Operating System Design
Douglas Comer
ComerThe Xinu Approach
Second EditionOperating System Design
The Xinu Approach
Second EditionOperating System Design
Second Edition
With Intel and ARM Examples
• Access online or download to your smartphone, tablet or PC/Mac
• Search the full text of this and other titles you own
• Make and share notes and highlights
• Copy and paste text and ﬁgures for use in your own documents
• Customize your view by changing font size and layoutWITH VITALSOURCE®
EBOOK
Widely lauded for avoiding the typical black box approach found in other operating system textbooks, the first edition of this bestselling book taught readers how an operating system works and explained how to build it from the ground up. Continuing to follow a logical pattern for system design, Operating System Design: The Xinu Approach, Sec-ond Edition removes the mystery from operating system design and consolidates the body of material into a sys-tematic discipline. It presents a hierarchical design paradigm that organizes major operating system components in an orderly, understandable manner. The book guides readers through the construction of a conventional process-based operating system using prac-tical, straightforward primitives. It gives the implementation details of one set of primitives, usually the most popu-lar set. Once readers understand how primitives can be implemented on conventional hardware, they can then easily implement alternative versions.The text begins with a bare machine and proceeds step-by-step through the design and implementation of the Xinu operating system. The Xinu code runs on many hardware platforms. This second edition has been completely rewritten to contrast operating systems for RISC and CISC processors. Encouraging hands-on experimentation, the book provides updated code throughout and examples for two low-cost experimenter boards: BeagleBone Black from ARM and Galileo from Intel.Features• Covers topics in the order a designer follows when building a system• Uses inexpensive embedded platforms from ARM and Intel• Describes the main components in the design hierarchy • Presents example software that illustrates the functions provided by each hierarchy level• Gives readers the foundation to implement alternative versions of primitives• Includes many practical examples and exercises that facilitate hands-on learning with the code• Offers updated code and other information on the author’s websiteComputer Science & Engineering
K25117www.crcpress.com
K25117_cover.indd   1 1/6/15   10:33 AMOperating System Design The Xinu ApproachSecond EditionOperating System Design
Douglas ComerThe Xinu Approach
Second EditionUNIX is a registered trademark in the United States and other countries, licensed exclusively through X/Open Company, Ltd. Linux is a registered trade -
mark of Linus Torvalds. In the United States, Linux is a trademark registered to Linus Torvalds. Microsoft Windows is a trademark of Microsoft Cor -
poration. Microsoft is a registered trademark of Microsoft Corporation. Solaris is a trademark of Sun Microsystems, Incorporated. MIPS is a registered 
trademark of MIPS Technologies, Inc. IBM is a registered trademark of International Business Machines. Mac is a trademark of Apple, Inc. Intel is a 
registered trademark of Intel Corporation. Galileo is a registered trademark of Intel Corporation. mini-PCI Express is a trademark of Intel Corporation. 
ARM is a registered trademark of ARM Limited. Other trademarks are the property of their respective owners.
CRC Press
Taylor & Francis Group
6000 Broken Sound Parkway NW, Suite 300
Boca Raton, FL 33487-2742
© 2015 by Taylor & Francis Group, LLC
CRC Press is an imprint of Taylor & Francis Group, an Informa business
No claim to original U.S. Government works
Version Date: 20141204
International Standard Book Number-13: 978-1-4987-1244-6 (eBook - PDF)
This book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been made to publish reliable data and 
information, but the author and publisher cannot assume responsibility for the validity of all materials or the consequences of their use. The authors and 
publishers have attempted to trace the copyright holders of all material reproduced in this publication and apologize to copyright holders if permission 
to publish in this form has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may rectify in any 
future reprint.
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or utilized in any form by any electronic, 
mechanical, or other means, now known or hereafter invented, including photocopying, microfilming, and recording, or in any information storage or 
retrieval system, without written permission from the publishers.
For permission to photocopy or use material electronically from this work, please access www.copyright.com (http://www.copyright.com/) or contact 
the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400. CCC is a not-for-profit organization that provides 
licenses and registration for a variety of users. For organizations that have been granted a photocopy license by the CCC, a separate system of payment 
has been arranged.
Trademark Notice:  Product or corporate names may be trademarks or registered trademarks, and are used only for identification and explanation without 
intent to infringe.
Visit the Taylor & Francis Web site at
http://www.taylorandfrancis.com
and the CRC Press Web site at
http://www.crcpress.comTo my wife, Chris, and our children, Sharon and ScottContentsxixPrefacexxiiiAbout the Author3Chapter 1 Introduction And Overview1.1 Operating Systems     31.2 Approach Used In The Text     51.3 A Hierarchical Design     51.4 The Xinu Operating System    71.5 What An Operating System Is Not     81.6 An Operating System Viewed From The Outside     91.7 Remainder Of The Text     101.8 Perspective     111.9 Summary     1115Chapter 2 Concurrent Execution And Operating System Services2.1 Introduction     152.2 Programming Models For Multiple Activities     162.3 Operating System Services     172.4 Concurrent Processing Concepts And Terminology     172.5 Distinction Between Sequential And Concurrent Programs     192.6 Multiple Processes Sharing A Single Piece Of Code     212.7 Process Exit And Process Termination     232.8 Shared Memory, Race Conditions, And Synchronization     242.9 Semaphores And Mutual Exclusion     282.10 Type Names Used In Xinu     302.11 Operating System Debugging With Kputc And Kprintf     312.12 Perspective     322.13 Summary     32viiiContents37Chapter 3 An Overview Of The Hardware And Runtime Environment3.1 Introduction     373.2 Physical And Logical Organizations Of A Platform     383.3 Instruction Sets     383.4 General-purpose Registers     393.5 I/O Buses And The Fetch-Store Paradigm     413.6 Direct Memory Access     423.7 The Bus Address Space    423.8 Bus Startup And Configuration     433.9 Calling Conventions And The Runtime Stack    443.10 Interrupts And Interrupt Processing    473.11 Vectored Interrupts     483.12 Exception Vectors And Exception Processing     483.13 Clock Hardware     493.14 Serial Communication     493.15 Polled vs. Interrupt-driven I/O     493.16 Storage Layout     503.17 Memory Protection     513.18 Hardware Details And A System On Chip Architecture    513.19 Perspective     523.20 Hardware References     5257Chapter 4 List And Queue Manipulation4.1 Introduction     574.2 A Unified Structure For Linked Lists Of Processes    584.3 A Compact List Data Structure     594.4 Implementation Of The Queue Data Structure     614.5 Inline Queue Manipulation Functions     624.6 Basic Functions To Extract A Process From A List     634.7 FIFO Queue Manipulation     654.8 Manipulation Of Priority Queues    684.9 List Initialization     704.10 Perspective     714.11 Summary     7275Chapter 5 Scheduling And Context Switching5.1 Introduction     755.2 The Process Table     765.3 Process States     795.4 Ready And Current States     80Contents        ix5.5 A Scheduling Policy     805.6 Implementation Of Scheduling     815.7 Deferred Rescheduling     855.8 Implementation Of Context Switching     855.9 State Saved In Memory     865.10 Context Switch Operation     875.11 An Address At Which To Restart A Process    915.12 Concurrent Execution And A Null Process    925.13 Making A Process Ready And The Scheduling Invariant     935.14 Other Process Scheduling Algorithms     945.15 Perspective     955.16 Summary     9599Chapter 6 More Process Management6.1 Introduction     996.2 Process Suspension And Resumption     996.3 Self–suspension And Information Hiding     1006.4 The Concept Of A System Call     1016.5 Interrupt Control With Disable And Restore    1036.6 A System Call Template     1046.7 System Call Return Values SYSERR And OK     1056.8 Implementation Of Suspend     1056.9 Suspending The Current Process    1076.10 The Value Returned By Suspend     1076.11 Process Termination And Process Exit     1086.12 Process Creation     1116.13 Other Process Manager Functions     1156.14 Summary     117123Chapter 7 Coordination Of Concurrent Processes7.1 Introduction     1237.2 The Need For Synchronization     1237.3 A Conceptual View Of Counting Semaphores    1257.4 Avoidance Of Busy Waiting     1257.5 Semaphore Policy And Process Selection     1267.6 The Waiting State     1277.7 Semaphore Data Structures     1287.8 The Wait System Call     1297.9 The Signal System Call     1307.10 Static And Dynamic Semaphore Allocation     1317.11 Example Implementation Of Dynamic Semaphores     132xContents7.12 Semaphore Deletion     1337.13 Semaphore Reset     1357.14 Coordination Across Parallel Processors (Multicore)    1367.15 Perspective     1377.16 Summary     137143Chapter 8 Message Passing8.1 Introduction     1438.2 Two Types Of Message Passing Services    1438.3 Limits On Resources Used By Messages     1448.4 Message Passing Functions And State Transitions     1458.5 Implementation Of Send     1468.6 Implementation Of Receive     1488.7 Implementation Of Non-Blocking Message Reception     1498.8 Perspective     1498.9 Summary     150153Chapter 9 Basic Memory Management9.1 Introduction     1539.2 Types Of Memory     1539.3 Definition Of A Heavyweight Process     1549.4 Memory Management In Our Example System     1559.5 Program Segments And Regions Of Memory    1569.6 Dynamic Memory Allocation     1579.7 Design Of The Low–level Memory Manager     1589.8 Allocation Strategy And Memory Persistence     1599.9 Keeping Track Of Free Memory     1599.10 Implementation Of Low–level Memory Management     1609.11 Data Structure Definitions Used With Free Memory    1619.12 Allocating Heap Storage     1629.13 Allocating Stack Storage     1659.14 Releasing Heap And Stack Storage     1679.15 Perspective     1709.16 Summary     170175Chapter 10 High-level Memory Management and Virtual Memory10.1 Introduction     17510.2 Partitioned Space Allocation     176 10.3 Buffer Pools     17610.4 Allocating A Buffer     178Contents        xi10.5 Returning Buffers To The Buffer Pool     179 10.6 Creating A Buffer Pool     18110.7 Initializing The Buffer Pool Table     18310.8 Virtual Memory And Memory Multiplexing     184 10.9 Real And Virtual Address Spaces    18510.10 Hardware For Demand Paging     18610.11 Address Translation With A Page Table     187 10.12 Metadata In A Page Table Entry     18810.13 Demand Paging And Design Questions     189 10.14 Page Replacement And Global Clock     190 10.15 Perspective     19110.16 Summary     191195Chapter 11 High-level Message Passing11.1 Introduction     19511.2 Inter–process Communication Ports     195 11.3 The Implementation Of Ports     19611.4 Port Table Initialization     197 11.5 Port Creation     19911.6 Sending A Message To A Port     20011.7 Receiving A Message From A Port     202 11.8 Port Deletion And Reset     20411.9 Perspective     207 11.10 Summary     207211Chapter 12 Interrupt Processing12.1 Introduction     21112.2 The Advantage Of Interrupts     212 12.3 Interrupt Processing     21212.4 Vectored Interrupts     21312.5 Integration Of Interrupts And Exceptions    214 12.6 ARM Exception Vectors Using Code     21512.7 Assignment Of Device Interrupt Vector Numbers     219 12.8 Interrupt Dispatching     22012.9 The Structure Of Interrupt Software     221 12.10 Disabling Interrupts     22312.11 Constraints On Functions That Interrupt Code Invokes    225 12.12 The Need To Reschedule During An Interrupt     22512.13 Rescheduling During An Interrupt     226 12.14 Perspective     22712.15 Summary     228xiiContents233Chapter 13 Real-time Clock Management13.1 Introduction     233 13.2 Timed Events     23413.3 Real-time Clocks And Timer Hardware     234 13.4 Handling Real-time Clock Interrupts     235 13.5 Delay And Preemption     23613.6 Implementation Of Preemption     23713.7 Efficient Management Of Delay With A Delta List     238 13.8 Delta List Implementation     23913.9 Putting A Process To Sleep     241 13.10 Timed Message Reception     24413.11 Awakening Sleeping Processes     248 13.12 Clock Interrupt Processing     249 13.13 Clock Initialization     25113.14 Perspective     254 13.15 Summary     255259Chapter 14 Device–independent Input And Output14.1 Introduction     25914.2 Conceptual Organization Of I/O And Device Drivers    260 14.3 Interface And Driver Abstractions     26114.4 An Example I/O Interface     26214.5 The Open-Read-Write-Close Paradigm     26314.6 Bindings For I/O Operations And Device Names     264 14.7 Device Names In Xinu     26514.8 The Concept Of A Device Switch Table     26514.9 Multiple Copies Of A Device And Shared Drivers    266 14.10 The Implementation Of High–level I/O Operations     269 14.11 Other High–level I/O Functions     27114.12 Open, Close, And Reference Counting     275 14.13 Null And Error Entries In Devtab    27714.14 Initialization Of The I/O System    278 14.15 Perspective     28314.16 Summary     283287Chapter 15 An Example Device Driver15.1 Introduction     28715.2 Serial Communication Using UART Hardware     287 15.3 The Tty Abstraction     28815.4 Organization Of A Tty Device Driver    289Contents        xiii15.5 Request Queues And Buffers     29015.6 Synchronization Of Upper Half And Lower Half     291 15.7 UART Hardware FIFOs And Driver Design     292 15.8 The Concept Of A Control Block    29315.9 Tty Control Block And Data Declarations     293 15.10 Minor Device Numbers     29615.11 Upper–half Tty Character Input (ttygetc)    297 15.12 Upper–half Tty Read Function (ttyread)    298 15.13 Upper–half Tty Character Output (ttyputc)    300 15.14 Starting Output (ttykickout)     30115.15 Upper–half Tty Multiple Character Output (ttywrite)     302 15.16 Lower–half Tty Driver Function (ttyhandler)     30315.17 Output Interrupt Processing (ttyhandle_out)     306 15.18 Tty Input Processing (ttyhandle_in)     30815.19 Tty Control Block Initialization (ttyinit)     315 15.20 Device Driver Control (ttycontrol)     31715.21 Perspective     319 15.22 Summary     320325Chapter 16 DMA Devices And Drivers (Ethernet)16.1 Introduction     32516.2 Direct Memory Access And Buffers     325 16.3 Multiple Buffers And Rings     32616.4 An Example Ethernet Driver Using DMA     327 16.5 Device Hardware Definitions And Constants     328 16.6 Rings And Buffers In Memory    33116.7 Definitions Of An Ethernet Control Block    333 16.8 Device And Driver Initialization     33616.9 Reading From An Ethernet Device    343 16.10 Writing To An Ethernet Device    34716.11 Handling Interrupts From An Ethernet Device    349 16.12 Ethernet Control Functions     35216.13 Perspective     353 16.14 Summary     354357Chapter 17 A Minimal Internet Protocol Stack17.1 Introduction     35717.2 Required Functionality     35817.3 Simultaneous Conversations, Timeouts, And Processes    359 17.4 A Consequence Of The Design     35917.5 ARP Functions     360xivContents17.6 Definition Of A Network Packet    371 17.7 The Network Input Process    37317.8 Definitions For IP     377 17.9 IP Functions     37717.10 Definition Of The UDP Table     388 17.11 UDP Functions     38917.12 Internet Control Message Protocol     403 17.13 Dynamic Host Configuration Protocol     404 17.14 Perspective     41217.15 Summary     413417Chapter 18 A Remote Disk Driver18.1 Introduction     41718.2 The Disk Abstraction     41718.3 Operations A Disk Driver Supports     41818.4 Block Transfer And High–level I/O Functions     418 18.5 A Remote Disk Paradigm     41918.6 The Important Concept Of Caching     420 18.7 Semantics Of Disk Operations     42118.8 Definition Of Driver Data Structures     421 18.9 Driver Initialization (rdsinit)     42718.10 The Upper–half Open Function (rdsopen)     43018.11 The Remote Communication Function (rdscomm)     432 18.12 The Upper–half Write Function (rdswrite)     43518.13 The Upper–half Read Function (rdsread)     438 18.14 Flushing Pending Requests     44218.15 The Upper–half Control Function (rdscontrol)     442 18.16 Allocating A Disk Buffer (rdsbufalloc)     44518.17 The Upper–half Close Function (rdsclose)    44718.18 The Lower–half Communication Process (rdsprocess)     448 18.19 Perspective     45318.20 Summary     454459Chapter 19 File Systems19.1 What Is A File System?    45919.2 An Example Set Of File Operations     460 19.3 Design Of A Local File System    46119.4 Data Structures For The Xinu File System    461 19.5 Implementation Of The Index Manager     462 19.6 Clearing An Index Block (lfibclear)     46719.7 Retrieving An Index Block (lfibget)     468Contents        xv19.8 Storing An Index Block (lfibput)     46919.9 Allocating An Index Block From The Free List (lfiballoc)     471 19.10 Allocating A Data Block From The Free List (lfdballoc)     472 19.11 Using The Device-Independent I/O Functions For Files     474 19.12 File System Device Configuration And Function Names     474 19.13 The Local File System Open Function (lfsopen)     47519.14 Closing A File Pseudo-Device (lflclose)     483 19.15 Flushing Data To Disk (lfflush)     48319.16 Bulk Transfer Functions For A File (lflwrite, lflread)     486 19.17 Seeking To A New Position In the File (lflseek)    48819.18 Extracting One Byte From A File (lflgetc)     489 19.19 Changing One Byte In A File (lflputc)     49019.20 Loading An Index Block And A Data Block (lfsetup)     492 19.21 Master File System Device Initialization (lfsinit)     49619.22 Pseudo-Device Initialization (lflinit)     497 19.23 File Truncation (lftruncate)     49919.24 Initial File System Creation (lfscreate)     501 19.25 Perspective     50319.26 Summary     504509Chapter 20 A Remote File Mechanism20.1 Introduction     50920.2 Remote File Access     509 20.3 Remote File Semantics     51020.4 Remote File Design And Messages     51020.5 Remote File Server Communication (rfscomm)     518 20.6 Sending A Basic Message (rfsndmsg)     52020.7 Network Byte Order     52220.8 A Remote File System Using A Device Paradigm     522 20.9 Opening A Remote File (rfsopen)     52420.10 Checking The File Mode (rfsgetmode)     527 20.11 Closing A Remote File (rflclose)     52820.12 Reading From A Remote File (rflread)     529 20.13 Writing To A Remote File (rflwrite)     532 20.14 Seeking On A Remote File (rflseek)     53520.15 Character I/O On A Remote File (rflgetc, rflputc)     536 20.16 Remote File System Control Functions (rfscontrol)     537 20.17 Initializing The Remote File System (rfsinit, rflinit)     541 20.18 Perspective     54320.19 Summary     543xviContents547Chapter 21 A Syntactic Namespace21.1 Introduction     54721.2 Transparency And A Namespace Abstraction     547 21.3 Myriad Naming Schemes     54821.4 Naming System Design Alternatives     550 21.5 Thinking About Names Syntactically    550 21.6 Patterns And Replacements     55121.7 Prefix Patterns     55121.8 Implementation Of A Namespace     55221.9 Namespace Data Structures And Constants     55221.10 Adding Mappings To The Namespace Prefix Table     553 21.11 Mapping Names With The Prefix Table     55521.12 Opening A Named File     559 21.13 Namespace Initialization     56021.14 Ordering Entries In The Prefix Table     562 21.15 Choosing A Logical Namespace    56321.16 A Default Hierarchy And The Null Prefix    564 21.17 Additional Object Manipulation Functions     56421.18 Advantages And Limits Of The Namespace Approach     566 21.19 Generalized Patterns     56621.20 Perspective     567 21.21 Summary     568573Chapter 22 System Initialization22.1 Introduction     57322.2 Bootstrap: Starting From Scratch     57322.3 An Example Of Booting Over A Network     574 22.4 Operating System Initialization     57522.5 Xinu Initialization     576 22.6 Xinu System Startup     57922.7 Transforming A Program Into A Process    583 22.8 Perspective     58422.9 Summary     584589Chapter 23 Subsystem Initialization And Memory Marking23.1 Introduction     58923.2 Self-initializing Modules     59023.3 Self-initializing Modules In A Concurrent System    591 23.4 Self-initialization In The Presence Of Reboot     59323.5 Initialization Using Accession Numbers     593Contents        xvii23.6 A Generalized Memory Marking Scheme     59523.7 Data Declarations For The Memory Marking System     596 23.8 Implementation Of Marking     59823.9 Perspective     599 23.10 Summary     599603Chapter 24 Exception Handling24.1 Introduction     60324.2 Terminology: Faults, Checks, Traps, And Exceptions     603 24.3 Vectored Exceptions And Maskable Interrupts     60424.4 Types Of Exceptions     604 24.5 Handling Exceptions     60524.6 Exception Vector Initialization     60624.7 Panic In The Face Of Catastrophic Problems     606 24.8 Implementation Of Panic     60724.9 Perspective     607 24.10 Summary     608611Chapter 25 System Configuration25.1 Introduction     61125.2 The Need For Multiple Configurations     611 25.3 Configuration In Xinu     61325.4 Contents Of The Xinu Configuration File     613 25.5 Computation Of Minor Device Numbers     616 25.6 Steps In Configuring A Xinu System    61625.7 Perspective     617 25.8 Summary     617621Chapter 26 An Example User Interface: The Xinu Shell26.1 Introduction     62126.2 What Is A User Interface?    62226.3 Commands And Design Principles     62226.4 Design Decisions For A Simplified Shell     623 26.5 Shell Organization And Operation     62326.6 The Definition Of Lexical Tokens     62426.7 The Definition Of Command-Line Syntax    625 26.8 Implementation Of The Xinu Shell     62526.9 Storage Of Tokens     62826.10 Code For The Lexical Analyzer     629xviiiContents26.11 The Heart Of The Command Interpreter    63326.12 Command Name Lookup And Builtin Processing     641 26.13 Arguments Passed To Commands     64126.14 Passing Arguments To A Non-builtin Command     643 26.15 I/O Redirection     64626.16 An Example Command Function (sleep)     647 26.17 Perspective     64926.18 Summary     650Appendix 1   Porting An Operating System 653A1.1 Introduction     653A1.2 Motivation: Evolving Hardware     654A1.3 Steps Taken When Porting An Operating System     654 A1.4 Programming To Accommodate Change     660A1.5 Summary     662Appendix 2   Xinu Design Notes 663A2.1 Introduction     663 A2.2 Overview     663A2.3 Xinu Characteristics     664 A2.4 Xinu Implementation     665A2.5 Major Concepts And Implementation    667669IndexPrefaceBuilding a computer operating system is like weaving a fine tapestry. In eachcase, the ultimate goal is a large, complex artifact with a unified and pleasing design,and in each case, the artifact is constructed with small, intricate steps. As in a tapestry, small details are essential because a minor mismatch is easily noticed — like stitches in a tapestry, each small piece added to an operating system must fit the overall design. Therefore, the mechanics of assembling pieces forms only a minor part of the overall process; a masterful creation must start with a pattern, and all artisans who work on the system must follow the pattern.Ironically, few operating system textbooks or courses explain underlying patterns and principles that form the basis for operating system construction. Students form the impression that an operating system is a black box, and textbooks reinforce the misimpression by explaining operating system features and focusing on how to use operating system facilities. More important, because they only learn how an operating system appears from the outside, students are left with the feeling that an operating sys-tem consists of a set of interface functions that are connected by a morass of mysterious code containing many machine-dependent tricks.Surprisingly, students often graduate with the impression that research on operating systems is over: existing operating systems, constructed by commercial companies and the open source community, suffice for all needs. Nothing could be further from the truth. Ironically, even though fewer companies are now producing conventional operat-ing systems for personal computers, the demand for operating system expertise is rising and companies are hiring students to work on operating systems. The demand arises from inexpensive microprocessors embedded in devices such as smart phones, video games, wireless sensors, cable and set-top boxes, and printers.When working in the embedded world, knowledge of principles and structures is essential because a programmer may be asked to build new mechanisms inside an operating system or to modify an operating system for new hardware. Furthermore, writing applications for embedded devices requires an appreciation for the underlying operating system — it is impossible to exploit the power of small embedded processors without understanding the subtleties of operating system design.This book removes the mystery from operating system design, and consolidates the body of material into a systematic discipline. It reviews the major system components, and imposes a hierarchical design paradigm that organizes the components in an order-ly, understandable manner. Unlike texts that survey the field by presenting as many al-ternatives as possible, the reader is guided through the construction of a conventional process-based operating system, using practical, straightforward primitives. The text begins with a bare machine, and proceeds step-by-step through the design and imple-xxOperating System Designmentation of a small, elegant system. The system, called Xinu, serves as an exampleand a pattern for system design.Although it is small enough to fit into the text, Xinu includes all the components that constitute an ordinary operating system: memory management, process manage-ment, process coordination and synchronization, interprocess communication, real-time clock management, device-independent I/O, device drivers, network protocols, and a file system. The components are carefully organized into a multi-level hierarchy, making the interconnections among them clear and the design process easy to follow. Despite its size, Xinu retains much of the power of larger systems. Xinu is not a toy — it has been used in many commercial products by companies such as Mitsubishi, Lexmark, HP, IBM, and Woodward (woodward.com), Barnard Software, and Mantissa Corpora-tion. An important lesson to be learned is that good system design can be as important on small embedded systems as on large systems and that much of the power arises from choosing good abstractions.The book covers topics in the order a designer follows when building a system. Each chapter describes a component in the design hierarchy, and presents example software that illustrates the functions provided by that level of the hierarchy. The ap-proach has several advantages. First, each chapter explains a successively larger subset of the operating system than the previous chapters, making it possible to think about the design and implementation of a given level independent of the implementation of succeeding levels. Second, the details of a given chapter can be skipped on first reading — a reader only needs to understand the services that the level provides, not how those services are implemented. Third, reading the text sequentially allows a reader to under-stand a given function before the function is used to build others. Fourth, intellectually deep subjects like support for concurrency arise early, before higher-level services have been introduced. Readers will see that the most essential functionality only occupies a few lines of code, which allows us to defer the bulk of the code (networking and file systems) until later when the reader is better prepared to understand details and refer-ences to basic functions.Unlike many other books on operating systems, this text does not attempt to re-view every alternative for each system component, nor does it survey existing commer-cial systems. Instead, it shows the implementation details of one set of primitives, usu-ally the most popular set. For example, the chapter on process coordination explains semaphores (the most widely accepted process coordination primitives), relegating a discussion of other primitives (e.g., monitors) to the exercises. Our goal is to remove all the mystery about how primitives can be implemented on conventional hardware. Once the essential magic of a particular set of primitives is understood, the implementa-tion of alternative versions will be easy to master.The Xinu code presented in the text runs on many hardware platforms. We will focus on two low-cost experimenter boards that use two popular processor architectures: a Galileo board that contains an Intel (x86) processor and a BeagleBone Black that con-tains an ARM processor. The paradigm is that a programmer uses conventional tools (editor, compiler, and linker) to create a Xinu image. The image is then loaded onto a target board, and the board boots the Xinu operating system.Preface        xxiThe book is designed for advanced undergraduate or graduate-level courses, andfor computing professionals who want to understand operating systems. Although thereis nothing inherently difficult about any topic, covering most of the material in one semester demands an extremely rapid pace usually unattainable by undergraduates. Few undergraduates are adept at reading code, and fewer still understand the details of a run-time environment or machine architecture. Thus, they need to be guided through the chapters on process management and process synchronization carefully. Choosing items to omit depends largely on the background of students who take the course. If time is limited, I recommend covering Chapters 1–7 (process management), 9 (basic memory management), 12 (interrupt processing), 13 (clock management), 14 (device-independent I/O), and 19 (file systems). If students have taken a data structures course that covers memory management and list manipulation, Chapters 4 and 9 can be skipped. It is important for students to understand that most operating systems include network communication. If they will take a separate course in networking, however, they can skip Chapter 17 on network protocols. The text includes chapters on both a re-mote disk system (18) and a remote file system (20); one of the two can be skipped. The chapter on a remote disk system may be slightly more pertinent because it intro-duces the topic of disk block caching, which is central in many operating systems.In grad courses, class time can be spent discussing motivations, principles, trade-offs, alternative sets of primitives, and alternative implementations. Students should emerge with a firm understanding of the process model and the relationship between in-terrupts and processes as well as the ability to understand, create, and modify system components. They should have a complete mental model of the entire system, and know how all the pieces interact. Two topics should be included in both graduate and undergraduate courses: the important metamorphosis that occurs during startup when a sequential program is transformed into a process, and the transformation in the shell when a sequence of characters on an input line become string arguments passed to a command process.In all cases, learning improves dramatically if students have hands-on experience with the system. The low cost of the boards we have selected (they are available forless than $50 US) means each student can afford to purchase a board and the cables needed to connect it to a laptop or other development computer. Ideally, they can start to use the system in the first few days or weeks of the class before they try to under-stand the internal structure. Chapter 1 provides a few examples and encourages experi-mentation. (It is surprising how many students take operating system courses without ever writing a concurrent program or using system facilities.) Many of the exercises suggest improvements, experiments, and alternative implementations. Larger projects are also possible. Examples that have been used with various hardware include: a pag-ing system, mechanisms to synchronize execution across computers, and the design of a virtual network. Other students have transported Xinu to various processors or built de-vice drivers for various I/O devices. Of course, a background in programming is as-sumed — working on the code requires a knowledge of the C programming language and a basic understanding of data structures, including linked lists, stacks, and queues.xxiiOperating System DesignAt Purdue, we have a lab with an automated system providing access to the experi-menter boards. A student uses cross-development tools on a conventional Linux system to create a Xinu image. The student then runs an application that uses the lab network to allocate one of the boards, load the image onto the board, connect the console linefrom the board to a window on the student’s screen, and boot the image. Because the hardware is inexpensive, a lab can be constructed at very low cost. For details, contact the author or look on the website:www.xinu.cs.purdue.eduI owe much to my experiences, good and bad, with commercially available operat-ing systems. Although Xinu differs internally from existing systems, the fundamental ideas are not new. Many basic ideas and names have been taken from Unix. However, readers should be aware that many of the function arguments and the internal structure of the two systems differ dramatically — applications written for one system will not run on the other without modification. Xinu is not Unix.I gratefully acknowledge the help of many people who contributed ideas, hard work, and enthusiasm to the Xinu project. Over the years, many graduate students at Purdue have worked on the system, ported it, and written device drivers. The version in this book represents a complete rewrite, and many students at Purdue contributed. As we updated the code, we strove to preserve the elegance of the original design. Rajas Karandikar and Jim Lembke created drivers and the multi-step downloading system used on the Galileo. Students in my operating systems class, including Andres Bravo, Gregory Essertel, Michael Phay, Sang Rhee, and Checed Rodgers, found problems and contributed to the code. Special thanks go to my wife and partner, Christine, whose careful editing and suggestions made many improvements throughout.Douglas ComerAbout the AuthorDouglas Comer, Distinguished Professor of Computer Science at Purdue Universi-ty, is an internationally recognized expert on computer networking, the TCP/IP proto-cols, the Internet, and operating systems design. The author of numerous refereed arti-cles and technical books, he is a pioneer in the development of curriculum and labora-tories for research and education.A prolific author, Dr. Comer’s popular books have been translated into sixteen languages, and are used in industry as well as computer science, engineering, and busi-ness departments around the world. His landmark three-volume series Internetworking With TCP/IP revolutionized networking and network education. His textbooks and in-novative laboratory manuals have shaped and continue to shape graduate and undergra-duate curricula.The accuracy and insight of Dr. Comer’s books reflect his extensive background in computer systems. His research spans both hardware and software. He has created the Xinu operating system, written device drivers, and implemented network protocol software for conventional computers as well as network processors. Software that has resulted from Dr. Comer’s research has been used by industry in a variety of products.Dr. Comer has created and teaches courses on network protocols, operating sys-tems, and computer architecture for a variety of audiences, including courses for en-gineers as well as academic audiences. His innovative educational laboratories allow him and his students to design and implement working prototypes of large, complex systems, and measure the performance of the resulting prototypes. He continues to teach at companies, universities, and conferences around the world. In addition, Dr. Comer consults for industry on the design of computer networks and systems.For twenty years, Professor Comer served as editor-in-chief of the research journal Software — Practice and Experience. While on an extended leave from Purdue, heserved as Vice President of Research at Cisco Systems. He is a Fellow of the ACM, a Fellow of the Purdue Teaching Academy, and a recipient of numerous awards, includ-ing a Usenix Lifetime Achievement award.Additional information about Dr. Comer can be found at:www. cs. purdue. edu/ people/ comerand information about his books can be found at:www.comerbooks.comChapter Contents1.1 Operating Systems, 31.2 Approach Used In The Text, 51.3 A Hierarchical Design, 51.4 The Xinu Operating System, 71.5 What An Operating System Is Not, 81.6 An Operating System Viewed From The Outside, 91.7 Remainder Of The Text, 101.8 Perspective, 111.9 Summary, 111Introduction And Overview
Our little systems have their day.— Alfred, Lord Tennyson1.1 Operating SystemsHidden in every intelligent device and computer system is the software that con-trols processing, manages resources, and communicates with peripherals such as display screens, disks, computer networks, and printers. Collectively, the code that performs control and coordination chores has been referred to as an executive,amonitor,atask manager, and a kernel; we will use the broader term operating system.Computer operating systems are among the most complex objects created by mankind: they allow multiple computational processes and users to share a processor simultaneously, protect data from unauthorized access, and keep independent input/output (I/O) devices operating correctly. The high-level services an operating system offers are all achieved by executing intricately detailed, low-level hardware in-structions. Interestingly, an operating system is not an independent mechanism that controls a computer from the outside — it consists of software that is executed by the same processor that executes applications. In fact, when a processor is executing an ap-plication, the processor cannot be executing the operating system and vice versa.Arranging mechanisms that guarantee an operating system will always regain con-trol after an application runs complicates system design. The most impressive aspect ofan operating system, however, arises from the difference in functionality between the services offered and underlying hardware: an operating system provides impressively high-level services over extremely low-level hardware. As the book proceeds, we will understand how crude the underlying hardware can be, and see how much system software is required to handle even a simple device such as the serial I/O device used34 Introduction And Overview Chap. 1for a keyboard or mouse. The philosophy is straightforward: an operating systemshould provide abstractions that make programming easier rather than abstractions that reflect the underlying hardware. Thus, we conclude:An operating system is designed to hide low-level hardware detailsand to create an abstract machine that provides applications withhigh-level services.Operating system design is not a well-known craft. In the beginning, because computers were scarce and expensive, only a few programmers had an opportunity to work on operating systems. By the time advances in micro-electronic technology re-duced fabrication costs and made personal computers available, operating systems had become commodities, and few programmers need to work on them. Interestingly, mi-croprocessors have become so inexpensive that most electronic devices are now con-structed from programmable processors rather than from discrete logic. As a result, designing and implementing software systems for microprocessors and microcontrollers is no longer a task reserved for a few specialists; it has become a skill expected of com-petent systems programmers.Fortunately, our understanding of operating systems has grown along with the technology we use to produce new machines. Researchers have explored fundamental issues, formulated design principles, identified essential components, and devised ways that components can work together. More important, researchers have identified abstractions, such as files and current processes, that are common to all operating sys-tems, and have found efficient implementations for the abstractions. Finally, we have learned how to organize the components of an operating system into a meaningful struc-ture that simplifies system design and implementation.Compared to its early counterparts, a modern system is simple, clean, and portable.A well-designed system follows a basic pattern that partitions software into a set ofbasic components. As a result, a modern system can be easier to understand and modi-fy, can contain less code, and has less processing overhead than early systems.Vendors that sell large commercial operating systems include many extra software components along with an operating system. For example, a typical software distribu-tion includes compilers, linkers, loaders, library functions, and a set of applications. To distinguish between the extras and the basic system, we sometimes use the term kernel to refer to the code that remains resident in memory and provides key services such as support for concurrent processes. Throughout the text, we will assume the term operat-ing system refers to the kernel, and does not include all additional facilities. A design that minimizes the facilities in a kernel is sometimes called a microkernel design; our discussions will concentrate on a microkernel.Sec. 1.2        Approach Used In The Text 51.2 Approach Used In The TextThis book is a guide to the structure, design, and implementation of operating sys-tem kernels. Instead of merely surveying extant systems, listing their features, and describing functionality abstractly, the book takes an engineering approach. It explains how to construct each OS abstraction, and shows how the individual abstractions can be organized into an elegant, efficient design.Our approach provides two advantages. First, because the text covers every part of the system, a reader will see how an entire system fits together, not merely how one or two parts interact. Second, because source code is available for all pieces described in the text, no mystery remains about any part of the implementation — a reader can ob-tain a copy of the system to examine, modify, instrument, measure, extend, or transport to another architecture. By the end of the book, a reader will see how each piece of an operating system fits into the design, and will be prepared to understand alternative design choices.Our focus on implementation means that the software forms an integral part of the text. In fact, the code provides a centerpiece for discussion; one must read and studythe program listings to appreciate the underlying subtlety and engineering detail. The example code is minimal, which means a reader can concentrate on concepts without wading through many pages of code. Some of the exercises suggest improvements or modifications that require a reader to delve into details or invent alternatives; a skillful programmer will find additional ways to improve and extend the system.1.3 A Hierarchical DesignIf designed well, the interior of an operating system can be as elegant and clean as the best application program. The design described in this book achieves elegance by partitioning system functions into eight major categories, and organizing the com-ponents into a multi-level hierarchy. Each level of the system provides an abstract ser-vice, implemented in terms of the abstract services provided by lower levels. The ap-proach offers a property that will become apparent: successively larger subsets of the levels can be selected to form successively more powerful systems. We will see how a hierarchical approach provides a model for designers that helps reduce complexity.Another important property of our approach arises from runtime efficiency — a designer can structure pieces of an operating system into a hierarchy without introduc-ing extra overhead. In particular, our approach differs from a conventional layered sys-tem in which a function at level K can only invoke functions at level K–1. In our multi-level approach, the hierarchy only provides a conceptual model for a designer —at runtime, a function at a given level of the hierarchy can invoke any of the functions in lower levels directly. We will see that direct invocation makes the entire system effi-cient.6 Introduction And Overview Chap. 1Figure 1.1 illustrates the hierarchy used in the text, gives a preview of the com-ponents we will discuss, and shows the structure into which all pieces are organized.
HARDWAREMEMORY MANAGERPROCESS MANAGERPROCESS COORDINATIONINTERPROCESS COMMUNICATIONREAL-TIME CLOCK MANAGERDEVICE MANAGER AND DEVICE DRIVERSINTERMACHINE COMMUNICATIONFILE SYSTEMAPPLICATION PROGRAMS
Figure 1.1  The multi-level organization used in the text.Sec. 1.3        A Hierarchical Design 7At the heart of the hierarchy lies the computer hardware. Although not part of the operating system itself, modern hardware includes features that allow tight integration with an operating system. Thus, we think of the hardware as forming level zero of our hierarchy.Building out from the hardware, each higher level of operating system software provides more powerful primitives that shield applications from the raw hardware. A memory manager controls and allocates memory. Process management forms the most fundamental component of the operating system, and includes a scheduler and context switch. Functions in the next level constitute the rest of the process manager, providing primitives to create, kill, suspend, and resume processes. Just beyond the process manager comes a process coordination component that implements semaphores. Func-tions for real-time clock management occupy the next level, and allow application software to delay for a specified time. On top of the real-time clock level lies a level of device-independent I/O routines that provide familiar services, such as read and write. Above the device routines, a level implements network communication, and the level above that implements a file system. Application programs occupy the highest concep-tual level of the hierarchy — an application has access to all the facilities provided by lower levels.The internal organization of a system should not be confused with the services the system provides. Although components are organized into levels to make the designand implementation cleaner, the resulting hierarchical structure does not restrict system calls at runtime. That is, once the system has been built, facilities from all levels of the hierarchy can be exposed to applications. For example, an application can invoke sema-phore functions, such as wait and signal, that reside in the process coordination level just as easily as it can invoke functions such as putc that reside in an outer level. Thus, the multi-level structure describes only the internal implementation, and does not res-trict the services the system provides.1.4 The Xinu Operating SystemExamples in the book are taken from the Xinu† operating system. Xinu is a small, elegant system that is intended for use in an embedded environment, such as a cell phone or an MP3 player. Typically, Xinu is loaded into memory along with a fixed setof applications when the system boots. Of course, if memory is constrained or the hardware architecture uses a separate memory for instructions, Xinu can be executed from Flash or other read-only memory. In a typical system, however, executing from main memory produces higher performance.Xinu is not a toy; it is a powerful operating system that has been used in commer-cial products. For example, Xinu was used in pinball games sold under theWilliams/  Bally brand (the major manufacturer), Woodward Corporation uses Xinu to control large gas/steam and diesel/steam turbine engines, and Lexmark Corporation used Xinu as the operating system in its printers until 2005. In each case, when the device was powered on, the hardware loaded a memory image that contained Xinu.†The name stands for Xinu Is Not Unix. As we will see, the internal structure of Xinu differs completelyfrom the internal structure of Unix (or Linux). Xinu is smaller, more elegant, and easier to understand.8 Introduction And Overview Chap. 1Xinu contains the fundamental components of an operating system, including: process, memory, and timer management mechanisms, interprocess communication fa-cilities, device-independent I/O functions, and Internet protocol software. Xinu can control I/O devices and perform chores such as reading keystrokes from a keyboard or keypad, displaying characters on an output device, managing multiple, simultaneous computations, controlling timers, passing messages between computations, and allowing applications to access the Internet.Xinu illustrates how the hierarchical design that is described above applies in prac-tice. It also shows how all the pieces of an operating system function as a uniform, in-tegrated whole, and how an operating system makes services available to application programs.1.5 What An Operating System Is NotBefore proceeding into the design of an operating system, we should agree on what we are about to study. Surprisingly, many programmers do not have a correct intuitive definition of an operating system. Perhaps the problem arises because vendors and computer professionals often apply the terminology broadly to refer to all software sup-plied by a vendor as well as the operating system itself, or perhaps confusion arises be-cause few programmers access system services directly. In any case, we can clarify the definition quickly by ruling out well-known items that are not part of the operating sys-tem kernel.First, an operating system is not a language or a compiler. Of course, an operating system must be written in some language, and languages have been designed that incor-porate operating systems features and facilities. Further confusion arises because a software vendor may offer one or more compilers that have been integrated with their operating system. However, an operating system does not depend on an integrated language facility — we will see that a system can be constructed using a conventional language and a conventional compiler.Second, an operating system is not a windowing system or a browser. Many com-puters and electronic devices have a screen that is capable of displaying graphics, and sophisticated systems permit applications to create and control multiple, independent windows. Although windowing mechanisms rely on an operating system, a windowing system can be replaced without replacing the operating system.Third, an operating system is not a command interpreter. Embedded systems often include a Command Line Interface (CLI); some embedded systems rely on a CLI for all control. In a modern operating system, however, the command interpreter operates as an application program, and the interpreter can be changed without modifying the underlying system.Fourth, an operating system is not a library of functions or methods. Almost all application programs use library functions, and the software found in libraries can offer significant convenience and functionality. Some operating systems even employ an op-timization that allows code from a library to be loaded in memory and shared among allSec. 1.5        What An Operating System Is Not 9applications. Despite the close relationship, library software remains independent of the underlying operating system.Fifth, an operating system is not the first code that runs after a computer is powered on. Instead, the computer contains firmware (i.e., a program in non-volatile memory) that initializes various pieces of hardware, loads a copy of the operating sys-tem into memory, and then jumps to the beginning of the operating system. On a PC, for example, the firmware is known as the Basic Input Output System (BIOS). We will learn more about bootstrapping in Chapter 22.1.6 An Operating System Viewed From The OutsideThe essence of an operating system lies in the services it provides to applications.An application accesses operating system services by making system calls. In sourcecode, a system call appears to be a conventional function invocation. At runtime, how-ever, a system call and a conventional function call differ. Instead of transferring con-trol to another function, a system call transfers control to the operating system, which performs the requested service for the application. Taken as a set, system calls establish a well-defined boundary between applications and the underlying operating system that is known as an Application Program Interface (API)†. The API defines the services that the system provides as well as the details of how an application uses the services.To appreciate the interior of an operating system, one must first understand the characteristics of the API and see how applications use the services. This chapter intro-duces a few fundamental services, using examples from the Xinu operating system to il-lustrate the concepts. For example, the Xinu function putc writes a single character to a specified I/O device. Putc takes two arguments: a device identifier and a character to write. File ex1.c contains an example C program that writes the message “hi” on the console when run under Xinu://**eexx11..cc--mmaaiinn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**mmaaiinn--WWrriittee""hhii""oonntthheeccoonnssoollee**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddmmaaiinn((vvooiidd)){{ppuuttcc((CCOONNSSOOLLEE,,’’hh’’));;ppuuttcc((CCOONNSSOOLLEE,,’’ii’’));;ppuuttcc((CCOONNSSOOLLEE,,’’\\nn’’));;}}†The interface is also known as a system call interfaceor the kernel interface.10 Introduction And Overview Chap. 1The code introduces several conventions used throughout Xinu.  The statement:##iinncclluuddee<<xxiinnuu..hh>>inserts a set of declarations into a source program that allows the program to reference operating system parameters. For example, the Xinu configuration file defines symbolic constant CONSOLE to correspond to a console serial device a programmer uses to in-teract with the embedded system. Later, we will see that xinu.h contains a series of #include statements that reference files needed by the Xinu system, and we will learn how names like CONSOLE become synonymous with devices; for now, it is sufficient to know that the include statement must appear in any Xinu application.To permit communication with an embedded system (e.g., for debugging), the seri-al device on the embedded system can be connected to a terminal application on a con-ventional computer. Each time a user presses a key on the computer’s keyboard, the terminal application sends the keystroke over the serial line to the embedded system. Similarly, each time the embedded system sends a character to the serial device, the ter-minal application displays the character on the user’s screen. Thus, a console provides two-way communication between the embedded system and the outside world.The main program listed above writes three characters to the console serial device: “h”, “i”, and a line feed (known as NEWLINE). The line feed is a control character that moves the cursor to the beginning of the next line. Xinu does not perform any special operations when the program sends control characters — control characters are merely passed on to the serial device just like alphanumeric characters. A control character has been included in the example to illustrate that putc is not line-oriented; in Xinu, a pro-grammer is responsible for terminating a line.The example source file introduces two important conventions followed throughoutthe book. First, the file begins with a one-line comment that contains the name of thefile (ex1.c). If a source file contains multiple functions, the name of each appears onthe comment line. Knowing the names of files will help you locate them in a machine-readable copy of Xinu. Second, the file contains a block comment that identifies the start of each function (main). Having a block comment before each function makes it easy to locate functions in a given file.1.7 Remainder Of The TextThe remainder of the text proceeds through the design of a system that follows the multi-level organization that Figure 1.1 illustrates. Chapter 2 describes concurrent pro-gramming and the services an operating system supplies. Successive chapters consider the levels in roughly the same order as they are designed and built: from the innermost outward. Each chapter explains the role of one level in the system, describes new abstractions, and illustrates the details with source code. Taken together, the chapters describe a complete, working system and explain how the components fit together in a clean and elegant design.Sec. 1.7        Remainder Of The Text 11Although the bottom-up approach may seem awkward at first, it shows how an operating system designer builds a system. The overall structure of the system will start to become clear by Chapter 9. By the end of Chapter 14, readers will understand a minimal kernel capable of supporting concurrent programs. By Chapter 20, the system will include remote file access, and by Chapter 22, the design will include a complete set of operating system functions and code to initialize the entire system.1.8 PerspectiveWhy study operating systems? It may seem pointless because commercial systems are widely available and relatively few programmers write operating system code. However, a strong motivation exists: even in small embedded systems, applications run on top of an operating system and use the services it provides. Therefore, understand-ing how an operating system works internally helps a programmer appreciate concurrent processing and make sensible choices about system services. In some cases, the behavior of application software can only be understood, and problems can only be solved, by understanding how an operating system manages concurrent process execu-tion.The key to learning operating systems lies in persistence. A concurrent paradigm requires you to think about computer programs in new ways. Until you grasp thebasics, it may seem confusing. Fortunately, you will not be overwhelmed with code —some of the most important ideas are contained neatly in a few lines of code. Once you understand what’s going on, you will be able to read operating systems code easily, understand why process coordination is needed, and see how functions work together. By the end of the text, you will be able to write or modify operating systems functions.1.9 SummaryAn operating system provides a set of convenient, high-level services over low-level hardware. Because most applications use operating system services, programmers need to understand operating system principles. Programmers who work on embedded devices need to understand operating system design more deeply. Using a hierarchical structure can make an operating system easier to design, understand, and modify.The text takes a practical approach. Instead of merely describing commercial sys-tems or listing operating system features, it uses an example system, Xinu, to illustrate how a system can be designed. Although it is small and elegant, Xinu is not a toy — it has been used in commercial products. Xinu follows a multi-level design in which software components are organized into eight conceptual levels. The text explains one level of the system at a time, beginning with the raw hardware and ending with a work-ing operating system.12 Introduction And Overview Chap. 1EXERCISES1.1 Should an operating system make hardware facilities available to application programs?Why or why not?1.2 What are the advantages of using a real operating system in examples?1.3 What are the eight major components of an operating system?1.4 In the Xinu multi-level hierarchy, can a function in the file system code use a function inthe process manager? Can a function in the process manager use a function in the file sys-tem? Explain.1.5 Explore the system calls available on your favorite operating system, and write a programthat uses them.1.6   Various programming languages have been designed that incorporate OS concepts such asprocesses and process synchronization primitives. Find an example language, and make alist of the facilities it offers.1.7 Search the web, and make a list of the major commercial operating systems that are in use.1.8  Compare the facilities in Linux and Microsoft’s Windows operating systems. Does eitherone support functionality that is not available in the other?1.9 The set of functions that an operating system makes available to application programs isknown as the Application Program Interface or the system call interface. Choose two ex-ample operating systems, count the functions in the interface that each makes available, and compare the counts.1.10 Extend the previous exercise by identifying functions that are available in one system butnot in the other. Characterize the purpose and importance of the functions.1.11 How large is an operating system? Choose an example system, and count the lines ofsource code used for the kernel.Chapter Contents2.1 Introduction, 152.2 Programming Models For Multiple Activities, 162.3 Operating System Services, 172.4 Concurrent Processing Concepts And Terminology, 172.5 Distinction Between Sequential And Concurrent Programs, 192.6 Multiple Processes Sharing A Single Piece Of Code, 212.7 Process Exit And Process Termination, 232.8 Shared Memory, Race Conditions, And Synchronization, 242.9 Semaphores And Mutual Exclusion, 282.10 Type Names Used In Xinu, 302.11 Operating System Debugging With Kputc And Kprintf, 312.12 Perspective, 322.13 Summary, 322Concurrent Execution And Operating System Services
From an article on a new operating system for theIBM PC: Real concurrency — in which one program actually continues to function while you call up and use another — is more amazing but of small use to the average person. How many programs do you have that take more than a few seconds to perform any task?— New York Times, 25 April 19892.1 IntroductionThis chapter considers the concurrent programming environment that an operating system provides for applications. It describes a model of concurrent execution, andshows why applications that operate concurrently need mechanisms to coordinate and synchronize. It introduces basic concepts, such as processes and semaphores, and ex-plains how applications use such facilities.Instead of describing operating systems abstractly, the chapter uses concrete exam-ples from the Xinu system to illustrate concepts such as concurrency and synchroniza-tion. The chapter contains trivial applications that capture the essence of concurrent ex-ecution in a few lines of code. Later chapters expand the discussion by explaining in detail how an operating system implements each of the facilities described.1516 Concurrent Execution And Operating System Services Chap. 22.2 Programming Models For Multiple ActivitiesEven small computing devices are designed to handle multiple tasks at the same time. For example, while a voice call is connected, a cell phone can display the time of day, accept text messages, and allow the user to adjust the volume. More complex computing systems allow a user to run multiple applications that execute at the same time. The question arises: how should the software in such systems be organized? Three basic approaches can be used:Synchronous event loopAsynchronous event handlersConcurrent executionSynchronous event loop.The term synchronous refers to events that are coordinat-ed. A synchronous event loop uses a single, large iteration to handle coordination.During a given iteration of the loop, the code checks each possible activity and invokes the appropriate handler. Thus, the code has a structure similar to the following:while (1) { /* synchronous loop runs forever */Update time-of-day clock;if (screen timeout has expired) {turn off the screen;}if (volume button is being pushed) {adjust volume;}if (text message has arrived) {Display notification for user;} ...}Asynchronous event handlers. An asynchronous paradigm is used in systems where the hardware can be configured to invoke a handler for each event. For example, the code to adjust volume might be placed in memory at location 100, and the hardware is configured so that when the volume button is pressed, control transfers to location 100. Similarly, the hardware can be configured so that when a text message arrives, control transfers to location 200, and so on. A programmer writes a separate piece of code for each event, and uses global variables to coordinate the interactions. For exam-ple, if a user presses the mute button, the code associated with the mute event turns off the audio and records the status in a global variable. Later, when the user adjusts the volume, code associated with the volume button checks the global variable, turns on the audio, and changes the global variable to indicate that audio is on.Sec. 2.2        Programming Models For Multiple Activities 17Concurrent execution. The third paradigm used to organize multiple activities is the most significant: software is organized as a set of programs that each operate con-currently. The model is sometimes called run-to-completion because each computation appears to run until it chooses to stop. From a programmer’s point of view, concurrent execution is a delight. Compared to synchronous or asynchronous events, concurrent execution is more powerful, easier to understand, and less error-prone.The next sections describe operating systems that provide the support needed for concurrency, and characterize the concurrent model. Later chapters examine the under-lying operating system mechanisms and functions that enable a concurrent programming model.2.3 Operating System ServicesWhat are the main services that an operating system supplies? Although the de-tails vary from system to system, most systems supply the same basic services. The services (with the chapters of the text that describe them) are:Support for concurrent execution (5–6)Facilities for process synchronization (7)Inter-process communication mechanisms (8 and 11)Dynamic memory allocation (9)Management of address spaces and virtual memory (10)High-level interface for I/ O devices (13–15)Network and Internet communication (16–17)A file system and file access facilities (19–21)Concurrent execution is at the heart of an operating system, and we will see that concurrency affects each piece of operating system code. Thus, we begin by examining the facilities an operating system offers for concurrency, and use concurrency to show how an application program invokes services.2.4 Concurrent Processing Concepts And TerminologyConventional programs are called sequential because a programmer imagines a computer executing the code statement by statement; at any instant, the machine is exe-cuting exactly one statement. Operating systems support an extended view of computa-tion called concurrent processing. Concurrent processing means that multiple computa-tions can proceed “at the same time.”Many questions arise about concurrent processing. It is easy to imagine N in-dependent programs being executed simultaneously by N processors (i.e., N cores), but it is difficult to imagine a set of independent computations proceeding simultaneously18 Concurrent Execution And Operating System Services Chap. 2on a computer that has fewer than N processing units. Is concurrent computation possi-ble even if a computer has a single core? If multiple computations each proceed simul-taneously, how does the system keep one program from interfering with others? How do the programs cooperate so that only one takes control of an input or output device at a given time?Although many processors do incorporate some amount of parallelism, the most visible form of concurrency, multiple independent applications that execute simultane-ously, is a grand illusion. To create the illusion, an operating system uses a technique, called multitasking or multiprogramming— the operating system switches the available processor(s) among multiple programs, allowing a processor to execute one program for only a few milliseconds before moving on to another. When viewed by a human, the programs all appear to proceed. Multitasking forms the basis of most operating sys-tems. The only exceptions are systems used in basic embedded devices, such as a simplistic remote control used with a television, and safety-critical systems, such as flight avionics and medical device controllers. In such cases, designers use a synchro-nous event loop rather than a multitasking system, either to reduce cost or to guarantee that tight time constraints can be met absolutely.Systems that support multitasking can be divided into two broad categories:TimesharingReal-timeTimesharing.Atimesharing system gives equal priority to all computations, and permits computations to start or terminate at any time. Because they allow computa-tions to be created dynamically, timesharing systems are popular for computers that hu-man users operate. A timesharing system allows a human to leave an email application running and a background application playing music while using a browser to view a web page. The chief characteristic of a timesharing system is that the amount of proc-essing a computation receives is inversely proportional to the load on the system — if N computations are executing, each computation receives approximately 1/Nof the avail-able processor cycles. Thus, as more computations appear, each proceeds at a slower rate.Real-time. Because it is designed to meet performance constraints, a real-time sys-tem does not treat all computations equally. Instead, a real-time system assigns priori-ties to computations, and schedules the processor carefully to ensure that each computa-tion meets its required schedule. The chief characteristic of a real-time system arises from its ability to give the processor to high-priority tasks, even if other tasks are wait-ing. For example, by giving priority to voice transmission, a real-time system in a cell phone can guarantee that the conversation is uninterrupted, even if a user runs an appli-cation to view the weather or an application to play a game.Designers of multitasking systems have used a variety of terms to describe a single computation, including process, task, job, and thread of control. The terms process and job often connote a single computation that is self-contained and isolated from other computations. Typically, a process occupies a separate region of memory, and the operating system prevents a process from accessing the memory that has been assignedSec. 2.4        Concurrent Processing Concepts And Terminology 19to another process. The term task refers to a process that is declared statically. That is,a programming language allows a programmer to declare a task similar to the way one declares a function. The term thread refers to a type of concurrent process that shares an address space with other threads. Shared memory means that members of the set can exchange information efficiently. Early scientific literature used the term process to refer to concurrent execution in a generic sense; the Unix operating system popularized the idea that each process occupied a separate address space. The Mach system intro-duced a two-level concurrent programming scheme in which the operating system al-lows a user to create one or more processes that each operate in an independent region of memory, and to create multiple threads of control within each process. Linux fol-lows the Mach model. To refer to a Linux-style process, the word Process is written with an uppercase P.Because it is designed for an embedded environment, Xinu permits processes to share an address space. To be precise, we might say that Xinu processes follow a thread model. However, because the term process is widely accepted, we will use it throughout the text to refer generically to a concurrent computation.The next section helps distinguish concurrent execution from sequential execution by examining a few applications. As we will see, the difference plays a central role in operating system design — each piece of an operating system must be built to support concurrent execution.2.5 Distinction Between Sequential And Concurrent ProgramsWhen a programmer creates a conventional (i.e., sequential) program, the program-mer imagines a single processor executing the program step-by-step without interruption or interference. When writing code that will be executed concurrently, however, a pro-grammer must take a different view and imagine multiple computations executing simultaneously. The code inside an operating system provides an excellent example of code that must accommodate concurrency. At any given instant, multiple processes may be executing. In the simplest case, each process executes application code that no other process is executing. However, an operating system designer must plan for a situ-ation in which multiple processes have invoked a single operating system function, or even a case where multiple processes are executing the same instruction. To further complicate matters, the operating system may switch the processor among processes at any time; in a multitasking system, no guarantee can be made about the relative speed at which a given computation will proceed.Designing code to operate correctly in a concurrent environment provides a tough intellectual challenge because a programmer must ensure that all processes perform the intended function correctly, no matter what operating system code they execute or in which order they execute. We will see how the notion of concurrent execution affects each line of code in an operating system.To understand applications in a concurrent environment, consider the Xinu model. When it boots, Xinu creates a single concurrent process that starts running the main pro-20 Concurrent Execution And Operating System Services Chap. 2gram. The initial process can continue execution by itself, or it can create additional processes. When a new process is created, the original process continues to execute, and the new process executes concurrently. Either the original process or a new process can create additional processes that execute concurrently.As an example, consider the code for a concurrent main program that creates two additional processes. Each of the two new processes sends characters over the console serial device: the first process sends the letter A, and the second sends the letter B. File ex2.c contains the source code, which consists of a main program and two functions, sndA and sndB.//**eexx22..cc--mmaaiinn,,ssnnddAA,,ssnnddBB**//##iinncclluuddee<<xxiinnuu..hh>>vvooiiddssnnddAA((vvooiidd)),,ssnnddBB((vvooiidd));;//**------------------------------------------------------------------------------------------------------------------------------------------------**mmaaiinn--EExxaammpplleeooffccrreeaattiinnggpprroocceesssseessiinnXXiinnuu**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddmmaaiinn((vvooiidd)){{rreessuummee((ccrreeaattee((ssnnddAA,,11002244,,2200,,""pprroocceessss11"",,00))));;rreessuummee((ccrreeaattee((ssnnddBB,,11002244,,2200,,""pprroocceessss22"",,00))));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ssnnddAA--RReeppeeaatteeddllyyeemmiitt’’AA’’oonntthheeccoonnssoolleewwiitthhoouutttteerrmmiinnaattiinngg**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddssnnddAA((vvooiidd)){{wwhhiillee((11))ppuuttcc((CCOONNSSOOLLEE,,’’AA’’));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ssnnddBB--RReeppeeaatteeddllyyeemmiitt’’BB’’oonntthheeccoonnssoolleewwiitthhoouutttteerrmmiinnaattiinngg**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddssnnddBB((vvooiidd)){{wwhhiillee((11))ppuuttcc((CCOONNSSOOLLEE,,’’BB’’));;}}Sec. 2.5        Distinction Between Sequential And Concurrent Programs 21In the code, the main program never calls either function directly. Instead, the main program calls two operating system functions, create and resume. Each call to create forms a new process that will begin executing instructions at the address speci-fied by its first argument. In the example, the first call to create passes the address of function sndA, and the second call passes the address of function sndB.† Thus, the code creates a process to execute sndA and a process to execute sndB.  Create establishes a process, leaves the process ready to execute but temporarily suspended, and returns an integer value that is known as a process identifier or process ID. The operating system uses the process ID to identify the newly created process; an application uses the proc-ess ID to reference the process. In the example, the main program passes the ID re-turned by create to resume as an argument. Resume starts (i.e., unsuspends) the proc-ess, allowing the process to begin execution. The distinction between normal function calls and process creation is:A normal function call does not return until the called function com-pletes. Process creation functions create and resume return to the caller immediately after starting a new process, which allows execu-tion of both the existing process and the new process to proceed con-currently.In Xinu, all processes execute concurrently. That is, execution of a given process continues independent of other processes unless a programmer explicitly controls in-teractions among processes. In the example, the first new process executes code in function sndA, sending the letter A continuously, and the second executes code in func-tion sndB, sending the letter B continuously. Because the processes execute concurrent-ly, the output is a mixture of As and Bs.What happens to the main program? Remember that in an operating system, each computation corresponds to a process. Therefore, we should ask, “What happens to the process executing the main program?” Because it has reached the end of the main pro-gram, the process executing the main program exits after the second call to resume. Its exit does not affect the newly created processes — they continue to send As and Bs. A later section describes process termination in more detail.2.6 Multiple Processes Sharing A Single Piece Of CodeThe example in file ex2.c shows each process executing a separate function. It is possible, however, for multiple processes to execute the same function. Arranging for processes to share code can be essential in an embedded system that has a small memory. To see an example of processes sharing code, consider the program in file ex3.c.†Other arguments to create specify the stack space needed, a scheduling priority, a name for the process,the count of arguments passed to the process, and (when applicable) the argument values passed to the proc-ess; we will see details later.22 Concurrent Execution And Operating System Services Chap. 2//**eexx33..cc--mmaaiinn,,ssnnddcchh**//##iinncclluuddee<<xxiinnuu..hh>>vvooiiddssnnddcchh((cchhaarr));;//**------------------------------------------------------------------------------------------------------------------------------------------------**mmaaiinn--EExxaammpplleeooff22pprroocceesssseesseexxeeccuuttiinnggtthheessaammeeccooddeeccoonnccuurrrreennttllyy**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddmmaaiinn((vvooiidd)){{rreessuummee((ccrreeaattee((ssnnddcchh,,11002244,,2200,,""sseennddAA"",,11,,’’AA’’))));;rreessuummee((ccrreeaattee((ssnnddcchh,,11002244,,2200,,""sseennddBB"",,11,,’’BB’’))));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ssnnddcchh--OOuuttppuuttaacchhaarraacctteerroonnaasseerriiaallddeevviicceeiinnddeeffiinniitteellyy**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddssnnddcchh((cchhaarrcchh//**TThheecchhaarraacctteerrttooeemmiittccoonnttiinnuuoouussllyy**//)){{wwhhiillee((11))ppuuttcc((CCOONNSSOOLLEE,,cchh));;}}As in the previous example, a single process begins executing the main program. The process calls create twice to start two new processes that each execute code from function sndch. The final two arguments in the call to create specify that create will pass one argument to the newly created process and a value for the argument. Thus, the first process receives the character A as an argument, and the second process receives character B.Although they execute the same code, the two processes proceed concurrently without any effect on one another. In particular, each process has its own copy of argu-ments and local variables. Thus, one process emits As, while the other process emits Bs. The key point is:A program consists of code executed by a single process of control.In contrast, concurrent processes are not uniquely associated with a piece of code; multiple processes can execute the same code simul-taneously.Sec. 2.6        Multiple Processes Sharing A Single Piece Of Code 23The examples provide a hint of the difficulty involved in designing an operating system. Not only must each piece be designed to operate correctly by itself, thedesigner must also guarantee that multiple processes can execute a given piece of code concurrently without interfering with one another.Although processes can share code and global variables, each process must have a private copy of local variables. To understand why, consider the chaos that wouldresult if all processes shared every variable. If two processes tried to use a shared vari-able as the index of a for loop, for example, one process might change the value while another process was in the midst of executing the loop. To avoid such interference, the operating system creates an independent set of local variables for each process.Function create also allocates an independent set of arguments for each process, asthe example in file ex3.c demonstrates. In the call to create, the last two argumentsspecify a count of values that follow (1 in the example), and the value that the operating system passes to the newly created process. In the code, the first new process has char-acter A as an argument, and the process begins execution with formal parameter ch set to A. The second new process begins with ch set to B. Thus, the output contains a mixture of both letters. The example points out a significant difference between the sequential and concurrent programming models.Storage for local variables, function arguments, and a function call stack is associated with the process executing a function, not with the code for the function.The important point is: an operating system must allocate additional storage for each process, even if the process shares the same code that another process or processes are using. As a consequence, the amount of memory available limits the number of processes that can be created.2.7 Process Exit And Process TerminationThe example in file ex3.c consists of a concurrent program with three processes: the initial process and the two processes that were started with the system call create. Recall that when it reaches the end of the code in the main program, the initial process ceases execution. We use the term process exit to describe the situation. Each process begins execution at the start of a function. A process can exit by reaching the end of the function or by executing a return statement in the function in which it starts. Once a process exits, it disappears from the system; there is simply one less computation in progress.Process exit should not be confused with normal function call and return or with recursive function calls. Like a sequential program, each process has its own stack of function calls. Whenever it executes a call, an activation record for the called function is pushed onto the stack. Whenever it returns, a function’s activation record is popped24 Concurrent Execution And Operating System Services Chap. 2off the stack. Process exit occurs only when the process pops the last activation record (the one that corresponds to the top-level function in which the process started) off its stack.The system routine kill provides a mechanism to terminate a process without wait-ing for the process to exit. In a sense, kill is the inverse of create— kill takes a processID as an argument, and removes the specified process immediately. A process can be killed at any time and at any level of function nesting. When terminated, the process ceases execution and local variables that have been allocated to the process disappear; in fact, the entire stack of functions for the process is removed.A process can exit by killing itself as easily as it can kill another process. To doso, the process uses system call getpid to obtain its own process ID, and then uses killto request termination:kill( getpid() );When used to terminate the current process, the call to kill never returns because thecalling process exits.2.8 Shared Memory, Race Conditions, And SynchronizationIn Xinu, each process has its own copy of local variables, function arguments, and function calls, but all processes share the set of global (external) variables. Sharing data is sometimes convenient, but it can be dangerous, especially for programmers who are unaccustomed to writing concurrent programs. For example, consider two concurrent processes that each increment a shared integer, n. In terms of the underlying hardware, incrementing an integer requires three steps:Load the value from variable n in memory into a registerIncrement the value in the registerStore the value from the register back into the memory location for nBecause the operating system can choose to switch from one process to another atany time, a potential race condition exists in which two processes attempt to incrementn at the same time. Process 1 might start first and load the value of n into a register.But just at that moment, the operating system switches to process 2, which loads n, in-crements the register, and stores the result. Unfortunately, when the operating system switches back to process 1, execution resumes with the original value of n in a register. Process 1 increments the original value of n and stores the result to memory, overwrit-ing the value that process 2 placed in memory.To see how sharing works, consider the code in file ex4.c. The file contains codefor two processes that communicate through a shared integer, n†. One process repeat-edly increments the value of the shared integer, while the other process repeatedly prints the value.†The code uses the type name int32 to emphasize that variable n is a 32-bit integer; a later section ex-plains conventions for type names.Sec. 2.8        Shared Memory, Race Conditions, And Synchronization 25//**eexx44..cc--mmaaiinn,,pprroodduuccee,,ccoonnssuummee**//##iinncclluuddee<<xxiinnuu..hh>>vvooiiddpprroodduuccee((vvooiidd)),,ccoonnssuummee((vvooiidd));;iinntt3322nn==00;;//**GGlloobbaallvvaarriiaabblleessaarreesshhaarreeddbbyyaallllpprroocceesssseess**////**------------------------------------------------------------------------------------------------------------------------------------------------**mmaaiinn--EExxaammpplleeooffuunnssyynncchhrroonniizzeeddpprroodduucceerraannddccoonnssuummeerrpprroocceesssseess**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddmmaaiinn((vvooiidd)){{rreessuummee((ccrreeaattee((ccoonnssuummee,,11002244,,2200,,""ccoonnss"",,00))));;rreessuummee((ccrreeaattee((pprroodduuccee,,11002244,,2200,,""pprroodd"",,00))));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**pprroodduuccee--IInnccrreemmeennttnn22000000ttiimmeessaannddeexxiitt**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddpprroodduuccee((vvooiidd)){{iinntt3322ii;;ffoorr((ii==11;;ii<<==22000000;;ii++++))nn++++;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ccoonnssuummee--PPrriinnttnn22000000ttiimmeessaannddeexxiitt**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddccoonnssuummee((vvooiidd)){{iinntt3322ii;;ffoorr((ii==11;;ii<<==22000000;;ii++++))pprriinnttff((""TThheevvaalluueeooffnniiss%%dd\\nn"",,nn));;}}In the code, global variable n is a shared integer that is initialized to zero. Theprocess executing produce iterates 2000 times, incrementing n; we call the process the26 Concurrent Execution And Operating System Services Chap. 2producer. The process executing consume also iterates 2000 times. It displays thevalue of n in decimal; we call the process executing consume the consumer.Try running file ex4.c— its output may surprise you. Most programmers suspectthat the consumer will print at least a few, perhaps all, of the values between 0 and2000, but it does not. In a typical run, n has the value 0 for the first few lines; afterthat, its value becomes 2000.† Even though the two processes run concurrently, theydo not require the same amount of processor time per iteration. The consumer process must format and write a line of output, an operation that requires hundreds of machine instructions. Although formatting is expensive, it does not dominate the timing; output does. The consumer quickly fills the available output buffers, and must wait for the output device to send characters to the console before it can proceed. While the con-sumer waits, the producer runs. Because it executes only a few machine instructions per iteration, the producer runs through its entire loop and exits in the short time it takes the console device to send a line of characters. When the consumer resumes execution again, it finds that n has the value 2000.Production and consumption of data by independent processes is common. The question arises: how can a programmer synchronize producer and consumer processes so the consumer receives every data value produced? Clearly, the producer must waitfor the consumer to access the data item before generating another. Likewise, the con-sumer must wait for the producer to manufacture the next item. For the two processes to coordinate correctly, a synchronization mechanism must be designed carefully. The crucial constraint is:In a concurrent programming system, no process should use the pro-cessor while waiting for another process.A process that executes instructions while waiting for another is said to engage in busy waiting. To understand our prohibition on busy waiting, think of the implementa-tion. If a process uses the processor while waiting, the processor cannot be executing other processes. At best, the computation will be delayed unnecessarily, and at worst, the waiting process will use all the available processor cycles in a single-core system, and will wind up waiting forever.Many operating systems include coordination functions that applications can use to avoid busy waiting. Xinu provides a semaphore abstraction — the system supplies aset of system calls that allow applications to operate on semaphores and to create sema-phores dynamically. A semaphore consists of an integer value that is initialized when the semaphore is created and a set of zero or more processes that are waiting on the semaphore. The system call wait decrements a semaphore and adds the calling process to the set of waiting processes if the result is negative. The system call signal performs the opposite action by incrementing the semaphore and allowing one of the waiting process to continue, if any are waiting. To synchronize, a producer and consumer need two semaphores: one on which the consumer waits and one on which the producer waits. In Xinu, semaphores are created dynamically with the system call semcreate, †The example assumes a 32-bit architecture in which each operation affects the entire 32-bit integer;when run on an 8-bit architecture, some bytes of nmay be updated before others.Sec. 2.8        Shared Memory, Race Conditions, And Synchronization 27which takes the desired initial count as an argument, and returns an integer identifier by which the semaphore is known.Consider the example in file ex5.c†. The main process creates two semaphores, consumed and produced, and passes them as arguments to the processes it creates. Be-cause the semaphore named produced begins with a count of 1, wait will not block the first time it is called in cons2. So, the consumer is free to print the initial value of n. However, semaphore consumed begins with a count of 0, so the first call to wait in prod2 blocks. In effect, the producer waits for semaphore consumed before increment-ing n to guarantee that the consumer has printed it. When the example executes, the producer and consumer coordinate, and the consumer prints all values of n from 0 through 1999.//**eexx55..cc--mmaaiinn,,pprroodd22,,ccoonnss22**//##iinncclluuddee<<xxiinnuu..hh>>vvooiiddpprroodd22((ssiidd3322,,ssiidd3322)),,ccoonnss22((ssiidd3322,,ssiidd3322));;iinntt3322nn==00;;//**VVaarriiaabblleennhhaassiinniittiiaallvvaalluueezzeerroo**////**------------------------------------------------------------------------------------------------------------------------------------------------**mmaaiinn--PPrroodduucceerraannddccoonnssuummeerrpprroocceesssseessssyynncchhrroonniizzeeddwwiitthhsseemmaapphhoorreess**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddmmaaiinn((vvooiidd)){{ssiidd3322pprroodduucceedd,,ccoonnssuummeedd;;ccoonnssuummeedd==sseemmccrreeaattee((00));;pprroodduucceedd==sseemmccrreeaattee((11));;rreessuummee((ccrreeaattee((ccoonnss22,,11002244,,2200,,""ccoonnss"",,22,,ccoonnssuummeedd,,pprroodduucceedd))));;rreessuummee((ccrreeaattee((pprroodd22,,11002244,,2200,,""pprroodd"",,22,,ccoonnssuummeedd,,pprroodduucceedd))));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**pprroodd22--IInnccrreemmeennttnn22000000ttiimmeess,,wwaaiittiinnggffoorriittttoobbeeccoonnssuummeedd**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddpprroodd22((ssiidd3322ccoonnssuummeedd,,ssiidd3322pprroodduucceedd)){{iinntt3322ii;;†Section 2.10 on page 30 explains the type sid32 used in the code to declare a semaphore ID.28 Concurrent Execution And Operating System Services Chap. 2ffoorr((ii==11;;ii<<==22000000;;ii++++)){{wwaaiitt((ccoonnssuummeedd));;nn++++;;ssiiggnnaall((pprroodduucceedd));;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ccoonnss22--PPrriinnttnn22000000ttiimmeess,,wwaaiittiinnggffoorriittttoobbeepprroodduucceedd**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddccoonnss22((ssiidd3322ccoonnssuummeedd,,ssiidd3322pprroodduucceedd)){{iinntt3322ii;;ffoorr((ii==11;;ii<<==22000000;;ii++++)){{wwaaiitt((pprroodduucceedd));;pprriinnttff((""nniiss%%dd\\nn"",,nn));;ssiiggnnaall((ccoonnssuummeedd));;}}2.9 Semaphores And Mutual ExclusionSemaphores provide another important purpose, mutual exclusion. Two or more processes engage in mutual exclusion when they cooperate so that only one of them ob-tains access to a shared resource at a given time. For example, suppose two executing processes each need to insert items into a shared linked list. If they access the list con-currently, pointers can be set incorrectly. Producer–consumer synchronization does not handle the problem because the two processes do not alternate accesses. Instead, a mechanism is needed that allows either process to access the list at any time, but guarantees mutual exclusion so that one process will wait until the other finishes.To provide mutual exclusion for use of a resource such as a linked list, the processes create a single semaphore that has an initial count of 1. Before accessing the shared resource, a process calls wait on the semaphore, and calls signal after it has com-pleted access. The calls to wait and signal can be placed at the beginning and end of the functions designed to perform the update, or they can be placed around the lines of code that access the shared resource. We use the term critical section to refer to the code that cannot be executed by more than one process at a time.Sec. 2.9        Semaphores And Mutual Exclusion 29For example, file ex6.c shows a function that adds an item to an array that isshared by multiple concurrent processes. The critical section consists of the single line:sshhaarreedd[[nn++++]]==iitteemm;;which adds the item to the array and increments the count of items. Thus, the code for mutual exclusion only needs to surround one line of code. In the example, the critical section has been placed in a function, additem, which means the calls to wait and signal occur at the beginning and end of the function.The code in additem calls wait on semaphore mutex before accessing the array, and calls signal on the semaphore when access is complete. In addition to the function, thefile contains declarations for three global variables: an array, shared, an index for the array, n, and the ID of the semaphore used for mutual exclusion, mutex.//**eexx66..cc--aaddddiitteemm**//##iinncclluuddee<<xxiinnuu..hh>>ssiidd3322mmuutteexx;;//**AAssssuummeeiinniittiiaalliizzeeddwwiitthhsseemmccrreeaattee**//iinntt3322sshhaarreedd[[110000]];;//**AAnnaarrrraayysshhaarreeddbbyymmaannyypprroocceesssseess**//iinntt3322nn==00;;//**CCoouunnttooffiitteemmssiinntthheeaarrrraayy**////**------------------------------------------------------------------------------------------------------------------------------------------------**aaddddiitteemm--OObbttaaiinneexxcclluussiivveeuusseeooffaarrrraayysshhaarreeddaannddaaddddaanniitteemmttooiitt**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddaaddddiitteemm((iinntt3322iitteemm//**IItteemmttooaaddddttoosshhaarreeddaarrrraayy**//)){{wwaaiitt((mmuutteexx));;sshhaarreedd[[nn++++]]==iitteemm;;ssiiggnnaall((mmuutteexx));;}}The code assumes that global variable mutex will be assigned the ID of a sema-phore before any calls to additem occur. That is, during initialization, the following statement was executed:mutex = semcreate(1);The code in file ex6.c provides a final illustration of the difference between theway one programs in sequential and concurrent environments. In a sequential program,a function often acts to isolate changes to a data structure. By localizing the code that30 Concurrent Execution And Operating System Services Chap. 2changes a data structure in one function, a programmer gains a sense of security — only a small amount of code needs to be checked for correctness because nothing else in the program will interfere with the data structure. In a concurrent execution environment, isolating the code into a single function is insufficient. A programmer must guarantee that execution is exclusive because interference can come from another process execut-ing the same function at the same time.2.10 Type Names Used In XinuData declarations in the code above illustrate conventions used throughout the text. For example, semaphores are declared using the type name sid32. This section explains the reasoning for the conventions.Two important questions arise when programming in C. When is it appropriate to define a new type name? How should a type name be chosen? The questions require careful thought because types fill two conceptual roles. Size. A type defines the storage associated with a variable and theset of values that can be assigned to the variable.Use. A type defines the abstract meaning of a variable and helps aprogrammer know how a variable can be used.Size. The sizes of variables are especially important in an embedded system be-cause a programmer must design data structures that fit in the memory available. Fur-thermore, choosing a size that does not match the underlying hardware can result in unexpected processing overhead (e.g., arithmetic operations on large integers can re-quire multiple hardware steps). Unfortunately, C does not specify the exact size of con-crete types, such as int, short, and long. Instead, the size of items depends on the underlying computer architecture. For example, a long integer can occupy 32 bits on one computer and 64 bits on another computer. To guarantee sizes, a programmer can define and use a set of type names, such as int32, that specify data size.Use.  The classic purpose of a type arises from the need to define the purpose of a variable (i.e., to tell how the variable is used). For example, although semaphore IDs are integers, defining a type name such as sid32 makes it clear to anyone reading the code that a variable holds a semaphore ID and should only be used where a semaphore ID is appropriate (e.g., as an argument to a function that operates on a semaphore).Thus, although it consists of an integer, a variable of type sid32 should not be used as a temporary value when computing an arithmetic expression, nor should it be used to store a process ID or a device ID.Include files further complicate type declarations in C. In principle, one would ex-pect each include file to contain the type, constant, and variable declarations related to a single module. Thus, one would expect to find the type for a process identifier declared in the include file that defines items related to processes. In an operating system, how-ever, many cross-references exist among modules. For example, we will see that the in-Sec. 2.10        Type Names Used In Xinu 31clude file for semaphores references the process type, and the include file for processes references the semaphore type.We have chosen an approach in which types accommodate the need to define sizeas well as the need to define use. Instead of using the C form of char, short, int, andlong, the code uses the types that Figure 2.1 lists.Type Meaningbyte unsigned 8-bit valuebool8 8-bit value used as a Booleanint16 signed 16-bit integeruint16 unsigned 16-bit integerint32 signed 32-bit integeruint32 unsigned 32-bit integerFigure 2.1  Basic type names for integers used throughout Xinu.For types that correspond to operating system abstractions, each name combines a short mnemonic that identifies the purpose plus a numeric suffix that identifies the size. Thus, a type that defines a semaphore ID to be a 32-bit integer has been assigned the name sid32, and a type that defines a queue ID to be a 16-bit integer has been assigned the name qid16.To permit cross-references of types among modules, a single include file, kernel.h, contains declarations for all type names, including the types listed in Figure 2.1. Thus, each source file must include kernel.h before referencing any type name. In particular, an include for kernel.hmust precede the include statements for other modules. For con-venience, a single include file, xinu.h, includes all header files used in Xinu in the correct order.2.11 Operating System Debugging With Kputc And KprintfThe examples in this chapter use Xinu functions putc and printf to display outputon the CONSOLE. Although such functions work well once an operating system hasbeen completed and tested, they are not used during construction or debugging because they require many components of the operating system to function correctly. What do operating system designers use?Designers use polled I/O. That is, a designer creates a special I/O function that does not need interrupts to be working. Following Unix tradition, we call the special function kputc (i.e., a version of putc suitable for use inside the operating system ker-nel).  Kputc takes a character, c, as an argument and performs four steps:32 Concurrent Execution And Operating System Services Chap. 2Disable interruptsWait for the CONSOLE serial device to be idleSend character c to the serial deviceRestore interrupts to their previous statusThus, when a programmer invokes kputc, all processing stops until the character has been displayed. Once the character has been displayed, processing resumes. The important idea is that the operating system itself does not need to be working because kputcmanipulates the hardware device directly.Once kputc is available, it is easy to create a function that can display formatted output. Again following Unix tradition, we call the function kprintf. Basically, kprintf operates exactly like printf except that instead of invoking putc to display each charac-ter, kprintf invokes kputc.†Although it is not important to understand the exact details of how polled I/Ooperates, it is essential to use polled I/O when debugging:Whenever they modify or extend the operating system, programmers should use kprintf to display messages rather than printf.2.12 PerspectiveConcurrent processing is one of the most powerful abstractions in computer sci-ence. It makes programming easier, less error prone, and in many cases, yields higher overall performance than code that attempts to switch among tasks manually. The ad-vantages are so significant that once concurrent execution was introduced, it rapidly be-came the primary choice for most programming.2.13 SummaryAn understanding of an operating system begins with the set of services the system provides to applications. Unlike a conventional, sequential programming environment, an operating system provides concurrent execution in which multiple processes proceed at the same time. In our example system, as in most systems, a process can be createdor terminated at runtime. Multiple processes can each execute a separate function, or multiple processes can execute a single function. In a concurrent environment, storage for arguments, local variables, and a function call stack are associated with each process rather than with the code.†Debugging operating system code is difficult because disabling interrupts can change the execution of a system (e.g., by preventing clock interrupts). Thus, a programmer must be extremely careful when usingkprintf.Sec. 2.13        Summary33Processes use synchronization primitives, such as semaphores, to coordinate execu-tion. Two primary forms of coordination are producer–consumer synchronization and mutual exclusion.EXERCISES2.1 What is the API an operating system provides, and how is the API defined?2.2 To what does multitasking refer?2.3 List the two basic categories of multitasking systems, and state the characteristics of each.2.4 What characteristics are generally associated with the terms process, task, and thread?2.5 How is a process ID used?2.6 How does calling function X differ from calling create to start a process executing functionX?2.7  The program in file ex3.c uses three processes. Modify the code to achieve the sameresults using only two processes.2.8  Test the program in file ex4.c repeatedly. Does it always print the same number of zeroes?Does it ever print a value of n other than 0 or 2000?2.9 In Xinu, what is the difference in storage between global variables and local variables?2.10 Why do programmers avoid busy waiting?2.11  Suppose three processes attempt to use function additem in file ex6.c at the same time. Ex-plain the series of steps that occur, and give the value of the semaphore during each step.2.12  Modify the producer–consumer code in file ex5.c to use a buffer of 15 slots, and have theproducer and consumer synchronize in such a way that a producer can generate up to 15 values before blocking and a consumer can extract all values in the buffer before blocking. That is, arrange for the producer to write integers 1, 2, ... in successive locations of the buffer, wrapping around to the beginning after filling the last slot, and have the consumer extract values and print them on the console. How many semaphores are needed?2.13  In file ex5.c, the semaphore produced is created with a count of 1. Rewrite the code soproduced is created with a count of 0 and the producer signals the semaphore once before starting the iteration. Does the change affect the output?2.14 Find the documentation for the serial port (or console device hardware) on a platform towhich you have access. Describe how to construct a polled I/O function, kputc() that usesthe device.Chapter Contents3.1 Introduction, 373.2 Physical And Logical Organizations Of A Platform, 383.3 Instruction Sets, 383.4 General-purpose Registers, 393.5 I/O Buses And The Fetch-Store Paradigm, 413.6 Direct Memory Access, 423.7 The Bus Address Space, 423.8 Bus Startup And Configuration, 433.9 Calling Conventions And The Runtime Stack, 443.10 Interrupts And Interrupt Processing, 473.11 Vectored Interrupts, 483.12 Exception Vectors And Exception Processing, 483.13 Clock Hardware, 493.14 Serial Communication, 493.15 Polled vs. Interrupt-driven I/O, 493.16 Storage Layout, 503.17 Memory Protection, 513.18 Hardware Details And A System On Chip Architecture, 513.19 Perspective, 523.20 Hardware References, 523An Overview Of The Hardware And Runtime Environment
One machine can do the work of fifty ordinary men.No machine can do the work of one extraordinaryman.— Elbert Hubbard3.1 IntroductionBecause it deals with the details of devices, processors, and memory, an operating system cannot be designed without knowledge of the capabilities and features of the underlying hardware. Throughout the text, we will use two example hardware plat-forms: a Galileo and a BeagleBone Black. The platforms each consist of a small, low-cost circuit board that includes a processor, memory, and a few I/O devices. The pro-cessors on the boards employ well-known instruction sets: the Galileo uses Intel’s in-struction set that is known as x86, and the BeagleBone Black uses an ARM instruction set. We will see that most operating system functions are identical on the two architec-tures. However, the use of two platforms will allow a reader to compare how low-level OS system functions, such as a context switch, differ between a CISC (Complex In-struction Set Computer) architecture and a RISC (Reduced Instruction Set Computer) architecture.The remainder of the chapter provides an overview of the two hardware platforms, describing pertinent features of the processors, memories, and I/O devices. The chapter3738 An Overview Of The Hardware And Runtime Environment Chap. 3explains enough of the architecture, memory addressing, runtime stack, interrupt mecha-nisms, and device addressing to allow a reader to understand the discussions that fol-low. Although the chapter focuses on specific boards, the basic concepts apply broadly to most computer systems.3.2 Physical And Logical Organizations Of A PlatformPhysically, the platforms we are using each consist of a single, self-contained cir-cuit board that uses a separate power cube. Most of the major components are con-tained in a single VLSI chip that is known as a System on Chip (SoC).† Because theboards are intended for use in experimental systems, they come completely assembled.Like most computers, our platforms each include a serial console— a character-oriented device that the operating system uses to issue information messages, report er-rors, and interact with a user.‡ The Galileo has a (nonstandard) connector for its serial console. Thus, one must obtain a special cable. Although it has serial hardware on the board, the BeagleBone Black does not have a connector. Instead, a user must purchase a converter that connects to GPIO pins on the board. To interact over a serial console, a user can connect the serial line through a cable to a conventional computer (e.g., to the USB connection to a laptop or desktop), and then run an application that sends char-acters to the console line and displays the results. Information about a serial connection and instructions describing how to attach a serial connector can be found on the web site:http:// www.xinu.cs.purdue.eduFor now, it is sufficient to know that once an operating system is loaded on one of the platforms, a user can run an application that sends keystrokes to the platform and displays output from the platform.Logically, the platforms follow the same overall architecture as most general-purpose computer systems. The components on the SoC include a processor, memory interface, and I/O device interfaces. Among other devices, each board includes an Eth-ernet network interface that allows the board to connect to a local network or the Inter-net. Figure 3.1 illustrates the conceptual organization.3.3 Instruction SetsRecall from the above discussion that the Galileo board implements an Intel in-struction set and the BeagleBone Black implements an ARM instruction set. Except fora few special cases, an operating system does not need to focus on the instruction set because most OS functions are written in C, and a compiler generates the appropriate code. Thus, instruction set details will only be important for a handful of functions that are written in assembly language.†See page 51 for an explanation of the difference between the boards and the underlying SoC. ‡Technically, a serial console uses the RS-232 standard.Sec. 3.3        Instruction Sets39system backplaneserial console interfacemain memory (RAM)onboard flash memoryprocessorEthernet network interfaceUSB hostinterfaceUSB client interfaceexternal I/O connectionsFigure 3.1 The logical organization of major components in the exampleplatforms.In practice, the platforms each include additional hardware features that are not shown in the figure. For example, the BeagleBone Black provides graphics and floating point accelerators and an HDMI interface; the Galileo provides a mini-PCI Express in-terface and an interface for a micro-SD card. However, we are only concerned with the hardware features most pertinent to an operating system. For now, we will focus on the overall design of each component and how the components fit together. Later chapters discuss additional details, explain how an operating system interacts with the hardware, and provide examples.3.4 General-purpose RegistersMost computer architectures provide a small set of general-purpose registers. We think of registers as temporary, high-speed storage that can be used in arithmetic, logi-cal, and data movement instructions. A register can hold an integer, a pointer, or other data value. Because registers are much faster than memory, a compiler keeps frequently used variables in registers, and only writes values back to memory when the register is needed for another variable.Hardware registers play a key role in operating system design because they formpart of the state of a computation. That is, the hardware provides a single set ofgeneral-purpose registers, and each computation uses the registers. To support con-current processes, an operating system must provide each process with the illusion that it has complete control over the registers. From a process’s point of view, once the process can store a value in register X, the value will remain until the process changes it. We know that an operating system switches the processor among multiple processes. To preserve the illusion when switching from one process to another, the operating sys-tem must save a copy of the values that the first process had placed in all the registers, and load the registers with the values the second process was using when it last had40 An Overview Of The Hardware And Runtime Environment Chap. 3control of the processor. In Chapter 5, we will see exactly how an operating systemsaves and restores copies of registers. For now, it is sufficient to understand that the hardware contains one copy of registers that all processes share.3.4.1  Galileo (Intel)The Galileo board follows the traditional 32-bit Intel architecture. In addition to an internal program counter and floating point registers, the processor has eight general-purpose registers. For our purposes, each register is 32 bits wide.† Figure 3.2 lists the registers on an Intel processor by giving the name used to reference a register and the meaning assigned.Name UseEAX AccumulatorEBX BaseECX CountEDX DataESI Source IndexEDI Destination IndexEBP Base PointerESP Stack PointerFigure 3.2The general-purpose registers in the Galileo board (Intel) and themeaning of each.In practice, the Intel instruction set allows a programmer to access subparts of re-gisters. For example, the hardware allows a programmer to treat some of the 32-bit re-gisters as pairs of 16-bit registers. That is, instructions can access the low-order 16 bits or the high-order 16 bits of a register without changing the other part. In fact, some in-structions allow a programmer to reference individual bytes of a register. However, such details will not be important except in special cases, such as system startup.Registers can be used as operands in instructions, or can point to an operand in memory. Despite being classified as general-purpose, individual registers are assigned specific uses by the hardware and/or compiler. For example, the ESP register serves as a pointer to a runtime stack. The stack can be used as temporary storage during compu-tation (e.g., by pushing intermediate results and popping them later), and is essential during function invocation because the activation record for a called function is pushed on the stack during a function call, and popped off the stack when the function returns.†Xinu runs in protected mode; an x86 processor has other modes, such as a 64-bit mode, with moregeneral-purpose registers.Sec. 3.4        General-purpose Registers 413.4.2  BeagleBone Black (ARM)The BeagleBone Black follows the traditional 32-bit ARM architecture, which has15 general-purpose registers plus a program counter. The program counter contains the address of the instruction that will be executed next, and is only changed during a jump. Figure 3.3 lists the 32-bit registers on an ARM processor, aliases, and their typical use.†Name Alias UseR0 – R3 a1 – a4 Argument registersR4 – R11 v1 – v8 Variables and temporariesR9 sb Static base registerR12 ip Intra procedure call scratch registerR13 sp Stack pointerR14 lr Link register used for return addressR15 pc Program counterFigure 3.3 The general-purpose registers and the program counter in theBeagleBone Black (ARM) and the meaning of each.3.5 I/O Buses And The Fetch-Store ParadigmWe use the term bus to refer to a mechanism that provides the primary pathbetween the processor and other components, namely the memory, I/O devices, andother interface controllers. Bus hardware uses a fetch-store paradigm in which the only operations are fetch, to move data from a component across the bus to the processor, and store, to move data from the processor across the bus to a component. For exam-ple, when it needs to access memory, the processor places a memory address on the bus and issues a fetch request to obtain the corresponding value. The memory hardware responds to the request by looking up the address in memory, placing the data value on the bus, and signalling the processor that the value is ready. Similarly, to store a value in memory, the processor places an address and value on the bus and issues a store re-quest; the memory hardware extracts the value and stores a copy in the specified memory location. Bus hardware handles many details of the fetch-store paradigm, in-cluding signals that the processor and other components use to communicate and control access to the bus. We will see that an operating system can use a bus without knowing many details of the underlying hardware.The example systems use memory-mapped I/O, which means that each I/O deviceis assigned a set of addresses in the bus address space. The processor uses the same†The ARM architecture has eight additional floating point registers that are not listed here because theyare not directly relevant to process management.42 An Overview Of The Hardware And Runtime Environment Chap. 3fetch-store paradigm to communicate with I/O devices as with memory. We will seethat communication with a memory-mapped I/O device resembles data access. First,the processor computes the address associated with a device. Second, to access the de-vice, the processor either stores a value to the address or fetches a value from the ad-dress.3.6 Direct Memory AccessHigher-speed I/O devices (e.g., an Ethernet device) offer Direct Memory Access (DMA), which means the device contains hardware that can use the bus to communicate directly with memory. The key idea is that DMA allows I/O to proceed quickly be-cause it does not interrupt the processor frequently nor does it require the processor to perform each data transfer. Instead, a processor can give the I/O device a list of opera-tions, and the device proceeds from one to the next. Thus, DMA allows a processor to continue running processes while a device operates.As an example, consider how an Ethernet device uses DMA. To receive a packet,the operating system allocates a buffer in memory and starts the Ethernet device. Whena packet arrives, the device hardware accepts the packet and makes multiple bustransfers to move a copy into the buffer in memory. Finally, once the entire packet has been transferred, the device interrupts the processor. Sending a packet is equally effi-cient: the operating system places the packet in a buffer in memory and starts the de-vice. The device uses the bus multiple times to fetch the packet from the buffer in memory. The device then transmits the packet on the network and interrupts the pro-cessor after the entire packet has been transferred.We will see that the DMA hardware on the example platforms allows a processorto request multiple operations. In essence, the processor creates a list of packets to besent and a list of buffers to be used for incoming packets. The network interfacehardware uses the lists to send and receive packets without requiring the processor to restart the device after each operation. As long as the processor consumes incoming packets faster than they arrive and adds fresh buffers to the list, the network hardware device will continue to read packets. Similarly, as long as the processor continues to generate packets and add them to the list, the network hardware device will continue to transmit the packets. Later chapters explain additional DMA details, and the example code illustrates how a device driver in the operating system allocates I/O buffers and controls DMA operations.3.7 The Bus Address SpaceEach of the platforms uses a 32-bit bus address space, with addresses ranging from 0x00000000 through 0xFFFFFFFF. Some of the addresses in the bus address space correspond to memory, some to FlashROM, and others to I/O devices. The next sec-tions provide more detail.Sec. 3.7        The Bus Address Space 43Memory. On each system, memory is divided into 8-bit bytes, with a byte being the smallest addressable unit. The C language uses the term character in place of byte because each byte can hold one ASCII character. Although a 32-bit bus can address 4 Gbytes total, not all possible addresses are assigned. The Galileo contains an 8 Mbyte Legacy SPI Flash (used to store firmware, such as a bootstrap loader), 512 Kbytes of SRAM, 256 Mbytes of DRAM, and between 256 and 512 Kbytes of storage for Ar-duino sketches. Note that the largest item, the DRAM, occupies only 6.25% of the ad-dress space. The BeagleBone Black contains a 4 Gbyte Flash memory (used to store firmware), and 512 Mbytes of DRAM. In the case of a BeagleBone Black, the DRAM occupies 12.5% of the bus address space, meaning that many addresses are not as-signed.Do unassigned bus addresses cause a problem? The hardware allows addresses to remain unassigned provided the addresses are not referenced. If the processor attemptsto access an unassigned address, however, the hardware raises an exception.† For ex-ample, a bus exception can occur if a Xinu process overflows an array or generates an incorrect pointer and then tries to dereference the pointer. The important point is:Referencing an unassigned bus address, such as an address beyondthe physical memory, will cause the hardware to create an exception.3.8 Bus Startup And ConfigurationHow should memory modules and devices be assigned addresses in the bus addressspace? Two methods are used:Static address assignmentDynamic address assignmentThe example platforms illustrate the two methods: the BeagleBone Black uses stat-ic assignment, and the Galileo uses dynamic assignment.Static address assignment. Often used by small, embedded systems, static means that all details of the hardware configuration are chosen when the hardware is designed. That is, a hardware designer chooses a set of peripheral devices, and assigns each a unique address on the bus. The hardware designer passes the assignments to an operat-ing system designer, who must configure the operating system to match the underlying hardware. Extreme care must be taken — if the operating system does not match the hardware exactly, the system will not operate correctly (i.e., may not even be able to boot). Static configuration has the advantage of increased runtime efficiency, but the disadvantages of less generality and susceptibility to human error.Dynamic address assignment. Dynamic assignment means that when a system boots, an operating system, with the support of the bus hardware and platform firmware, must discover devices and memories attached to the bus. Each component attached to the bus is assigned a unique identifier that specifies the vendor and the specific †Chapter 24 discusses exception handling.44 An Overview Of The Hardware And Runtime Environment Chap. 3hardware type. An operating system probes the bus to determine which components are present. Each component returns its ID. For example, an operating system can deter-mine the type and size of each memory module that has been installed as well as the ex-act bus address assigned to each module. A bus that supports dynamic assignment has the advantage of increased generality because a single operating system image can run on a variety of hardware configurations. However, dynamic assignment makes both bus hardware and operating system code more complex.Chapter 25 discusses operating system configuration in more detail, and shows an example of configuration; chapters on device mechanisms and drivers show how a sys-tem contends with static and dynamic address assignment.3.9 Calling Conventions And The Runtime StackWe will see that operating systems rely heavily on mechanisms for function invo-cation. When they invoke operating systems services, applications use function calls. Thus, function calls define operating system services. Furthermore, when it switches context from one process to another, an operating system must handle the situation where the processes have each made a series of nested function calls. Thus, an operat-ing system designer must understand the details of function invocation. The following paragraphs define key concepts and mechanisms related to function invocation.Calling conventions. The steps taken during a function call and return are known as calling conventions. The term convention arises because the hardware does not dic-tate all details. Instead, the hardware design places some constraints on possible ap-proaches, and leaves final choices to a compiler writer. We will see that because it calls functions to process interrupts and switch from one running process to another, an operating system must understand and follow the same conventions as the compiler.Arguments and argument passing. When a function is called, the caller supplies a set of actual arguments that correspond to formal parameters. A variety of argument passing mechanisms have been used in commercial processors. The example platforms illustrate two common approaches: placing arguments on the stack and passing argu-ments in general-purpose registers.Runtime stack and stack frame contents. A statically scoped language, such as C, uses a runtime stack to store the state associated with a function call. The compiler al-locates enough space on the stack to hold an activation record for the called function. The allocated space is known as a stack frame. Each activation record contains space for the local variables associated with the function, temporary storage needed during computation, a return address, and other miscellaneous items. We assume the stack grows downward from higher memory addresses to lower memory addresses. A com-piler generates code needed to create a stack frame. The compiler computes the size needed for local variables as well as the size needed for auxiliary items, such as the temporary space used to save the contents of registers (so the function can use the regis-ters for computation and then restore their original values before returning to the caller). We will see that when it creates a new process, an operating system needs to construct aSec. 3.9        Calling Conventions And The Runtime Stack 45stack frame for the process’s initial function. Thus, the operating system needs to know exactly how a stack frame is laid out, including the location of arguments and the return address. Examples will clarify the concept. In the examples below, we assume a gcc compiler; the calling conventions used by other compilers may differ in minor ways.3.9.1  Galileo (Intel)On an Intel processor, before invoking a function, a caller pushes registers EAX, ECX, and EDX on the stack, pushes the arguments in reverse order, and then executes a call instruction, which pushes the return address on the stack. Code in the called func-tion pushes EBP, EBX, EDI, and ESI, and pushes space for the local variables. When the call returns, values are popped from the stack in reverse order. Figure 3.4 illustrates values on the top of the stack immediately after a function call (remember that a stack grows downward).
EBP
ESPSaved EAX Saved ECX Saved EDXArgument N ...Argument 2 Argument 1Return addressSaved EBP Saved EBXSaved EDI Saved ESILocal variable K ...Local variable 2 Local variable 1pushed by calling function
pushed by called functionset by the called functionafter EBP is saved on the stackpushed by the call instruction; removed by the ret instructionstack pointer just before the call instruction is executed
Figure 3.4  The stack on an Intel processor when a function is called.46 An Overview Of The Hardware And Runtime Environment Chap. 33.9.2  BeagleBone Black (ARM)On an ARM processor, the first four arguments to a function are passed in registers a0 – a3(i.e., registers r0 – r4). Arguments beyond the first four are passed on the stack. To call a function, the caller executes a BL (branch and link) instruction. When the BL executes, the hardware places the return address in register r14. The calledfunction must save registers it will use; typically, the called function pushes copies of r14 – r4 onto the stack, and then pushes the CPSR (status) register. Figure 3.5 illus-trates values on the top of the stack immediately after a function call (remember that a stack grows downward). In the figure, the top of the stack only contains space for local variables beyond the first seven. By convention, the first seven local variables are stored in registers 4 through 8, 10, and 11.In fact, the set of saved registers varies across versions of the ARM architecture. Furthermore, if a program uses floating point, the floating point registers must also be saved and restored.Argument K ...Argument 6 Argument 5Saved r14 Saved r13 Saved r12 Saved r11 Saved r10Saved r9 Saved r8 Saved r7 Saved r6 Saved r5 Saved r4Saved CPSRLocal variables beyond the first seven, if anysppushed by calling function if needed
pushed by called functionstack pointer just before the BL instruction is executed saved value of return address
Figure 3.5  The stack on an ARM processor when a function is called.Sec. 3.9        Calling Conventions And The Runtime Stack 473.10 Interrupts And Interrupt ProcessingModern processors provide mechanisms that allow external I/O devices to inter-rupt the processor when they need service. In most cases, processor hardware has a closely related exception mechanism that is used to inform the software when an erroror fault occurs (e.g., an application attempts division by zero or references a page in vir-tual memory that is not present in memory). From an operating system’s point of view, interrupts are fundamental because they allow the processor to perform computation at the same time I/O proceeds.†Any of the I/O devices connected to a bus can interrupt the processor when the de-vice needs service. To do so, the device places a signal on one of the bus control lines. During normal execution of the fetch-execute cycle, hardware in the processor monitors the control line and initiates interrupt processing when the control line has been sig-naled. In the case of a RISC processor, the main processor does not usually contain the hardware to handle interrupts. Instead, a co-processor interacts with the bus on behalf of the main processor.Whatever interrupt mechanisms a processor uses, the hardware or the operatingsystem must guarantee that:The entire state of the processor, including the programcounter and status registers, is saved when an interrupt occursThe processor runs the appropriate interrupt handler processor,which must have been placed in memory before the interrupt occursWhen an interrupt finishes, the operating system and hardwareprovide mechanisms that restore the entire state of the proces-sor and continue processing at the point of interruptionInterrupts introduce a fundamental idea that pervades an entire operating system.An interrupt can occur at any time, and an operating system can switch from one proc-ess to another during an interrupt. The consequence is that other processes can run atany time.To prevent problems caused by concurrent processes trying to manipulate shared data, an operating system must take steps to avoid switching context. The simplest wayto prevent other processes from executing consists of disabling interrupts. That is, the hardware includes an interrupt mask mechanism that an operating system can use to control interrupts. On many hardware systems, if the interrupt mask is assigned a value of zero, the processor ignores all interrupts; if the mask is assigned a non zero value, the hardware allows interrupts to occur. On some processors, the hardware has indivi-dual interrupt bits for each device, and on others, the mask provides a set of eight or sixteen levels, and each device is assigned a level. We will see that many operating system functions disable interrupts while they manipulate global data structures and I/O queues.†Later chapters explain how an operating system manages interrupt and exception processing, and showhow the high-level I/O operations a user performs relate to low-level device hardware mechanisms.48 An Overview Of The Hardware And Runtime Environment Chap. 33.11 Vectored InterruptsWhen a device interrupts, how does the hardware know the location of the code that handles the interrupt? The hardware on most processors uses a mechanism known as vectored interrupts. The basic idea is straightforward: each device is assigned a small integer number: 0, 1, 2, and so on. The integers are known as interrupt level numbers or interrupt request numbers. The operating system creates an array of pointers in memory known as an interrupt vector, where the ith entry in the interrupt vector array points to the code that handles interrupts for the device with vector number i. When it interrupts, a device sends its vector number over the bus to the processor. Depending on the processor details, either the hardware or the operating system uses the vector number as an index into the interrupt vector, obtains a pointer, and uses the pointer as the address of the code to run.Because it must be configured before any interrupts occur, an operating system ini-tializes the interrupt vector at the same time devices are assigned addresses on the bus. The assignment of interrupt level numbers usually employs the same paradigm as ad-dress assignment. A manual assignment means a human assigns a unique interrupt level number to each device and then configures the interrupt vector addresses accordingly. An automatic approach requires bus and device hardware that can assign interrupt levels at runtime. To use the automatic approach, an operating system polls devices at startup, assigns a unique interrupt level number to each device, and initializes the interrupt vec-tor accordingly. Automatic assignment is safer (i.e., less prone to human error), but re-quires more complex hardware in both the devices and the bus. We will see examples of static and automatic interrupt vector assignment.3.12 Exception Vectors And Exception ProcessingMany processors follow the same vectored approach for exceptions as they use for interrupts. That is, each exception is assigned a unique number: 0, 1, 2, and so on.When an exception occurs, the hardware places the exception number in a register. The operating system extracts the exception number, and uses the number as the index into an exception vector. A minor difference occurs between the way processor hardware handles interrupts and exceptions. We think of an interrupt as occurring between two instructions. Thus, one instruction has completed and the next instruction has not be-gun. However, an exception occurs during an instruction. Thus, when the processor re-turns from the exception, the program counter has not advanced, and the instruction can be restarted. Restarting is especially important for page fault exceptions — when a page fault occurs, the operating system must read the missing page from memory, set the page table, and then execute the instruction that caused the fault a second time.Sec. 3.13        Clock Hardware 493.13 Clock HardwareIn addition to I/O devices that transfer data, most computers include hardware thatcan be used to manage timed events. There are two basic forms:Real-time clockInterval timerReal-time clock. A real-time clock circuit consists of hardware that generates apulse regularly (e.g., 1000 times per second). To turn a real-time clock circuit into areal-time clock device, the hardware is configured to interrupt the processor on each pulse. A real-time clock device does not keep any counters, does not store the time of day, and may not have an adjustable cycle time (e.g., the pulse rate may be determined by a crystal that must be replaced to change the rate).Interval timer. Conceptually, an interval timer consists of a real-time clock circuitthat pulses at regular intervals connected to a counter that computes a tally of pulsesplus a comparator circuit that compares the tally to a threshold value. An operating sys-tem can specify a threshold value and can reset the counter to zero. When the counter reaches the threshold value, the interval timer interrupts the processor. The advantage of an interval timer lies in its efficiency. Instead of interrupting continuously, an inter-val timer can be configured to wait until an event should occur. Of course, interval tim-er hardware is more complex than a real-time clock.3.14 Serial CommunicationSerial communication devices are among the simplest I/O devices available, and have been used on computers for decades. Each of the example platforms contains an RS-232 serial communication device that is used as a system console. The serialhardware handles both input and output (i.e., the transmission and reception of charac-ters). When an interrupt occurs, the processor examines a device hardware register to determine whether the output side has completed transmission or the input side has re-ceived a character. Chapter 15 examines serial devices, and shows how interrupts are processed.3.15 Polled vs. Interrupt-driven I/OMost I/O performed by an operating system uses the interrupt mechanism. The operating system interacts with the device to start an operation (either input or output), and then proceeds with computation. When the I/O operation completes, the device in-terrupts the processor, and the operating system can choose to start another operation.Although they optimize concurrency and permit multiple devices to proceed in parallel with computation, interrupts cannot always be used to perform I/O. For exam-50 An Overview Of The Hardware And Runtime Environment Chap. 3ple, consider displaying a startup message for a user before the operating system has in-itialized interrupts and I/O. Also consider a programmer writing operating systems code. It may be desirable to allow I/O even though it may be necessary to leave inter-rupts disabled during debugging. In either case, interrupts cannot be used.The alternative to interrupt-driven I/O is known as polled I/O. When using polled I/O, the processor starts an I/O operation, but does not enable interrupts. Instead, the processor enters a loop that repeatedly checks a device status register to determine whether the operation has completed. We have already seen an example of how an operating system designer can use polled I/O when we examined functions kputc and kprintf in Chapter 2.3.16 Storage LayoutWhen it compiles a program, a C compiler partitions the resulting image into fourmemory segments:Text segmentData segmentBss segmentStack segmentThe text segment, which includes code for the main program and all functions, oc-cupies the lowest part of the address space. The data segment, which contains all ini-tialized data, occupies the next region of the address space. The uninitialized data seg-ment, called the bss segment, follows the data segment. Finally, the stack segment oc-cupies the highest part of the address space and grows downward. Figure 3.6 illustrates the conceptual organization.textdatabssstackfree spaceetext edata endlowest address SPFigure 3.6  Illustration of memory segments created by a C compiler.The symbols etext, edata, and end in the figure refer to global variables that the loader inserts into the object program. The names are initialized to the first address beyond the text, data, and bss segments, respectively. Thus, a running program can determine how much memory remains between the end of the bss segment and the current top of stack by subtracting the address of end from the stack pointer, SP.Chapter 9 explains memory allocation for multiple processes in Xinu. Although all processes share the text, data, and bss segments, a separate stack segment must be allo-Sec. 3.16        Storage Layout51cated for each process. If three processes are executing, the stacks are allocated con-tiguously from the highest memory address downward as Figure 3.7 illustrates.As the figure indicates, each process has its own stack pointer. At a given time, the stack pointer for process i must point to an address within the stack that has been al-located for process i. Later chapters explain the concept in detail.textdatabssheapprocess 1 stackprocess 2 stackprocess 3 stackfreeetext edata endlowest addressSP1SP2SP3Figure 3.7  Illustration of memory with stack segments for three processes.3.17 Memory ProtectionThe memory hardware available on the example platforms includes mechanisms that an operating system can use to protect one process from another and to protect the operating system from application processes. For example, applications can be config-ured to run in user mode, which means they cannot read or write kernel memory. When an application makes a system call, control transfers to the kernel and the privilege level is increased to kernel mode until the call returns. The key to understanding protection is to remember that control can only transfer to the operating system at the specific en-try points that the operating system designer provides. Thus, a designer can ensure that an application only receives carefully controlled services.Like many other embedded systems, our example code avoids the complexity and runtime overhead of memory protection. Instead the code runs completely in aprivileged mode, without memory protection. The lack of protection means a program-mer must be careful because any process can access any memory location, including the memory allocated to operating system structures or memory allocated to another process’s stack. If a process overflows the allocated stack area, the process’s runtime stack will overwrite data in another process’s stack.3.18 Hardware Details And A System On Chip ArchitectureBoth hardware platforms use a System on Chip (SoC) approach. That is, a singleVLSI chip contains the processor, memories, and a set of I/O interfaces. For example,the Intel Galileo contains a Quark SoC. We have chosen to emphasize the boards rath-er than the underlying SoC because a given board can be less general than the SoC.For example, the Quark design allows multiple cores and has multiple copies of someI/O interfaces. However, the version of the SoC on the Galileo board provides onlyone core and one Ethernet connection. Similarly, the ARM architecture is more general than the version available on the BeagleBone Black.52 An Overview Of The Hardware And Runtime Environment Chap. 3Despite our focus on complete boards rather than the SoC, much of the material in the text generalizes to other boards that use the same SoC. For example, the context switch code used with the Galileo also runs on other x86 platforms, and the context switch code used on the BeagleBone Black also runs on other ARM platforms.3.19 PerspectiveThe hardware specifications for a processor or I/O device contain so many detailsthat studying them can seem overwhelming. Fortunately, many of the differencesamong processors are superficial — fundamental concepts apply across most hardware platforms. Therefore, when learning about hardware, it is important to focus on the overall architecture and design principles rather than on tiny details.In terms of operating systems, many hardware details affect the overall design. In particular, the hardware interrupt mechanism and interrupt processing dominate many parts of the design. Intellectually, however, the most significant item to appreciate is the stunning disparity between the primitive facilities the hardware offers and the high-level abstractions an operating system supplies.3.20 Hardware ReferencesGeneral information about the BeagleBone Black, including a photo and links to aGetting Started page and other materials can be found on the web site:http://beagleboard.org/blackDetails about the processor and SoC can be found on:http://www.ti.com/product/am3358and a data sheet for the SoC is available at:http://www.ti.com/lit/pdf/spruh73A general introduction to the Galileo and other platforms that use the Quark SoCcan be found at:http://www.intel.com/galileoInformation about the Galileo development board, including a photo and links to sites with more detail, can be found at:http://www.intel.com/content/www/us/en/intelligent-systems/galileo/galileo-overview.htmlExercises53EXERCISES3.1 Some systems use a programmable interrupt address mechanism that allows the system tochoose the address to which the processor jumps when an interrupt occurs. What is the ad-vantage of a programmable interrupt address?3.2  DMA introduces the possibility of unexpected errors. What happens if a DMA operationthat transfers N bytes of data begins at a memory location less than N bytes from thehighest memory address?3.3  Read about hardware that uses multi-level interrupts. Should an interrupt at one level beable to interrupt the system while it is processing an interrupt from another level? Explain.3.4  What are the advantages of the memory layout shown in Figure 3.7? Are there disadvan-tages? What other layouts might be useful?3.5 Embedded hardware often includes multiple interval timer devices, each with its own inter-rupt vector. Why might multiple timers be helpful? Can a system with only a single timer accomplish the same tasks as a system with multiple timers? Explain.3.6 If you are familiar with an assembly language, read about the calling conventions that areused to permit recursive function calls. Build a function that makes recursive calls, and demonstrate that your function works correctly.3.7 On an Intel platform, the program counter (i.e., the instruction pointer register) cannot beread directly. Devise x86 assembly language code that determines the value indirectly by using instructions that manipulate the instruction pointer.Chapter Contents4.1 Introduction, 574.2 A Unified Structure For Linked Lists Of Processes, 584.3 A Compact List Data Structure, 594.4 Implementation Of The Queue Data Structure, 614.5 Inline Queue Manipulation Functions, 624.6 Basic Functions To Extract A Process From A List, 634.7 FIFO Queue Manipulation, 654.8 Manipulation Of Priority Queues, 684.9 List Initialization, 704.10 Perspective, 714.11 Summary, 724List And Queue Manipulation
As some day it may happen that a victim must befound, I’ve got a little list ....— W. S. Gilbert4.1 IntroductionLinked list processing is fundamental in operating systems, and pervades each component. Linked structures enable a system to manage sets of objects efficiently without searching or copying. As we will see, managing lists of processes is especially important.This chapter introduces a set of functions that form the backbone of a linked list manipulation system. The functions represent a unified approach — a single data struc-ture and a single set of nodes used by all levels of the operating system to maintain lists of processes. We will see that the data structure includes functions to create a new list, insert an item at the tail of a list, insert an item in an ordered list, remove the item at the head of a list, or remove an item from the middle of a list.†The linked list functions are easy to understand because they assume that only one process executes a list function at a given time. Thus, a reader can think of the code as being part of a sequential program — there is no need to worry about interference from other processes executing concurrently. In addition, the example code introduces several programming conventions used throughout the text.†Although linked list manipulation is usually covered in texts on data structures, the topic is includedhere because the data structure is unusual and because it forms a key part of the system.5758 List And Queue Manipulation Chap. 44.2 A Unified Structure For Linked Lists Of ProcessesA process manager handles objects called processes. Although at any time a proc-ess appears on only one list, a process manager moves a process from one list to anoth-er frequently. In fact, a process manager does not store all details about a process on alist. Instead, the process manager merely stores a process ID, a small, nonnegative in-teger used to reference the process. Because it is convenient to think of placing a proc-ess on a list, we will use the terms process and process ID interchangeably throughout the chapter.An early version of Xinu had many lists of processes, each with its own data struc-ture. Some consisted of first-in-first-out (FIFO) queues, and others were ordered by akey. Some lists were singly linked; others needed to be doubly linked to permit itemsto be inserted and deleted at arbitrary positions efficiently. After the requirements had been formulated, it became clear that centralizing the linked-list processing into a single data structure would reduce code size and eliminate many special cases. That is, in-stead of six separate sets of linked list manipulation functions, a single set of functions was created to handle all situations.To accommodate all cases, a representation was selected with the following proper-ties:All lists are doubly linked, which means a node points to its prede-cessor and successor.Each node stores a key as well as a process ID, even though a keyis not used in a FIFO list.Each list has head and tail nodes; the head and tail nodes have thesame memory layout as other nodes.Non-FIFO lists are ordered in descending order; the key in a headnode is greater than the maximum valid key value, and the keyvalue in the tail node is less than the minimum valid key.Figure 4.1 illustrates the conceptual organization of a linked list data structure byshowing an example list with two items.
––4 252 14HEADTAILprevious process key next
greater than maximum key less than minimum keyFigure 4.1 The conceptual organization of a doubly-linked list containingprocesses 4 and 2 with keys 25 and 14, respectively.Sec. 4.2        A Unified Structure For Linked Lists Of Processes 59As expected, the successor of the tail and the predecessor of the head are null.When a list is empty, the successor of the head is the tail and the predecessor of the tailis the head, as Figure 4.2 illustrates.––HEAD TAILgreater than maximum key less than minimum keyFigure 4.2  The conceptual form of an empty linked list.4.3 A Compact List Data StructureOne of the key design goals in an embedded system involves reducing the memory used. Instead of using a conventional implementation of a linked list, Xinu optimizesthe memory required in two ways:Relative pointersImplicit data structureTo understand the optimizations, it is important to know that most operating sys-tems place a fixed upper bound on the number of processes in the system. In Xinu, constant NPROC specifies the number of processes, and process identifiers range from 0 through NPROC – 1. In most embedded systems, NPROC is small (less than 100); we will see that a small limit makes each optimization work well.Relative pointers. To understand the motivation for relative pointers, consider the space a conventional pointer occupies. On a 32-bit architecture, each pointer occupies four bytes. If the system contains fewer than 100 nodes, however, the size required can be reduced by placing nodes in contiguous memory locations and using a value between 0 and 99 as a reference. That is, the nodes can be allocated in an array, and the array index can be used instead of a pointer.Implicit data structure. The second optimization focuses on omitting the processID field from all nodes. Such an omission is feasible because:A process appears on at most one list at any time.To omit the process ID, use an array implementation and use the ith element of the arrayfor process ID i. Thus, to put process 3 on a particular linked list, insert node 3 ontothe list. Thus, the relative address of a node is the same as the ID of the process being stored.60 List And Queue Manipulation Chap. 4Figure 4.3 illustrates how the linked list in Figure 4.1 can be represented in an ar-ray that incorporates relative pointers and implicit identifiers. Each entry in an arrayhas three fields: a key, the index of the previous node, and the index of the next node.The head of the list has index 60, and the tail has index 61.
.........KEY PREV NEXT0 1 2 3 4 5
60 6125 60 214 4 61
MAXKEY MINKEY––42NPROC – 1each row corresponds to a single process
pairs of rows form the head and tail of a listHead of example listTail of example listconceptual boundary
Figure 4.3  The list from Figure 4.1 stored in the queue table array.Because a NEXT or PREV field contains a relative pointer (i.e., an array index), thesize of the field depends on the size of the array. For example, if the array containsfewer than 256 items, a single byte can be used to store an index.Xinu uses the term queue table to refer to the array. The key to understanding the structure is to observe that array elements with an index less than NPROC differ from elements with a higher index. Positions 0 through NPROC–1 each correspond to one process in the system; positions NPROC and higher are used to hold head and tail pointers for lists. Such a data structure is only feasible because the maximum number of processes and the maximum number of lists are each known at compile time and a process can only appear on one list at a given time.Sec. 4.4        Implementation Of The Queue Data Structure 614.4 Implementation Of The Queue Data StructureTo place process i on a list, the node with index i is linked into the list. A closerlook at the code will make the operations clear. In Xinu, the queue table pictured aboveis named queuetab, and declared to be an array of qentry structures. File queue.h con-tains the declarations of both queuetab and qentry://**qquueeuuee..hh--ffiirrssttiidd,,ffiirrssttkkeeyy,,iisseemmppttyy,,llaassttkkeeyy,,nnoonneemmppttyy**////**QQuueeuueessttrruuccttuurreeddeeccllaarraattiioonnss,,ccoonnssttaannttss,,aannddiinnlliinneeffuunnccttiioonnss**////**DDeeffaauulltt##ooffqquueeuueeeennttrriieess::11ppeerrpprroocceesssspplluuss22ffoorrrreeaaddyylliissttpplluuss**////**22ffoorrsslleeeepplliissttpplluuss22ppeerrsseemmaapphhoorree**//##iiffnnddeeffNNQQEENNTT##ddeeffiinneeNNQQEENNTT((NNPPRROOCC++44++NNSSEEMM++NNSSEEMM))##eennddiiff##ddeeffiinneeEEMMPPTTYY((--11))//**NNuullllvvaalluueeffoorrqqnneexxttoorrqqpprreevviinnddeexx**//##ddeeffiinneeMMAAXXKKEEYY00xx77FFFFFFFFFFFFFF//**MMaaxxkkeeyytthhaattccaannbbeessttoorreeddiinnqquueeuuee**//##ddeeffiinneeMMIINNKKEEYY00xx8800000000000000//**MMiinnkkeeyytthhaattccaannbbeessttoorreeddiinnqquueeuuee**//ssttrruuccttqqeennttrryy{{//**OOnneeppeerrpprroocceesssspplluussttwwooppeerrlliisstt**//iinntt3322qqkkeeyy;;//**KKeeyyoonnwwhhiicchhtthheeqquueeuueeiissoorrddeerreedd**//qqiidd1166qqnneexxtt;;//**IInnddeexxooffnneexxttpprroocceessssoorrttaaiill**//qqiidd1166qqpprreevv;;//**IInnddeexxooffpprreevviioouusspprroocceessssoorrhheeaadd**//}};;eexxtteerrnnssttrruuccttqqeennttrryyqquueeuueettaabb[[]];;//**IInnlliinneeqquueeuueemmaanniippuullaattiioonnffuunnccttiioonnss**//##ddeeffiinneeqquueeuueehheeaadd((qq))((qq))##ddeeffiinneeqquueeuueettaaiill((qq))((((qq))++11))##ddeeffiinneeffiirrssttiidd((qq))((qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqnneexxtt))##ddeeffiinneellaassttiidd((qq))((qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqpprreevv))##ddeeffiinneeiisseemmppttyy((qq))((ffiirrssttiidd((qq))>>==NNPPRROOCC))##ddeeffiinneennoonneemmppttyy((qq))((ffiirrssttiidd((qq))<<NNPPRROOCC))##ddeeffiinneeffiirrssttkkeeyy((qq))((qquueeuueettaabb[[ffiirrssttiidd((qq))]]..qqkkeeyy))##ddeeffiinneellaassttkkeeyy((qq))((qquueeuueettaabb[[llaassttiidd((qq))]]..qqkkeeyy))//**IInnlliinneettoocchheecckkqquueeuueeiiddaassssuummeessiinntteerrrruuppttssaarreeddiissaabblleedd**//##ddeeffiinneeiissbbaaddqqiidd((xx))((((((iinntt3322))((xx))<<00))||||((iinntt3322))((xx))>>==NNQQEENNTT--11))62 List And Queue Manipulation Chap. 4The queuetab array contains NQENT entries. As Figure 4.3 indicates, an important implicit boundary occurs between element NPROC–1 and element NPROC. Each ele-ment below the boundary corresponds to a process ID, and elements queuetab[NPROC] through queuetab[NQENT] correspond to the heads or tails of lists.File queue.h introduces several features of C and conventions used throughout the book. Because the name ends in .h, the file will be included in other programs (“h”stands for header). Such files often contain the declarations for global data structures, symbolic constants, and inline functions (macros) that operate on the data structures. File queue.h defines queuetab to be an external variable (i.e., global), which means that every process will be able to access the array. The file also defines symbolic constants used with the data structure, such as constant EMPTY that is used to define an empty list.Symbolic constant NQENT, which defines the total number of entries in the queuetab array, provides an example of conditional definition. The statement #ifndef NQENT means “compile the code down to the corresponding #endif, if and only if NQENT has not been defined previously.” Thus, the code in queue.h assigns a value to NQENT only if it has not been defined previously. The value assigned,NPROC+4+NSEM+NSEMallocates enough entries in queuetab for NPROC processes plus head and tail pointers for NSEM semaphore lists, a ready list, and a sleep list. Conditional compilation is used to permit the size of the queuetab array to be changed without modifying the .h file.The contents of entries in the queuetab array are defined by structure qentry. Thefile contains only a declaration of the elements in the queuetab array; Chapter 22 ex-plains how data structures are initialized at system startup. Field qnext gives the rela-tive address of the next node on a list, field qprev points to the previous node, and field qkey contains an integer key for the node. When a field, such as a forward or backward pointer, does not contain a valid index value, the field is assigned the value EMPTY.4.5 Inline Queue Manipulation FunctionsThe functions isempty and nonempty are predicates (i.e., Boolean functions) that test whether a list is empty or not empty, given the index of its head as an argument. Isempty determines whether a list is empty by checking to see if the first node on theSec. 4.5        Inline Queue Manipulation Functions 63list is a process or the list tail; function nonempty makes the opposite test. To under-stand the test, remember that the first NPROC entries in the queuetab array eachcorrespond to a process. All the other nodes are either a list head or tail. Therefore,testing whether an item on a list is a process only requires comparing the item’s index to NPROC — the node is a process if its index is less than NPROC. The important point to note is that the test for an empty or nonempty queue are extremely efficient.The other inline functions are also easy to understand. Function firstkey returns thekey of the first process on a list, and function lastkey returns the key of the last processon a list. Function firstid returns the ID of the first process on a list. That is, the func-tion returns the queuetab index of the first process on a list.Usually, the queue functions are applied to nonempty lists. However, the imple-mentation has a useful property: a list always has a head and tail, even if the list is emp-ty. Thus, the functions described above can be applied to an empty list without causing a runtime error. For example, when firstkey is applied to an empty list, the function re-turns the key of the node following the head, which will be the tail. Thus, the function will return the key from the tail, MINKEY. Similarly, extracting the ID of the first node in an empty list will never cause an array reference to be out-of-bounds because the tail node has a valid ID. Finally, extracting the first key of an empty list will never cause an error because the qkey field is always initialized, even in the head and tail nodes.4.6 Basic Functions To Extract A Process From A ListConsider extracting a process from a list.† Recall that extracting an item from the head of a FIFO queue results in removing the item that has been in the queue the long-est. For a priority queue, extracting from the head produces an item with highest priori-ty. Similarly, extracting an item from the tail of the queue produces an item with lowest priority. As a result, we can construct three basic functions that are sufficient to handle extraction: getfirst— extract the process at the head of a list getlast— extract the process at the tail of a listgetitem— extract a process at an arbitrary pointThe code for the three basic functions can be found in file getitem.c.
†A later section considers inserting a process into a list.64 List And Queue Manipulation Chap. 4//**ggeettiitteemm..cc--ggeettffiirrsstt,,ggeettllaasstt,,ggeettiitteemm**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettffiirrsstt--RReemmoovveeaapprroocceessssffrroommtthheeffrroonnttooffaaqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//ppiidd3322ggeettffiirrsstt((qqiidd1166qq//**IIDDooffqquueeuueeffrroommwwhhiicchhttoo**//))//**RReemmoovveeaapprroocceessss((aassssuummeedd**////**vvaalliiddwwiitthhnnoocchheecckk))**//{{ppiidd3322hheeaadd;;iiff((iisseemmppttyy((qq)))){{rreettuurrnnEEMMPPTTYY;;}} hheeaadd==qquueeuueehheeaadd((qq));;rreettuurrnnggeettiitteemm((qquueeuueettaabb[[hheeaadd]]..qqnneexxtt));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettllaasstt--RReemmoovveeaapprroocceessssffrroommeennddooffqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//ppiidd3322ggeettllaasstt((qqiidd1166qq//**IIDDooffqquueeuueeffrroommwwhhiicchhttoo**//))//**RReemmoovveeaapprroocceessss((aassssuummeedd**////**vvaalliiddwwiitthhnnoocchheecckk))**//{{ppiidd3322ttaaiill;;iiff((iisseemmppttyy((qq)))){{rreettuurrnnEEMMPPTTYY;;}} ttaaiill==qquueeuueettaaiill((qq));;rreettuurrnnggeettiitteemm((qquueeuueettaabb[[ttaaiill]]..qqpprreevv));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettiitteemm--RReemmoovveeaapprroocceessssffrroommaannaarrbbiittrraarryyppooiinnttiinnaaqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------Sec. 4.6        Basic Functions To Extract A Process From A List 65**//ppiidd3322ggeettiitteemm((ppiidd3322ppiidd//**IIDDooffpprroocceessssttoorreemmoovvee**//)){{ppiidd3322pprreevv,,nneexxtt;;nneexxtt==qquueeuueettaabb[[ppiidd]]..qqnneexxtt;;//**FFoolllloowwiinnggnnooddeeiinnlliisstt**//pprreevv==qquueeuueettaabb[[ppiidd]]..qqpprreevv;;//**PPrreevviioouussnnooddeeiinnlliisstt**//qquueeuueettaabb[[pprreevv]]..qqnneexxtt==nneexxtt;;qquueeuueettaabb[[nneexxtt]]..qqpprreevv==pprreevv;;rreettuurrnnppiidd;;}}Getfirst takes a queue ID as an argument, verifies that the argument identifies a nonempty list, finds the process at the head of the list, and calls getitem to extract the process from the list. Similarly, getlast takes a queue ID as an argument, checks the ar-gument, finds the process at the tail of the list, and calls getitem to extract the process. Each of the two functions returns the ID of the process that has been extracted.Getitem takes a process ID as an argument, and extracts the process from the list in which the process is currently linked. Extraction consists of making the previous node point to the successor and the successor point to the previous node. Once a process has been unlinked from a list, getitem returns the process ID as the value of the function.4.7 FIFO Queue ManipulationWe will see that many of the lists a process manager maintains consist of a First-In-First-Out (FIFO) queue. That is, a new item is inserted at the tail of the list, and anitem is always removed from the head of the list. For example, a scheduler can use aFIFO queue to implement round-robin scheduling by placing the current process on the tail of a list and switching to the process on the head of the list.Functions enqueue and dequeue, found in file queue.c, implement FIFO operations on a list. Because each list has both a head and tail, both insertion and extraction are efficient. For example, enqueue inserts a process just prior to the tail of a list, and de-queue extracts an item just after the head of the list. Dequeue takes a single argument that gives the ID of the list to use. Enqueue takes two arguments: the ID of the process to be inserted and the ID of a list on which to insert it.66 List And Queue Manipulation Chap. 4//**qquueeuuee..cc--eennqquueeuuee,,ddeeqquueeuuee**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttqqeennttrryyqquueeuueettaabb[[NNQQEENNTT]];;//**TTaabblleeooffpprroocceessssqquueeuueess**////**------------------------------------------------------------------------------------------------------------------------------------------------**eennqquueeuuee--IInnsseerrttaapprroocceessssaatttthheettaaiillooffaaqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//ppiidd3322eennqquueeuuee((ppiidd3322ppiidd,,//**IIDDooffpprroocceessssttooiinnsseerrtt**//qqiidd1166qq//**IIDDooffqquueeuueettoouussee**//)){{qqiidd1166ttaaiill,,pprreevv;;//**TTaaiill&&pprreevviioouussnnooddeeiinnddeexxeess**//iiff((iissbbaaddqqiidd((qq))||||iissbbaaddppiidd((ppiidd)))){{rreettuurrnnSSYYSSEERRRR;;}} ttaaiill==qquueeuueettaaiill((qq));;pprreevv==qquueeuueettaabb[[ttaaiill]]..qqpprreevv;;qquueeuueettaabb[[ppiidd]]..qqnneexxtt==ttaaiill;;//**IInnsseerrttjjuussttbbeeffoorreettaaiillnnooddee**//qquueeuueettaabb[[ppiidd]]..qqpprreevv==pprreevv;;qquueeuueettaabb[[pprreevv]]..qqnneexxtt==ppiidd;;qquueeuueettaabb[[ttaaiill]]..qqpprreevv==ppiidd;;rreettuurrnnppiidd;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ddeeqquueeuuee--RReemmoovveeaannddrreettuurrnntthheeffiirrssttpprroocceessssoonnaalliisstt**------------------------------------------------------------------------------------------------------------------------------------------------**//ppiidd3322ddeeqquueeuuee((qqiidd1166qq//**IIDDqquueeuueettoouussee**//)){{ppiidd3322ppiidd;;//**IIDDooffpprroocceessssrreemmoovveedd**//iiff((iissbbaaddqqiidd((qq)))){{rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((iisseemmppttyy((qq)))){{rreettuurrnnEEMMPPTTYY;;}}Sec. 4.7        FIFO Queue Manipulation 67ppiidd==ggeettffiirrsstt((qq));;qquueeuueettaabb[[ppiidd]]..qqpprreevv==EEMMPPTTYY;;qquueeuueettaabb[[ppiidd]]..qqnneexxtt==EEMMPPTTYY;;rreettuurrnnppiidd;;}}Function enqueue calls isbadpid to check whether its argument is a valid processID. The next chapter shows that isbadpid consists of an inline function that checkswhether the ID is in the correct range and that a process with that ID exists.File queue.c includes xinu.h, which includes the complete set of Xinu include files://**xxiinnuu..hh--iinncclluuddeeaallllssyysstteemmhheeaaddeerrffiilleess**//##iinncclluuddee<<kkeerrnneell..hh>>##iinncclluuddee<<ccoonnff..hh>>##iinncclluuddee<<pprroocceessss..hh>>##iinncclluuddee<<qquueeuuee..hh>>##iinncclluuddee<<rreesscchheedd..hh>>##iinncclluuddee<<mmaarrkk..hh>>##iinncclluuddee<<sseemmaapphhoorree..hh>>##iinncclluuddee<<mmeemmoorryy..hh>>##iinncclluuddee<<bbuuffppooooll..hh>>##iinncclluuddee<<cclloocckk..hh>>##iinncclluuddee<<ppoorrttss..hh>>##iinncclluuddee<<uuaarrtt..hh>>##iinncclluuddee<<ttttyy..hh>>##iinncclluuddee<<ddeevviiccee..hh>>##iinncclluuddee<<iinntteerrrruupptt..hh>>##iinncclluuddee<<ffiillee..hh>>##iinncclluuddee<<rrffiilleessyyss..hh>>##iinncclluuddee<<rrddiisskkssyyss..hh>>##iinncclluuddee<<llffiilleessyyss..hh>>##iinncclluuddee<<eetthheerr..hh>>##iinncclluuddee<<nneett..hh>>##iinncclluuddee<<iipp..hh>>##iinncclluuddee<<aarrpp..hh>>##iinncclluuddee<<uuddpp..hh>>##iinncclluuddee<<ddhhccpp..hh>>##iinncclluuddee<<iiccmmpp..hh>>##iinncclluuddee<<ttffttpp..hh>>##iinncclluuddee<<nnaammee..hh>>##iinncclluuddee<<sshheellll..hh>>68 List And Queue Manipulation Chap. 4##iinncclluuddee<<ddaattee..hh>>##iinncclluuddee<<pprroottoottyyppeess..hh>>##iinncclluuddee<<ddeellaayy..hh>>##iinncclluuddee<<ppccii..hh>>##iinncclluuddee<<qquuaarrkk__eetthh..hh>>##iinncclluuddee<<qquuaarrkk__ppddaatt..hh>>##iinncclluuddee<<qquuaarrkk__iirrqq..hh>>##iinncclluuddee<<mmuullttiibboooott..hh>>##iinncclluuddee<<ssttddiioo..hh>>##iinncclluuddee<<ssttrriinngg..hh>>Combining the set of header files into a single include file helps programmers be-cause it ensures that all pertinent definitions are available and guarantees that the set of include files are processed in a valid sequence. Later chapters consider the contents of each include file.4.8 Manipulation Of Priority QueuesA process manager often needs to select from a set of processes the process thathas highest priority. Consequently, the linked list routines must be able to maintainlists of processes that each have an associated priority. In our example system, a priori-ty is an integer value assigned to the process. In general, the task of examining a proc-ess with highest priority is performed frequently compared with the tasks of insertingand deleting processes. Thus, a data structure used to manage lists of processes shouldbe designed to make finding the highest priority process efficient compared to insertionor deletion.A variety of data structures has been devised to store a set of items that can be selected in priority order. Any such data structure is known generically as a priorityqueue. Our example system uses a linear list to store a priority queue where the priority of a process serves as a key in the list. Because the list is ordered in descending order by key, the highest priority process can always be found at the head of the list. Thus, finding the highest priority process takes constant time. Insertion is more expensive be-cause the list must be searched to determine the location at which a new item should be inserted.In a small embedded system where one only expects two or three processes to beon a given priority queue at any time, a linear list suffices. For a large system wheremany items appear in a given priority queue or where the number of insertions is high compared to the number of times items are extracted, a linear list can be inefficient. An exercise considers the point further.Deletion from an ordered list is trivial: the first node is removed from the list. When an item is inserted, list order must be maintained.  Insert, which is shown below, inserts a process on a list ordered by priority. The function takes three arguments: the ID of a process to be inserted, the ID of a queue on which to insert the process, and anSec. 4.8        Manipulation Of Priority Queues 69integer priority for the process. Insert uses the qkey field in queuetab to store theprocess’s priority. To find the correct location in the list, insert searches for an existing element with a key less than the key of the element being inserted. During the search, integer curr moves along the list. The loop must eventually terminate because the key of the tail element contains a value less than the smallest valid key. Once the correct location has been found, insert changes the necessary pointers to link the new node into the list.//**iinnsseerrtt..cc--iinnsseerrtt**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**iinnsseerrtt--IInnsseerrttaapprroocceessssiinnttooaaqquueeuueeiinnddeesscceennddiinnggkkeeyyoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussiinnsseerrtt((ppiidd3322ppiidd,,//**IIDDooffpprroocceessssttooiinnsseerrtt**//qqiidd1166qq,,//**IIDDooffqquueeuueettoouussee**//iinntt3322kkeeyy//**KKeeyyffoorrtthheeiinnsseerrtteeddpprroocceessss**//)){{iinntt1166ccuurrrr;;//**RRuunnsstthhrroouugghhiitteemmssiinnaaqquueeuuee**//iinntt1166pprreevv;;//**HHoollddsspprreevviioouussnnooddeeiinnddeexx**//iiff((iissbbaaddqqiidd((qq))||||iissbbaaddppiidd((ppiidd)))){{rreettuurrnnSSYYSSEERRRR;;}} ccuurrrr==ffiirrssttiidd((qq));;wwhhiillee((qquueeuueettaabb[[ccuurrrr]]..qqkkeeyy>>==kkeeyy)){{ccuurrrr==qquueeuueettaabb[[ccuurrrr]]..qqnneexxtt;;}} //**IInnsseerrttpprroocceessssbbeettwweeeennccuurrrrnnooddeeaannddpprreevviioouussnnooddee**//pprreevv==qquueeuueettaabb[[ccuurrrr]]..qqpprreevv;;//**GGeettiinnddeexxooffpprreevviioouussnnooddee**//qquueeuueettaabb[[ppiidd]]..qqnneexxtt==ccuurrrr;;qquueeuueettaabb[[ppiidd]]..qqpprreevv==pprreevv;;qquueeuueettaabb[[ppiidd]]..qqkkeeyy==kkeeyy;;qquueeuueettaabb[[pprreevv]]..qqnneexxtt==ppiidd;;qquueeuueettaabb[[ccuurrrr]]..qqpprreevv==ppiidd;;rreettuurrnnOOKK;;}}70 List And Queue Manipulation Chap. 44.9 List InitializationThe functions described above all assume that although it may be empty, a given queue has been initialized. We now consider the code that creates an empty list. It is appropriate that the code to create an empty list occurs at the end of the chapter because it brings up an important point about the design process:Initialization is the final step in design.It may seem strange to defer initialization because a designer cannot postpone thinking about initialization altogether. However, the general paradigm can be stated as follows: first, design the data structures needed when the system is running, and then figure out how to initialize the data structures. Partitioning the “steady state” aspect of the system from the “transient state” helps focus the designer’s attention on the most important aspect, and avoids the temptation of sacrificing good design for easy initiali-zation.Initialization of entries in the queuetab structure is performed on demand as entriesare needed. A running process calls function newqueue to create a new list. The sys-tem maintains a global pointer to the next unallocated element of queuetab, whichmakes it easy to allocate the list.In theory, the head and tail of a list could be allocated from any of the unused en-tries in queuetab. In practice, however, choosing arbitrary locations would require acaller to store two items: the indices of the head and tail. To optimize storage, we make the rule that:The head and tail nodes for a list, X, are allocated from successive locations in the queuetab array, and list X is identified by the index of the head.In the code, newqueue allocates a pair of adjacent positions in the queuetab arrayto use as head and tail nodes, and initializes the list to empty by pointing the successorof the head to the tail and the predecessor of the tail to the head.  Newqueue assigns the value EMPTY to unused pointers (i.e., the successor of the tail and the predecessor of the head). When it initializes a list, newqueue also sets the key fields in the head and the tail to the maximum and minimum integer values, respectively, with the assumption that neither value will be used as a key. Only one allocation function is needed because a list can be used to implement a FIFO queue or a priority queue.Once it finishes with initialization, newqueue returns the index of the list head to its caller. The caller only needs to store one value because the ID of the tail can be computed by adding 1 to the ID of the head.Sec. 4.9        List Initialization 71//**nneewwqquueeuuee..cc--nneewwqquueeuuee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**nneewwqquueeuuee--AAllllooccaatteeaannddiinniittiiaalliizzeeaaqquueeuueeiinntthheegglloobbaallqquueeuueettaabbllee**------------------------------------------------------------------------------------------------------------------------------------------------**//qqiidd1166nneewwqquueeuuee((vvooiidd)){{ssttaattiiccqqiidd1166nneexxttqqiidd==NNPPRROOCC;;//**NNeexxttlliissttiinnqquueeuueettaabbttoouussee**//qqiidd1166qq;;//**IIDDooffaallllooccaatteeddqquueeuuee**//qq==nneexxttqqiidd;;iiff((qq>>NNQQEENNTT)){{//**CChheecckkffoorrttaabblleeoovveerrffllooww**//rreettuurrnnSSYYSSEERRRR;;}} nneexxttqqiidd++==22;;//**IInnccrreemmeennttiinnddeexxffoorrnneexxttccaallll**////**IInniittiiaalliizzeehheeaaddaannddttaaiillnnooddeessttooffoorrmmaanneemmppttyyqquueeuuee**//qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqnneexxtt==qquueeuueettaaiill((qq));;qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqpprreevv==EEMMPPTTYY;;qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqkkeeyy==MMAAXXKKEEYY;;qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqnneexxtt==EEMMPPTTYY;;qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqpprreevv==qquueeuueehheeaadd((qq));;qquueeuueettaabb[[qquueeuueettaaiill((qq))]]..qqkkeeyy==MMIINNKKEEYY;;rreettuurrnnqq;;}}4.10 PerspectiveUsing a single data structure for process lists makes it possible to create general-purpose linked list manipulation functions, which reduce the size of the code by avoid-ing duplication. Using an implicit data structure with relative pointers reduces the memory used. For small embedded systems, compacting code and data is necessary. What about systems that have plenty of memory? Interestingly, a general principle ap-plies: unless care is taken, successive generations of software expand to fill whatever memory is available. Thus, thinking carefully about a design is always important: there are never sufficient resources to justify wasteful inefficiency.72 List And Queue Manipulation Chap. 44.11 SummaryThe chapter describes a set of linked-list functions used to store processes. In our example system, linked lists of processes are kept in a single, uniform data structure, the queuetab array. Functions that manipulate lists of processes can produce FIFO queues or priority queues. All lists have the same form: they are doubly linked, each has both a head and tail, and each node has an integer key field. Keys are used when the list is a priority queue; keys are ignored if the list is a FIFO queue.The implementation uses a single array for all list elements — an entry in the array either corresponds to a process or to a list head or tail. To reduce the size required, the Xinu implementation uses relative pointers and an implicit data structure. In addition, the head and tail of a list are allocated sequentially, allowing a single relative pointer to identify both the head and tail.EXERCISES4.1 In what sense is the queue structure described here an implicit data structure?4.2 If priority values range from –8 to +8, how many bits are required to store each key inqueuetab?4.3 Create a separate set of functions that allows one to create a singly-linked list, and insertitems in either FIFO or priority order. By how much does the second set of routines in-crease memory usage? Does having a separate set of routines decrease processor usage? Explain.4.4  Does insert work correctly for all possible key values? If not, for which key(s) does it fail?4.5   Implement functions to manipulate lists using pointers instead of indices into an array ofstructures. What is the difference in memory space and processor time?4.6 Compare the complexity of functions like isempty implemented with pointers and with ar-ray indexing.4.7 Larger systems sometimes use a data structure known as a heap to contain a priority queue.What is a heap? Will its use be more or less expensive than an ordered, doubly linked list when the list size is between 1 and 3?4.8 Functions getfirst, getlast, and getitem do not check whether their argument is a valid queueID. Modify the code to insert the appropriate checks.4.9 The code generated to convert a subscript into a memory address may use multiplication.Try padding the size of a qentry to a power of two bytes, and examine the resulting code tosee if the compiler uses a shift instead of multiplication.4.10 In the previous exercise, measure a series of insertions and deletions to determine thedifference in speed between the padded and unpadded versions of the data structure.4.11  If a structure contains data items that are not multiples of four bytes on an architecture withstrict word alignment (e.g., some RISC architectures), the code a compiler generates to ac-cess a structure member may include masking and shifting. Try altering the fields of qen-try so that members are aligned on machine word boundaries, and examine the impact on the size of the queue table and the resulting code for accessing members.Chapter Contents5.1 Introduction, 755.2 The Process Table, 765.3 Process States, 795.4 Ready And Current States, 805.5 A Scheduling Policy, 805.6 Implementation Of Scheduling, 815.7 Deferred Rescheduling, 855.8 Implementation Of Context Switching, 855.9 State Saved In Memory, 865.10 Context Switch Operation, 875.11 An Address At Which To Restart A Process, 915.12 Concurrent Execution And A Null Process, 925.13 Making A Process Ready And The Scheduling Invariant, 935.14 Other Process Scheduling Algorithms, 945.15 Perspective, 955.16 Summary, 955Scheduling And Context Switching
What is called a sincere work is one that is endowed with enough strength to give reality to an illusion.— Max Jacob5.1 IntroductionAn operating system achieves the illusion of concurrent execution by rapidly switching a processor among several computations. Because the speed of the computa-tion is extremely fast compared to that of a human, the effect is impressive — multiple activities appear to proceed simultaneously.Context switching, which lies at the heart of the juggling act, consists of stopping the current process, saving enough information so it may be restarted later, and starting another process. What makes such a change difficult is that the processor cannot be stopped during a context switch — the processor must continue to execute the code that switches to a new process.This chapter describes the basic context switching mechanism, showing how an operating system saves the state information from one process, chooses another process to run from among those that are ready, and relinquishes control to the new process.The chapter describes the data structure that holds information about processes that are not currently executing, and explains how the context switch uses the data structure. For the present, we will ignore the questions of when and why processes choose to switch context. Later chapters answer the questions, showing how higher levels of the operating system use the context switch described here.7576 Scheduling And Context Switching Chap. 55.2 The Process TableAn operating system keeps all information about processes in a data structure known as a process table. A process table contains one entry for each process that currently exists. We will see that a new entry must be allocated each time a process is created and an entry is removed when a process terminates. Because exactly one proc-ess is executing at any time, exactly one of the entries in a process table corresponds to an active process — the saved state information in the process table is out of date for the executing process. Each of the other process table entries contains information about a process that has been stopped temporarily. To switch context, the operating system saves information about the currently running process in its process table entry, and restores information from the process table entry corresponding to the process it is about to execute.Exactly what information must be saved in the process table? The system must save any values that will be destroyed when the new process runs. Consider the stack. Because each process has its own separate stack memory, a copy of the entire stack need not be saved. However, when it executes, a process will change the hardware stack pointer register. Therefore, the contents of the stack pointer register must be saved when a process temporarily stops executing, and must be restored when the proc-ess resumes execution. Similarly, copies of other general-purpose registers must be saved and restored. In addition to values from the hardware, an operating system keeps meta-information in the process table. We will see how operating system functions use the meta-information for resource accounting, error prevention, and other administrative tasks. For example, the process table on a multi-user system stores the user ID of the user who owns the process. Similarly, if the operating system places policy limits on the memory that a process can allocate, the limit might be placed in the process table. The details of items in the process table will become clear in later chapters as we exam-ine operating system functions that operate on processes.Like most operating systems, our example system places a fixed upper bound on the maximum number of active processes. In the code, constant NPROC specifies the bound; the process table, proctab, consists of an array with NPROC entries. Each entry in proctab consists of a procent structure that defines the information kept for a process. Figure 5.1 lists key items found in a process table entry.Throughout the operating system, each process is identified by an integer processID. The following rule gives the relationship between process IDs and the processtable:A process is referenced by its process ID, which is the index of the proctab entry that contains the process’s saved state information.Sec. 5.2        The Process Table 77Field Purposeprstate The current status of the process (e.g., whetherthe process is currently executing or waiting)prprio The scheduling priority of the processprstkptr The saved value of the process’s stack pointerwhen the process is not executing prstkbase The address of the highest memory location inthe memory region used as the process’s stackprstklen A limit on the maximum size that the process’sstack can growprname A name assigned to the process that humansuse to identify the process’s purposeFigure 5.1  Key items found in the Xinu process table.As an example of using a process ID, consider how the code finds informationabout a process. The state information for a process with ID 3 can be found in proc-tab[3], and the state information for a process with ID 5 can be found in proctab[5].Using the array index as an ID makes locating information efficient. Of course, usingan array index has a disadvantage: once a process terminates, the process ID will be reused the next time the array entry is used. We will see that the implementation tries to maximize the time between reuse of an ID. An alternative, used in some operating systems, allocates process IDs from a much larger set. Doing so has the advantage of not reusing IDs as frequently, but the disadvantage of requiring a mapping between an ID and a process table slot. One of the exercises suggests an alternative that combines the advantages of both approaches.Each entry in proctab is defined to be a struct of type procent. The declaration of struct procent can be found in file process.h along with other declarations related to processes. Some fields in the process table contain information that the operating sys-tem needs to manage the process (e.g., the information needed to free the process’s stack memory when the process completes). Other fields are used only for debugging. For example, field prname contains a character string that identifies the process; the field is not used except when a human tries to debug a problem or understand the current set of processes and to which computation each corresponds.78 Scheduling And Context Switching Chap. 5//**pprroocceessss..hh--iissbbaaddppiidd**////**MMaaxxiimmuummnnuummbbeerrooffpprroocceesssseessiinntthheessyysstteemm**//##iiffnnddeeffNNPPRROOCC##ddeeffiinneeNNPPRROOCC88##eennddiiff//**PPrroocceessssssttaatteeccoonnssttaannttss**//##ddeeffiinneePPRR__FFRREEEE00//**PPrroocceessssttaabblleeeennttrryyiissuunnuusseedd**//##ddeeffiinneePPRR__CCUURRRR11//**PPrroocceessssiissccuurrrreennttllyyrruunnnniinngg**//##ddeeffiinneePPRR__RREEAADDYY22//**PPrroocceessssiissoonnrreeaaddyyqquueeuuee**//##ddeeffiinneePPRR__RREECCVV33//**PPrroocceesssswwaaiittiinnggffoorrmmeessssaaggee**//##ddeeffiinneePPRR__SSLLEEEEPP44//**PPrroocceessssiisssslleeeeppiinngg**//##ddeeffiinneePPRR__SSUUSSPP55//**PPrroocceessssiissssuussppeennddeedd**//##ddeeffiinneePPRR__WWAAIITT66//**PPrroocceessssiissoonnsseemmaapphhoorreeqquueeuuee**//##ddeeffiinneePPRR__RREECCTTIIMM77//**PPrroocceessssiissrreecceeiivviinnggwwiitthhttiimmeeoouutt**////**MMiisscceellllaanneeoouusspprroocceessssddeeffiinniittiioonnss**//##ddeeffiinneePPNNMMLLEENN1166//**LLeennggtthhooffpprroocceessss""nnaammee""**//##ddeeffiinneeNNUULLLLPPRROOCC00//**IIDDoofftthheennuullllpprroocceessss**////**PPrroocceessssiinniittiiaalliizzaattiioonnccoonnssttaannttss**//##ddeeffiinneeIINNIITTSSTTKK6655553366//**IInniittiiaallpprroocceessssssttaacckkssiizzee**//##ddeeffiinneeIINNIITTPPRRIIOO2200//**IInniittiiaallpprroocceesssspprriioorriittyy**//##ddeeffiinneeIINNIITTRREETTuusseerrrreett//**AAddddrreessssttoowwhhiicchhpprroocceessssrreettuurrnnss**////**IInnlliinneeccooddeettoocchheecckkpprroocceessssIIDD((aassssuummeessiinntteerrrruuppttssaarreeddiissaabblleedd))**//##ddeeffiinneeiissbbaaddppiidd((xx))((((((ppiidd3322))((xx))<<00))||||\\((((ppiidd3322))((xx))>>==NNPPRROOCC))||||\\((pprrooccttaabb[[((xx))]]..pprrssttaattee====PPRR__FFRREEEE))))//**NNuummbbeerrooffddeevviicceeddeessccrriippttoorrssaapprroocceessssccaannhhaavveeooppeenn**//##ddeeffiinneeNNDDEESSCC55//**mmuussttbbeeooddddttoommaakkeepprroocceenntt44NNbbyytteess**////**DDeeffiinniittiioonnoofftthheepprroocceessssttaabbllee((mmuullttiipplleeooff3322bbiittss))**//ssttrruuccttpprroocceenntt{{//**EEnnttrryyiinntthheepprroocceessssttaabbllee**//uuiinntt1166pprrssttaattee;;//**PPrroocceessssssttaattee::PPRR__CCUURRRR,,eettcc..**//pprrii1166pprrpprriioo;;//**PPrroocceesssspprriioorriittyy**//Sec. 5.2        The Process Table 79cchhaarr**pprrssttkkppttrr;;//**SSaavveeddssttaacckkppooiinntteerr**//cchhaarr**pprrssttkkbbaassee;;//**BBaasseeooffrruunnttiimmeessttaacckk**//uuiinntt3322pprrssttkklleenn;;//**SSttaacckklleennggtthhiinnbbyytteess**//cchhaarrpprrnnaammee[[PPNNMMLLEENN]];;//**PPrroocceessssnnaammee**//ssiidd3322pprrsseemm;;//**SSeemmaapphhoorreeoonnwwhhiicchhpprroocceesssswwaaiittss**//ppiidd3322pprrppaarreenntt;;//**IIDDoofftthheeccrreeaattiinnggpprroocceessss**//uummssgg3322pprrmmssgg;;//**MMeessssaaggeesseennttttootthhiisspprroocceessss**//bbooooll88pprrhhaassmmssgg;;//**NNoonnzzeerrooiiffffmmssggiissvvaalliidd**//iinntt1166pprrddeesscc[[NNDDEESSCC]];;//**DDeevviicceeddeessccrriippttoorrssffoorrpprroocceessss**//}};;//**MMaarrkkeerrffoorrtthheettooppooffaapprroocceessssssttaacckk((uusseeddttoohheellppddeetteeccttoovveerrffllooww))**//##ddeeffiinneeSSTTAACCKKMMAAGGIICC00xx00AA00AAAAAAAA99eexxtteerrnnssttrruuccttpprroocceennttpprrooccttaabb[[]];;eexxtteerrnniinntt3322pprrccoouunntt;;//**CCuurrrreennttllyyaaccttiivveepprroocceesssseess**//eexxtteerrnnppiidd3322ccuurrrrppiidd;;//**CCuurrrreennttllyyeexxeeccuuttiinnggpprroocceessss**//5.3 Process StatesTo record exactly what each process is doing and to validate operations performedon the process, each process is assigned a state. An operating system designer definesthe set of possible states as the design proceeds. Because many of the system functions that operate on processes use the state to determine whether an operation is valid, the set of states must be completely defined before the system can be implemented.Xinu uses field prstate in the process table to record state information for each process. The system defines seven valid states and a symbolic constant for each. The system also defines an additional constant that is assigned when a given table entry is unused (i.e., no process has been created to use that particular entry). File process.h contains the definitions; Figure 5.2 lists the symbolic state constants and the meaning of each.Because it runs as an embedded system, Xinu keeps the code and data for all processes in memory at all times. In larger operating systems, where a process executes an application program, the system can move a process to secondary storage when the process is not currently executing. Thus, in those systems, the process state also deter-mines whether the process must reside in memory or can be moved to disk temporarily.80 Scheduling And Context Switching Chap. 5Constant MeaningPR_FREE The entry in the process table is unused(not really a process state)PR_CURR The process is currently executingPR_READY The process is ready to executePR_RECV The process is waiting for a messagePR_SLEEP The process is waiting for a timerPR_SUSP The process is suspendedPR_WAIT The process is waiting on a semaphorePR_RECTIM The process is waiting for a timeror a message, whichever occurs firstFigure 5.2The seven symbolic constants that can be assigned to the state ofa process.5.4 Ready And Current StatesLater chapters will explain each process state in detail, and show how and why system functions change a process’s state. The remainder of this chapter focuses on the current and ready states.Almost every operating system includes ready and current process states. A proc-ess is classified ready if the process is ready (i.e., eligible) to execute, but is notcurrently executing; at any time, the single process executing is classified as current.†5.5 A Scheduling PolicySwitching from the currently executing process to another process consists of two steps: selecting a process from among those that are eligible to use the processor, and giving control of the processor to the selected process. Software that implements the policy for selecting a process is called a scheduler. In Xinu, function resched makes the selection according to the following well-known scheduling policy:At any time, the highest priority eligible process is executing. Among processes with equal priority scheduling is round-robin.†Recall that our initial discussions are focused on a single-core processor.Sec. 5.5        A Scheduling Policy 81Two aspects of the policy deserve attention:The currently executing process is included in the set of eligibleprocesses. Thus, if process p is currently executing and has ahigher priority than any of the other processes, process p will con-tinue to execute.The term round-robin refers to a situation in which a set of kprocesses all have the same priority and the priority of processes in the set is higher than the priority of other processes. The round-robin policy means that members of the set will receive service one after another so all members of the set have an opportunity to exe-cute before any member has a second opportunity.5.6 Implementation Of SchedulingThe key to understanding a scheduler lies in knowing that a scheduler is merely a function. That is, the operating system scheduler is not an active agent that picks up the processor from one process and moves it to another. Instead, a running process invokes the scheduler:†A scheduler consists of a function that a running process calls to will-ingly give up the processor.Recall that a process priority consists of a positive integer, and the priority for a given process is stored in the prprio field of the process’s entry in the process table. Auser assigns a priority to each process to control how the process will be selected for execution. A variety of complex scheduling policies have been proposed and measured, including schedulers that adjust the priority of processes dynamically, based on the ob-served behavior of each process. For most embedded systems, process priorities remain relatively static (typically, the priority does not change after a process has been created).To make the selection of a new process fast, our example system stores all ready processes on a list known as a ready list. Processes on a ready list are stored in des-cending order by priority. Thus, a highest priority process is immediately accessible at the head of the list.In the example code, the ready list is stored in the queuetab array described inChapter 4, and the scheduler uses functions from Chapter 4 to update and access thelist. That is, the key in each element on the ready list consists of the priority for the process to which the element corresponds. Global variable readylist contains the queue ID of the ready list.Should an operating system keep the current process on the ready list? The answer depends on details of the implementation. Either possibility is feasible provided an en-tire system follows one approach or the other. Xinu implements the following policy:†Later chapters explain how and why a process invokes the scheduler.82 Scheduling And Context Switching Chap. 5The current process does not appear on the ready list; to provide fast access to the current process, its ID is stored in global integer vari-able currpid.Consider what happens when the processor switches from one process to another. The currently executing process relinquishes the processor. Often, the process that was executing remains eligible to use the processor again. In such situations, the scheduler must change the state of the current process to PR_READY and insert the process onto the ready list, ensuring that it will be considered for service again later. In other cases, however, the current process does not remain ready to execute, which means the process should not be placed on the ready list.How does the scheduler decide whether to move the current process onto the ready list? In Xinu, the scheduler does not receive an explicit argument that specifies the disposition of the current process. Instead, the system functions use an implicit argu-ment: if the current process should not remain ready, before calling resched, the current process’s prstate field must be set to the desired next state. Whenever it prepares to switch to a new process, resched checks the prstate field of the current process. If the state still specifies PR_CURR, resched assumes the process should remain ready, and moves the process to the ready list. Otherwise, resched assumes the next state has al-ready been chosen. The next chapter shows an example.In addition to moving the current process to the ready list, resched completes every detail of scheduling and context switching except saving and restoring machine registers (which cannot be done directly in a high-level language like C).  Resched selects a new process to run, updates the process table entry for the new process, removes the new process from the ready list, marks it current, and updates currpid. It also resets the preemption counter, something we will consider later. Finally, resched calls function ctxsw to save the hardware registers of the current process and restore the registers for the new process. The code can be found in file resched.c://**rreesscchheedd..cc--rreesscchheedd,,rreesscchheedd__ccnnttll**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttddeeffeerrDDeeffeerr;;//**------------------------------------------------------------------------------------------------------------------------------------------------**rreesscchheedd--RReesscchheedduulleepprroocceessssoorrttoohhiigghheessttpprriioorriittyyeelliiggiibblleepprroocceessss**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddrreesscchheedd((vvooiidd))//**AAssssuummeessiinntteerrrruuppttssaarreeddiissaabblleedd**//{{ssttrruuccttpprroocceenntt**ppttoolldd;;//**PPttrrttoottaabblleeeennttrryyffoorroollddpprroocceessss**//ssttrruuccttpprroocceenntt**ppttnneeww;;//**PPttrrttoottaabblleeeennttrryyffoorrnneewwpprroocceessss**//Sec. 5.6        Implementation Of Scheduling 83//**IIffrreesscchheedduulliinnggiissddeeffeerrrreedd,,rreeccoorrddaatttteemmppttaannddrreettuurrnn**//iiff((DDeeffeerr..nnddeeffeerrss>>00)){{DDeeffeerr..aatttteemmpptt==TTRRUUEE;;rreettuurrnn;;}} //**PPooiinnttttoopprroocceessssttaabblleeeennttrryyffoorrtthheeccuurrrreenntt((oolldd))pprroocceessss**//ppttoolldd==&&pprrooccttaabb[[ccuurrrrppiidd]];;iiff((ppttoolldd-->>pprrssttaattee====PPRR__CCUURRRR)){{//**PPrroocceessssrreemmaaiinnsseelliiggiibbllee**//iiff((ppttoolldd-->>pprrpprriioo>>ffiirrssttkkeeyy((rreeaaddyylliisstt)))){{rreettuurrnn;;}} //**OOllddpprroocceesssswwiillllnnoolloonnggeerrrreemmaaiinnccuurrrreenntt**//ppttoolldd-->>pprrssttaattee==PPRR__RREEAADDYY;;iinnsseerrtt((ccuurrrrppiidd,,rreeaaddyylliisstt,,ppttoolldd-->>pprrpprriioo));;}} //**FFoorrcceeccoonntteexxttsswwiittcchhttoohhiigghheessttpprriioorriittyyrreeaaddyypprroocceessss**//ccuurrrrppiidd==ddeeqquueeuuee((rreeaaddyylliisstt));;ppttnneeww==&&pprrooccttaabb[[ccuurrrrppiidd]];;ppttnneeww-->>pprrssttaattee==PPRR__CCUURRRR;;pprreeeemmpptt==QQUUAANNTTUUMM;;//**RReesseettttiimmeesslliicceeffoorrpprroocceessss**//ccttxxssww((&&ppttoolldd-->>pprrssttkkppttrr,,&&ppttnneeww-->>pprrssttkkppttrr));;//**OOllddpprroocceessssrreettuurrnnsshheerreewwhheennrreessuummeedd**//rreettuurrnn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**rreesscchheedd__ccnnttll--CCoonnttrroollwwhheetthheerrrreesscchheedduulliinnggiissddeeffeerrrreeddoorraalllloowweedd**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussrreesscchheedd__ccnnttll((//**AAssssuummeessiinntteerrrruuppttssaarreeddiissaabblleedd**//iinntt3322ddeeffeerr//**EEiitthheerrDDEEFFEERR__SSTTAARRTToorrDDEEFFEERR__SSTTOOPP**//)){{sswwiittcchh((ddeeffeerr)){{84 Scheduling And Context Switching Chap. 5ccaasseeDDEEFFEERR__SSTTAARRTT:://**HHaannddlleeaaddeeffeerrrraallrreeqquueesstt**//iiff((DDeeffeerr..nnddeeffeerrss++++====00)){{DDeeffeerr..aatttteemmpptt==FFAALLSSEE;;}} rreettuurrnnOOKK;;ccaasseeDDEEFFEERR__SSTTOOPP:://**HHaannddlleeeennddooffddeeffeerrrraall**//iiff((DDeeffeerr..nnddeeffeerrss<<==00)){{rreettuurrnnSSYYSSEERRRR;;}} iiff((((----DDeeffeerr..nnddeeffeerrss====00))&&&&DDeeffeerr..aatttteemmpptt)){{rreesscchheedd(());;}} rreettuurrnnOOKK;;ddeeffaauulltt::rreettuurrnnSSYYSSEERRRR;;}}}}Resched begins by checking global variable Defer.ndefers to see whetherrescheduling is deferred. If so, resched sets global variable Defer.attempt to indicatethat an attempt was made during the deferral period and returns to the caller. As thenext section explains, deferred rescheduling is provided for situations where the operat-ing system must make multiple processes eligible to use the processor before allowing any to run. In particular, some I/O hardware delivers multiple data items on a single interrupt. If multiple processes are each waiting to read a data item, the operating sys-tem must handle all of them at the same time. For now, it is sufficient to understand that rescheduling can be deferred temporarily.Once it passes the test for deferral, resched examines the implicit parameterdescribed above: the state of the current process. If the state variable containsPR_CURR and the current process’s priority is the highest in the system, resched re-turns and the current process remains running. If the state specifies that the current process should remain eligible to use the processor but the current process does not have the highest priority, resched adds the current process to the ready list. Resched then removes the process at the head of the ready list (the highest priority process), and performs a context switch.It may be difficult to envision how context switching occurs because each con-current process has its own instruction pointer. To see how concurrency operates, sup-pose that process P1 is running and calls resched. Ifresched chooses to switch to proc-ess P2, process P1 will be stopped in the call to ctxsw. Once process P2 starts to run, it can execute arbitrary code. At a later time when resched switches back to process P1, execution will resume where it left off — in the call to ctxsw. The location at which P1Sec. 5.6        Implementation Of Scheduling 85is executing does not change just because P2 used the processor. When process P1 runs,the call to ctxsw will return to resched. A later section explains exactly how a context switch handles the details.5.7 Deferred ReschedulingAlthough our scheduling policy requires the highest priority eligible process to ex-ecute, resched permits scheduling to be deferred temporarily. The motivation arises be-cause some operating system functions move multiple processes onto the ready list at the same time. For example, consider a timer. If two or more processes choose delays that expire at the exact same time, the operating system must move all of them to the ready state. The important idea is that one or more of the processes that become ready may have a higher priority than the process that is currently executing. However, rescheduling in the midst of such a move can result in incomplete and incorrect opera-tion. In particular, rescheduling after making one process ready may cause the process to execute, even if other processes have higher priority. We will see an example in Chapter 7; for now, it is sufficient to understand that the situation can arise.The solution for multiple processes consists of temporarily suspending the schedul-ing policy. Function resched_cntl provides the mechanism. At any time, a process can make the call:resched_cntl(DEFER_START)to defer rescheduling, and then call:resched_cntl(DEFER_STOP)to end a deferral period and continue normal operation.To permit nested function calls that each request deferral, our implementation usesa global counter, Defer.ndefers, that is initialized to zero. When a deferral is requested,the code increments Defer.ndefers. Later, when a function ends its deferral period,Defer.ndefers is decremented. As long as the count remains positive, resched onlyrecords that a call was made, but returns to its caller without switching context. When Defer.ndefers reaches zero, resched_cntl examines Defer.attempt to see if resched was called during the deferral period. If so, resched_cntl invokes resched before returning to its caller.5.8 Implementation Of Context SwitchingBecause registers and hardware status cannot be manipulated directly with a high-level language, resched calls an assembly language function, ctxsw, to switch contextfrom one process to another. The code for ctxsw is, of course, machine dependent. Thelast step consists of resetting the program counter (i.e., jumping to the location in the86 Scheduling And Context Switching Chap. 5new process at which execution should resume). In Xinu, the text segment for the new process will be present in memory because Xinu keeps all parts of the program resident. The point is that the operating system must load all other state variables for the new process before jumping to the new process. Some architectures contain a pair of in-structions that are used in context switching: one stores processor state information in successive memory locations and the other loads processor state from successive memory locations. On such architectures, context switching code executes a single in-struction to save the processor state on the current process’s stack and another instruc-tion to load the processor state from the new process’s stack. Of course, each instruc-tion takes many cycles. RISC architectures often implement ctxsw with a sequence of instructions that each save one of the registers and a sequence of instructions that each load a register.5.9 State Saved In MemoryTo understand how ctxsw saves processor states, imagine that we can look at the memory of a system that has three active processes: two of which are ready and one of which is currently executing. Each process has a private stack. The process that is currently executing is using its stack. That is, the hardware stack pointer currently points to the top of the current process’s stack.† When it calls a function, the executing process pushes copies of registers on the stack and allocates space on the stack for local variables and temporary storage needed by the called function. When it returns from a function, the saved items are popped off the stack.Our context switching function is designed to store a copy of the machine state fora process on the process’s stack. That is, just before switching context, the code storesall pertinent information about the process on the process’s stack. Now imagine freez-ing the system at a point in time, and think about the two processes that are not current-ly executing. When they were running, the two processes each pushed state information on their stack because each performed a context switch as the last step before turning the processor over to another process. Thus, if we look in memory, each of the processes will have saved state information on the top of their stack. Figure 5.3 illus-trates the configuration.
†Recall that stacks grow downward in memory, so the top of a stack is the lowest memory address thathas been used in a process’s stack area.Sec. 5.9        State Saved In Memory 87memory
(a)(b)(c)unusedunusedunused
stack space for current processstack space for ready process bstack space for ready process a
stack pointer (sp) points hereusedsaved state for process busedsaved state for process aused
Figure 5.3Illustration of stacks in memory when processes (a) and (b) areon the ready list, and process (c) is currently executing.5.10 Context Switch OperationOur example ctxsw function takes two arguments: a pointer to the process table en-try for the current process and a pointer to the process table entry for the new process.Execute instructions that push the contents of the processor registeron the stack of the process that is running when ctxsw is called(i.e., the old process).Save the stack pointer in the process table entry for the currentprocess, and load the stack pointer for the “new” process.Execute instructions that reload the processor registers from valuespreviously saved on the new process’s stack.Return to the function in the new process that called ctxsw.Because context switching involves the direct manipulation of processor registers, the code is written in assembly language. In addition to saving copies of the general-purpose registers, most processors require a context switch to save internal hardware re-88 Scheduling And Context Switching Chap. 5gisters, such as the status register (i.e., the register that records whether the last arithme-tic result was positive, negative, or zero).The second step, saving and restoring stack pointers, is handled by passing two ar-guments to ctxsw. The first argument gives the address of the location in the processtable where the current process’s stack pointer should be stored. The second argument gives the address of the location in the process table where the stack pointer for the new process has previously been saved. Thus, when saving the stack pointer for the current process, the context switch merely needs to dereference the first argument. Similarly, to pick up the stack pointer for the new process, the context switch merely needs to dereference the second argument. We will see that on an Intel processor, one of the general purpose registers must be saved because dereferencing requires the use of one register. On the ARM architecture, the calling sequence requires the caller to save re-gisters r0 through r3 (which are used to pass arguments). Because the context switch function only has two arguments, only registers r0 and r1 contain argument values. Therefore, the ARM context switch code can use either of registers r2 or r3.After the second step, the hardware stack pointer points to the new process’s stack. Ctxsw extracts the set of values that was saved on the stack for the process, and loads the values into processor registers. The following sections show the code for the Inteland ARM platforms.5.10.1  Galileo (Intel)On an Intel platform, such as the Galileo, the context switch begins by savingvalues for the old process on the current stack (i.e., the old process’s stack). It firstpushes the EBX register (so EBX can be used to access the arguments). It then pushesthe processor flags and all general-purpose registers. The flags contain the current pro-cessor status. The code then saves the old process’s stack pointer in the location given by the first argument, and picks up the new process’s stack pointer from the location given by the second argument. Once the stack pointer has been switched, ctxsw restores values that were previously saved with the new process: the general-purpose registers, the flags, and the saved value of EBX. Finally, ctxsw returns. Note that when the re-turn occurs, the new process will be running. An Intel processor includes a single machine instruction to push copies of all the registers on the stack (pushal), and a single machine instruction to restore all the registers from the saved values (popal). File ctxsw.S contains the code.//**ccttxxssww..SS--ccttxxssww((ffoorrxx8866))**//..tteexxtt..gglloobbllccttxxssww//**------------------------------------------------------------------------------------------------------------------------------------------------**ccttxxssww--XX8866ccoonntteexxttsswwiittcchh;;tthheeccaalllliissccttxxssww((&&oolldd__sspp,,&&nneeww__sspp))**------------------------------------------------------------------------------------------------------------------------------------------------**//Sec. 5.10        Context Switch Operation 89ccttxxssww::ppuusshhll%%eebbpp//**PPuusshheebbppoonnttoossttaacckk**//mmoovvll%%eesspp,,%%eebbpp//**RReeccoorrddccuurrrreennttSSPPiinneebbpp**//ppuusshhffll//**PPuusshhffllaaggssoonnttootthheessttaacckk**//ppuusshhaall//**PPuusshhggeenneerraallrreeggss..oonnssttaacckk**////**SSaavveeoollddsseeggmmeennttrreeggiisstteerrsshheerree,,iiffmmuullttiipplleeaalllloowweedd**//mmoovvll88((%%eebbpp)),,%%eeaaxx//**GGeettmmeemmllooccaattiioonniinnwwhhiicchhttoo**////**ssaavveetthheeoollddpprroocceessss’’ssSSPP**//mmoovvll%%eesspp,,((%%eeaaxx))//**SSaavveeoollddpprroocceessss’’ssSSPP**//mmoovvll1122((%%eebbpp)),,%%eeaaxx//**GGeettllooccaattiioonnffrroommwwhhiicchhttoo**////**rreessttoorreenneewwpprroocceessss’’ssSSPP**////**TThheenneexxttiinnssttrruuccttiioonnsswwiittcchheessffrroommtthheeoollddpprroocceessss’’ss**////**ssttaacckkttootthheenneewwpprroocceessss’’ssssttaacckk..**//mmoovvll((%%eeaaxx)),,%%eesspp//**PPooppuuppnneewwpprroocceessss’’ssSSPP**////**RReessttoorreenneewwsseegg..rreeggiisstteerrsshheerree,,iiffmmuullttiipplleeaalllloowweedd**//ppooppaall//**RReessttoorreeggeenneerraallrreeggiisstteerrss**//mmoovvll44((%%eesspp)),,%%eebbpp//**PPiicckkuuppeebbppbbeeffoorreerreessttoorriinngg**////**iinntteerrrruuppttss**//ppooppffll//**RReessttoorreeiinntteerrrruuppttmmaasskk**//aadddd$$44,,%%eesspp//**SSkkiippssaavveeddvvaalluueeooffeebbpp**//rreett//**RReettuurrnnttoonneewwpprroocceessss**//5.10.2  BeagleBone Black (ARM)The context switch for an ARM platform, such as the BeagleBone Black, follows almost the same approach as on the Intel platform. On an ARM processor, the co-processor stores the internal hardware status register. Therefore, to save a copy of the status, the context switch must obtain the value from the co-processor. Instruction mrs moves the status from the co-processor status register to a specified general-purpose re-gister. As described above, the example code uses register r3 because the calling se-quence allows a called function to change r3. Once a copy of the status has been ob-tained, the code saves a copy of registers r3 through r12 and register lr on the current process’s stack. The code then saves the old process’s stack pointer in the location given by the first argument, picks up the new process’s stack pointer from the location given by the second argument, restores registers r3 through r12 and lr from the stack, restores the status register from r3, and returns.90 Scheduling And Context Switching Chap. 5Because it uses a RISC approach, an ARM processor does not have a singlemachine instruction that can save multiple registers, nor does the processor have a sin-gle machine instruction that can restore multiple registers. Instead, a given instructioncan only save (i.e., push) or restore (i.e., pop) a single register. Thus, one might expectthe context switch code to start with a series of statements that each push one register:push r3push r4push r5push r6push r7push r8push r9push r10push r11push r12push lrand to end with a series of statements that each pop one register:pop lrpop r12pop r11pop r10pop r9pop r8pop r7pop r6pop r5pop r4pop r3Interestingly, the code does not contain such sequences. Instead, the code uses as-sembler directives that the assembler interprets and uses to generate multiple instruc-tions. For example, the push directivepush {r3–r12, lr}instructs the assembler to generate a sequence of instructions that each push one of the registers listed. Similarly, the pop directive:pop {r3–r12, lr}causes the assembler to generate a sequence of pop instructions. The assembler gen-erates the pop sequence in the opposite order than the push sequence, which gives the instruction sequence illustrated above. File ctxsw.S contains the code.Sec. 5.10        Context Switch Operation 91//**ccttxxssww..SS--ccttxxssww((ffoorrAARRMM))**//..tteexxtt..gglloobbllccttxxssww//**------------------------------------------------------------------------------------------------------------------------------------------------**ccttxxssww--AARRMMccoonntteexxttsswwiittcchh;;tthheeccaalllliissccttxxssww((&&oolldd__sspp,,&&nneeww__sspp))**------------------------------------------------------------------------------------------------------------------------------------------------**//ccttxxssww::ppuusshh{{rr00--rr1111,,llrr}}//**PPuusshhrreeggss00--1111aannddllrr**//ppuusshh{{llrr}}//**PPuusshhrreettuurrnnaaddddrreessss**//mmrrssrr22,,ccppssrr//**OObbttaaiinnssttaattuussffrroommccoopprroocceessss..**//ppuusshh{{rr22}}//**aannddppuusshhoonnttoossttaacckk**//ssttrrsspp,,[[rr00]]//**SSaavveeoollddpprroocceessss’’ssSSPP**//llddrrsspp,,[[rr11]]//**PPiicckkuuppnneewwpprroocceessss’’ssSSPP**//ppoopp{{rr00}}//**UUsseessttaattuussaassaarrgguummeennttaanndd**//bbllrreessttoorree//**ccaallllrreessttoorreettoorreessttoorreeiitt**//ppoopp{{llrr}}//**PPiicckkuupptthheerreettuurrnnaaddddrreessss**//ppoopp{{rr00--rr1122}}//**RReessttoorreeootthheerrrreeggiisstteerree**//mmoovvppcc,,rr1122//**RReettuurrnnttootthheenneewwpprroocceessss**//5.11 An Address At Which To Restart A ProcessA potential problem arises during context switching because the processor can change registers. Thus, the code must be written carefully because once a given register has been saved, subsequent changes will be lost when the process restarts. Fortunately, the standard calling sequence helps by saving and restoring registers when the context switch function is called. The instruction pointer (i.e., program counter) represents a special dilemma, because storing the value means that when the process restarts, execu-tion will continue at exactly the point in the code at which the instruction pointer was stored. If a copy of the instruction pointer is saved before the context switch has com-pleted, the process will restart at a point before the context switch has occurred. The code in ctxsw reveals how the situation is resolved: the instruction pointer is not among the registers saved on the stack. Instead, we only save the address to which ctxsw should return.To understand the idea, think of an executing process, P, that has called reschedwhich has then called ctxsw. We assume that the only way P will regain the processorlater will occur when some other process calls ctxsw. So, if we save the return address, when P runs again, ctxsw will return as if it were a normal function. Consequently:When a process restarts, the process will resume execution in resched immediately following the call to ctxsw.92 Scheduling And Context Switching Chap. 5We assume that no context switching occurs outside of ctxsw. That is, allprocesses must call resched to perform context switching, and resched calls ctxsw.Thus, if one were to freeze the system at an arbitrary instant and examine memory, the saved information for each ready process will have the same value for a return address — an address just after the call to ctxsw in resched. However, each process has its own stack of function calls, which means that when a given process resumes execution and returns from resched, the return may go to a different caller than the return in another process.The notion of function return forms a key ingredient in keeping the system design clean. Function calls proceed downward through each level of the system, and each call returns. To enforce the design at all levels, the scheduler, resched, and the context switch, ctxsw, have each been designed to behave like any other function and return. To summarize:In Xinu, each function, including the scheduler and context switch, eventually returns to its caller.Of course, rescheduling allows other processes to execute, and the execution may take arbitrarily long (depending on process priorities). Thus, a considerable delay may elapse between a call to resched and the time the call returns and the process runs again.5.12 Concurrent Execution And A Null ProcessThe concurrent execution abstraction is complete and absolute. That is, an operat-ing system views all computation as part of a process — there is no way that the pro-cessor can temporarily stop executing processes and execute a separate piece of code. The scheduler design reflects the following principle: the scheduler’s only function is to switch the processor among the set of processes that are current or ready. The scheduler cannot execute any code that is not part of a process, and cannot create a new process. Figure 5.4 illustrates the possible state transitions.READYCURRENTreschedreschedFigure 5.4Illustrations of state transitions for processes between the readyand current states.Sec. 5.12        Concurrent Execution And A Null Process 93We will see that a given process does not always remain ready to execute. For ex-ample, a process stops executing when it waits for I/O to complete or when it needs touse a shared resource that is already in use. What happens if all processes wait for I/O? Resched will fail because the code has been designed to assume at least one process will be eligible to execute at any time. When the currently executing process blocks, resched removes the first process from the ready list without verifying that the list is nonempty. If the list is empty, an error results. To summarize:Because an operating system can only switch the processor from one process to another, at least one process must remain ready to execute at all times.To ensure that at least one process always remains ready to execute, Xinu uses a standard technique: it creates an extra process, called the null process, when the system boots. The null process has process ID zero and priority zero (a lower priority than any other process). The null process code, which will be shown in Chapter 22, consists of an infinite loop. Because all other processes must have a priority greater than zero, the scheduler switches to the null process only when no other process is ready to run. In essence, the operating system switches the processor to the null process when all other processes are blocked (e.g., waiting for I/O).†5.13 Making A Process Ready And The Scheduling InvariantBecause it performs a swap by removing a process from the ready list and (possi-bly) moving the current process onto the ready list, reschedmanipulates the list directly. We will see that many other functions need to make a process eligible for processor ser-vice. The task occurs so frequently that we designed a function to do just that. The function is named ready.Ready takes an argument that specifies a process ID, and makes the process eligi-ble to execute. Our scheduling policy specifies that at any time, the highest priority eli-gible process must be executing. We say that each operating system function should maintain a scheduling invariant: a function assumes the highest priority process was ex-ecuting when the function was called, and must ensure that the highest priority process is executing when the function returns. Thus, if a function changes the state of processes, the function must call resched to reestablish the invariant. Thus, when it places a high priority process on the ready list, ready calls resched to ensure that the policy is followed. File ready.c contains the code.
†Some processors include a special instruction that can be placed in a null process that stops the proces-sor until an interrupt occurs; using the special instruction may reduce the energy that the processor consumes.94 Scheduling And Context Switching Chap. 5//**rreeaaddyy..cc--rreeaaddyy**//##iinncclluuddee<<xxiinnuu..hh>>qqiidd1166rreeaaddyylliisstt;;//**IInnddeexxooffrreeaaddyylliisstt**////**------------------------------------------------------------------------------------------------------------------------------------------------**rreeaaddyy--MMaakkeeaapprroocceesssseelliiggiibblleeffoorrCCPPUUsseerrvviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussrreeaaddyy((ppiidd3322ppiidd//**IIDDooffpprroocceessssttoommaakkeerreeaaddyy**//)){{rreeggiisstteerrssttrruuccttpprroocceenntt**pprrppttrr;;iiff((iissbbaaddppiidd((ppiidd)))){{rreettuurrnnSSYYSSEERRRR;;}} //**SSeettpprroocceessssssttaatteettooiinnddiiccaatteerreeaaddyyaannddaaddddttoorreeaaddyylliisstt**//pprrppttrr==&&pprrooccttaabb[[ppiidd]];;pprrppttrr-->>pprrssttaattee==PPRR__RREEAADDYY;;iinnsseerrtt((ppiidd,,rreeaaddyylliisstt,,pprrppttrr-->>pprrpprriioo));;rreesscchheedd(());;rreettuurrnnOOKK;;}}5.14 Other Process Scheduling AlgorithmsProcess scheduling was once an important topic in operating systems, and many scheduling algorithms have been proposed as alternatives to the round-robin schedulerin Xinu. For example, one policy measures the amount of I/O a process performs and gives the processor to the process that spends the most time doing I/O. Proponents of the policy argue that because I/O devices are slower than processors, choosing a proc-ess that performs I/O will increase the total throughput of the system.Because scheduling is confined to a few functions, it is easy to experiment with the scheduling policy in Xinu. Changing resched and ready changes the basic scheduler. Of course, if the new policy uses data that Xinu does not already gather (e.g., theamount of time spent doing I/O), other functions may need to change to record the ap-propriate data.Sec. 5.15        Perspective955.15 PerspectiveThe most interesting aspect of scheduling and context switching arises because they are embedded as part of normal computation. That is, instead of the operating sys-tem being implemented separately from the processes it controls, the operating system code is executed by the processes themselves. Thus, the system does not have an extra process that can stop the processor from executing one application and move it to another, scheduling and context switching occur as the side effect of a function call.We will see that using processes to execute operating system code affects the design. When a programmer writes an operating system function, the programmer must accommodate execution by concurrent processes. Similarly, using processes to execute operating system code affects how the system interacts with I/O devices and how it handles interrupts.5.16 SummaryScheduling and context switching form a foundation for concurrent execution. Scheduling consists of choosing a process from among those that are eligible for execu-tion. Context switching consists of stopping one process and starting a new one. To keep track of processes, the system uses a global data structure called a process table. Whenever it temporarily suspends a process, the context switch saves the processor state for the process on the process’s stack and places a pointer to the stack in the process table. To restart a process, the context switch reloads the processor state information from the process’s stack, and resumes execution in the process at the point the call to the context switch function returns.To allow functions to determine when an operation is permitted, each process is as-signed a state. A process that is using the processor is assigned the current state, and a process that is eligible to use the processor, but is not currently executing, is assigned the ready state. Because at least one process must remain eligible to execute at any time, the operating system creates an extra process at startup known as the null process. The null process has priority zero, and all other processes have priority greater than zero. Consequently, the null process only runs when no other process is eligible.The chapter presents three functions that perform transitions between the current and ready states. Function resched performs scheduling, function ctxsw performs con-text switching, and function readymakes a process eligible to execute.EXERCISES5.1 If the operating system contains a total of N processes, how many processes can be on theready list at a given time? Explain.5.2    How do operating system functions know which process is executing at a given time?96 Scheduling And Context Switching Chap. 55.3 Rewrite resched to have an explicit parameter giving the disposition of the currently exe-cuting process, and examine the assembly code generated to determine the number of in-structions executed in each case.5.4 What are the basic steps performed during a context switch?5.5   Investigate another hardware architecture (e.g., SPARC or MIPS), and determine what in-formation needs to be saved during a context switch.5.6  How much memory is needed to store processor state for a MIPS processor? Which regis-ters must be saved, and why? How does the standard calling convention for a processor af-fect the answer?5.7  Suppose process k has been placed on the ready list. When process k becomes current,where will execution start?5.8 Why is a null process needed?5.9 Consider a modification to the code that stores processor state in the process table insteadof on the process’s stack (i.e., assume the process table entry contains an array that holdsthe contents of registers). What are the advantages of each approach?5.10  In the previous exercise, does saving registers in the process table reduce or increase thenumber of instructions executed during a context switch?5.11 Devise a scheduling policy for a dual-core processor (i.e., a processor that contains twoseparate processing cores that can execute in parallel).5.12 Extend the previous exercise: show that executing resched on one core may require chang-ing the process that is running on the other core. (Note: many operating systems for dual-core processors avoid the problem by specifying that all operating system functions, includ-ing scheduling, run on one of the two cores.)5.13 Variable Defer.attempt records whether resched was called during the period whenrescheduling is deferred, but it does not record whether a context switch would have oc-curred. Should the code be rewritten to record whether rescheduling is needed rather than whether resched was called? Why or why not?Chapter Contents6.1 Introduction, 996.2 Process Suspension And Resumption, 996.3 Self–suspension And Information Hiding, 1006.4 The Concept Of A System Call, 1016.5 Interrupt Control With Disable And Restore, 1036.6 A System Call Template, 1046.7 System Call Return Values SYSERR And OK, 1056.8 Implementation Of Suspend, 1056.9 Suspending The Current Process, 1076.10 The Value Returned By Suspend, 1076.11 Process Termination And Process Exit, 1086.12 Process Creation, 1116.13 Other Process Manager Functions, 1156.14 Summary, 1176More Process Management
When men willingly suspend fear, science flourishes.— Anonymous6.1 IntroductionChapter 5 discusses the concurrent execution abstraction and process execution. The chapter explains how an operating system stores information about processes in a table, and how each process is assigned a state. Chapter 5 also explains the concepts of scheduling and context switching. It shows how a scheduler implements a scheduling policy, and explains how a process moves between the ready and current states.This chapter extends our study of the process management functions in an operat-ing system. The chapter explains how a new process comes into existence, and what happens when a process exits. The chapter also examines a process state that allows a process to be suspended temporarily, and explores functions that move processes among the current, ready, and suspended states.6.2 Process Suspension And ResumptionWe will see that operating system functions sometimes need to stop a process from executing temporarily and, at a later time, resume execution. We say that a stopped process has been placed in a state of “suspended animation.” For example, suspended animation can be used when a process waits for one of several restart conditions without knowing which will occur first.99100 More Process Management Chap. 6The first step in implementing operating system functionality consists of defining a set of operations. In the case of suspended animation, only two conceptual operations provide all the functionality that is needed:Suspend stops a process and places the process in suspended ani-mation (i.e., makes the process ineligible to use the processor).Resume continues execution of a previously suspended process(i.e., makes the process eligible to use the processor again).Because it is not eligible to use the processor, a suspended process cannot remainin either the ready or current states. Thus, a new state must be invented. We call thenew state suspended, and add the new state and associated transitions to the state di-agram. Figure 6.1 shows the extended state diagram, which summarizes how suspend and resume affect the state. The resulting diagram documents the possible transitions among the ready, current, and suspended states.READYCURRENTreschedreschedSUSPENDEDsuspendresumesuspendFigure 6.1  Transitions among the current, ready, and suspended states.6.3 Self–suspension And Information HidingAlthough each state transition in Figure 6.1 has a label that specifies a particular function, process suspension differs from scheduling in a significant way: instead of act-ing on the current process, suspend allows one process to suspend another process. More important, because a suspended process cannot resume itself, resume must allow an executing process to resume a previously suspended process. Thus, suspend and resume each take an argument that specifies the ID of a process on which the operation should be performed.Can a process suspend itself? Yes. To do so, a process must obtain its process IDand then pass the ID as an argument to suspend. An implementation may seem obvi-ous. Because global variable currpid contains the process ID of the currently executing process, a self-suspension can be achieved with:Sec. 6.3        Self–suspension And Information Hiding 101suspend( currpid );However, a well-designed operating system design adheres to the principle of in-formation hiding: implementation details are not generally revealed. Thus, instead of permitting processes to access global variables like currpid directly, Xinu includes a function named getpid that a process can call to obtain its ID. Thus, to suspend itself, a process calls:suspend( getpid( ) );The present implementation of getpid merely returns the value of currpid, which may seem like unnecessary overhead. However, the advantage of information hiding becomes clear when one considers modifying the operating system. If all processes call getpid, a designer can change the details of where and how the current process ID is stored without changing other code.The point is:A good system design follows the principle of information hiding,which states that implementation details are not revealed unless necessary. Hiding such details makes it possible to change the imple-mentation of a function without rewriting code that uses the function.6.4 The Concept Of A System CallIn theory, process resumption is straightforward. The process must be placed in the ready state and inserted in the correct position on the ready list. The ready function described in the previous chapter performs both tasks, so it may seem that resume is un-necessary. In practice, however, resume adds an extra layer of protection: it makes no assumptions about the caller or the correctness of the arguments. In particular, an arbi-trary process can invoke resume at an arbitrary time with arbitrary arguments.We used the term system call to distinguish a function like resume from internal functions like ready. In general, we think of the set of system calls as defining a viewof the operating system from the outside — application processes invoke system calls to obtain services. In addition to adding a layer of protection, the system call interface provides another example of information hiding: application processes remain unaware of the internal implementation, and can only use the set of system calls to obtain ser-vice. We will see that the distinction between system calls and other functions appears throughout an operating system. To summarize:System calls, which define operating system services for applications, protect the system from illegal use and hide information about the underlying implementation.102 More Process Management Chap. 6To provide protection, system calls handle three aspects of computation that under-lying functions do not:Check all argumentsEnsure that changes leave global data structures in aconsistent stateReport success or failure to the callerIn essence, a system call cannot make any assumptions about the process that is making the call. Thus, instead of assuming that the caller has supplied correct and meaningful argument values, a system call checks each argument. More important, many system calls make changes to operating system data structures, such as the proc-ess table and lists of processes stored in the queue structure. A system call must guarantee that no other process will attempt to change data structures at the same time, or inconsistencies can result. Because it cannot make assumptions about the conditions under which it will be invoked, a system call must take steps to prevent other processes from executing concurrently while data structures are being changed. There are two as-pects:Avoid invoking any functions that voluntarily relinquish the pro-cessorDisable interrupts to prevent involuntarily relinquishing the proces-sorTo prevent voluntarily relinquishing the processor, a system call must avoid direct or indirect calls to resched. That is, while changes are in progress, a system call cannot invoke resched directly and cannot invoke any function that calls resched. To prevent involuntarily relinquishing the processor, a system call disables interrupts until a change is complete. In Chapter 13, we will understand the reason: hardware interrupts can result in rescheduling because some interrupt routines call resched.An example system call will help clarify the two aspects. Consider the code forresume that is contained in file resume.c.//**rreessuummee..cc--rreessuummee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rreessuummee--UUnnssuussppeennddaapprroocceessss,,mmaakkiinnggiittrreeaaddyy**------------------------------------------------------------------------------------------------------------------------------------------------**//pprrii1166rreessuummee((ppiidd3322ppiidd//**IIDDooffpprroocceessssttoouunnssuussppeenndd**//Sec. 6.4        The Concept Of A System Call 103)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//pprrii1166pprriioo;;//**PPrriioorriittyyttoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd)))){{rreessttoorree((mmaasskk));;rreettuurrnn((pprrii1166))SSYYSSEERRRR;;}} pprrppttrr==&&pprrooccttaabb[[ppiidd]];;iiff((pprrppttrr-->>pprrssttaattee!!==PPRR__SSUUSSPP)){{rreessttoorree((mmaasskk));;rreettuurrnn((pprrii1166))SSYYSSEERRRR;;}} pprriioo==pprrppttrr-->>pprrpprriioo;;//**RReeccoorrddpprriioorriittyyttoorreettuurrnn**//rreeaaddyy((ppiidd));;rreessttoorree((mmaasskk));;rreettuurrnnpprriioo;;}}6.5 Interrupt Control With Disable And RestoreAs expected, the code in resume checks argument pid to ensure that the caller has supplied a valid process ID and the specified process is in the suspended state. Before it performs any computation, however, resume guarantees that no interrupts will occur (i.e., no context switching can occur until resume invokes an operating system functionthat causes a context switch). To control interrupts, resume uses a pair of functions:†Function disable disables interrupts and returns the previous inter-rupt status to its caller.Function restore reloads an interrupt status from a previously savedvalue.As expected, resume disables interrupts immediately upon entry. Resume can re-turn in two ways: either an error is detected or resume finishes the requested operation successfully. In either case, resume must call restore before returning to reset the inter-rupt status to the same value the caller was using when the call began.Programmers who do not have experience writing code for operating systems often expect a system call to enable interrupts before returning. However, restore providesmore generality. To see why, observe that because it restores interrupts rather than sim-ply enabling them, resume works correctly whether it is called with interrupts enabled or disabled. On the one hand, if a function has interrupts disabled when it calls resume, †Chapter 12 explains the details of interrupt handling.104 More Process Management Chap. 6the call will return with interrupts disabled. On the other hand, if a function has inter-rupts enabled when it calls resume, the call will return with interrupts enabled.System calls must disable interrupts to prevent other processes from changing global data structures; using a disable / restore paradigm in-creases generality.6.6 A System Call TemplateAnother way to look at interrupt handling focuses on an invariant that a systemfunction must maintain:An operating system function always returns to its caller with thesame interrupt status as when it was called.To ensure the invariant is maintained, operating system functions follow the gen-eral approach that Figure 6.2 illustrates.ssyyssccaallll function_name((args)){{iinnttmmaasskkmmaasskk;;//** Saved interrupt mask **//mmaasskk==ddiissaabbllee(());;//** Disable interrupts at start of function **//iiff(( args are incorrect )){{rreessttoorree((mmaasskk));;//** Restore interrupts before error return **//rreettuurrnnSSYYSSEERRRR;;}} ......other processing......iiff(( an error occurs )){{rreessttoorree((mmaasskk));;//** Restore interrupts before error return **//rreettuurrnnSSYYSSEERRRR;;}} ......more processing......rreessttoorree((mmaasskk));;//** Restore interrupts before normal return**//rreettuurrnn appropriate value ;;}}Figure 6.2  Illustration of the general form of an operating system function.Sec. 6.6        A System Call Template 1056.7 System Call Return Values SYSERR And OKWe will see that some system calls return a value that relates to the function being performed and others merely return a status to indicate that the call was successful. Resume provides an example of the former: it returns the priority of the process that has been resumed. In the case of resume, care must be taken to record the priority before calling ready because the resumed process may have higher priority than the currently executing process. Thus, as soon as ready places the specified process on the ready list and calls resched, the new process may begin executing. In fact, an arbitrary delay can occur between the time resume calls ready and execution continues after the call. Dur-ing the delay, an arbitrary number of other processes can execute and processes may terminate. Thus, to ensure that the returned priority reflects the resumed process’s priority at the time of resumption, resume makes a copy in local variable prio before calling ready.  Resume uses the local copy as the return value.To aid in reporting status, Xinu defines two constants that are used as return values throughout the system. A function returns SYSERR to indicate that an error occurredduring processing. That is, a system function returns SYSERR if the arguments are in-correct (e.g., outside the acceptable range) or the requested operation could not be com-pleted successfully. A function such as ready that does not compute a specific return value uses constant OK to indicate that the operation was successful.6.8 Implementation Of SuspendAs the state diagram in Figure 6.1 indicates, suspend can only be applied to a proc-ess that is current or ready. Suspension of a ready process is trivial: the process mustbe removed from the ready list and its state must be changed to suspended. No further action is required. Thus, after deleting the process from the ready list and changing the process’s state to PR_SUSP, suspend can restore interrupts and return to its caller. The suspended process will remain ineligible to use the processor until it has been resumed.Suspending the current process is almost as easy. The only subtle point is that resched uses an implicit argument to specify the disposition of the calling process. Re-call from Chapter 5 that if a caller does not want to remain eligible to use the processor, the caller must set its state before invoking resched. Therefore, to suspend the current process, suspend must set the state of the current process to PR-SUSP and then call resched. That is, suspend sets the state of the current process to the desired next state.The code for function suspend can be found in file suspend.c.106 More Process Management Chap. 6//**ssuussppeenndd..cc--ssuussppeenndd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ssuussppeenndd--SSuussppeennddaapprroocceessss,,ppllaacciinnggiittiinnhhiibbeerrnnaattiioonn**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllssuussppeenndd((ppiidd3322ppiidd//**IIDDooffpprroocceessssttoossuussppeenndd**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//pprrii1166pprriioo;;//**PPrriioorriittyyttoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd))||||((ppiidd====NNUULLLLPPRROOCC)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**OOnnllyyssuussppeennddaapprroocceesssstthhaattiissccuurrrreennttoorrrreeaaddyy**//pprrppttrr==&&pprrooccttaabb[[ppiidd]];;iiff((((pprrppttrr-->>pprrssttaattee!!==PPRR__CCUURRRR))&&&&((pprrppttrr-->>pprrssttaattee!!==PPRR__RREEAADDYY)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} iiff((pprrppttrr-->>pprrssttaattee====PPRR__RREEAADDYY)){{ggeettiitteemm((ppiidd));;//**RReemmoovveeaarreeaaddyypprroocceessss**////**ffrroommtthheerreeaaddyylliisstt**//pprrppttrr-->>pprrssttaattee==PPRR__SSUUSSPP;;}}eellssee{{pprrppttrr-->>pprrssttaattee==PPRR__SSUUSSPP;;//**MMaarrkktthheeccuurrrreennttpprroocceessss**//rreesscchheedd(());;//**ssuussppeennddeeddaannddrreesscchheedd..**//}} pprriioo==pprrppttrr-->>pprrpprriioo;;rreessttoorree((mmaasskk));;rreettuurrnnpprriioo;;}}Like resume, suspend is a system call, which means the function disables interrupts when it is invoked. In addition, suspend checks argument pid to verify that it is a validSec. 6.8        Implementation Of Suspend 107process ID. Because suspension is only valid for a process that is ready or current, the code verifies that the process is in one of the two valid states. If an error is detected, suspend restores interrupts and returns SYSERR to the caller.6.9 Suspending The Current ProcessThe code for suspending the currently executing process raises two interesting points. First, the currently executing process will stop executing, at least temporarily. Thus, before suspending itself, the current process must prearrange for some other proc-ess to resume it (or it will remain suspended forever). Second, because it will be suspended, the current process must allow another process to execute. Thus, when suspending the current process, suspend must call resched. The key idea is that when a process suspends itself, the process remains executing until the call to resched selects another process and switches context.Note that when a process is suspended, resched does not place the process on the ready list. In fact, a suspended process is not on a list of suspended processes because there is no list of suspended processes analogous to the list of ready processes. Ready processes are only kept on an ordered list to speed the search for the highest priority process during rescheduling. Because the system never searches through suspended processes looking for one to resume, the set of suspended processes need not be kept on a list. Thus, before suspending a process, a programmer must arrange a way for another process to find the ID of the suspended process so it can be resumed.6.10 The Value Returned By SuspendSuspend, like resume, returns the priority of the suspended process to its caller. In the case of a ready process, the value returned will reflect the priority the process had when suspend was called. (Once suspend disables interrupts, no other process can change priorities in the system, so the priority can be recorded at any time before suspend restores interrupts.) In the case of the current process, however, a question arises: should suspend return the priority that was in effect when suspend was invoked or the priority the process has after the process has been resumed (i.e., when suspend re-turns)? The two values can differ because it is possible to change the priority of a proc-ess at any time, which means the priority can change while the process is suspended. In terms of the code, the question is whether the local copy of the priority should be recorded before the call to resched or afterward (the version above records it afterward).To understand one possible motivation for returning the priority at the time of resumption, consider how the priority can be used to convey information. Suppose, for example, that a process needs to suspend until one of two events occurs. A programmer can assign a unique priority value to each event (e.g., priorities 25 and 26), and arrange the calls to resume to set the priority accordingly. The process can then use the priority to determine why it was resumed:108 More Process Management Chap. 6nneewwpprriioo==ssuussppeenndd((ggeettppiidd(())));;iiff((nneewwpprriioo====2255)){{......EEvveenntt11hhaassooccccuurrrreedd......}}eellssee{{ ......EEvveenntt22hhaassooccccuurrrreedd......}}6.11 Process Termination And Process ExitAlthough it freezes a process temporarily, suspend saves information about a proc-ess so the process can be resumed later. Another system call, kill, implements process termination by completely removing a process from the system. Once it has been killed, a process cannot be restarted because kill eradicates the entire record and frees the process table entry for reuse by a new process.The actions taken by kill depend on the process state. Before writing the code, a designer needs to consider each possible process state and what it means to terminate a process in that state. We will see, for example, that a process in the ready, sleeping, or waiting states is stored on one of the linked lists in the queue structure, which means kill must dequeue the process. In the next chapter, we will see that if a process is wait-ing for a semaphore, kill must adjust the semaphore count. Each of the cases will be-come clear once we have examined the process state and the functions that control the state. For now, it is sufficient to understand the overall structure of kill and see how it handles processes that are current or ready. The code for kill appears in file kill.c.Kill checks its argument, pid, to ensure that it corresponds to a valid process other than the null process (the null process cannot be killed because it must remain running). Kill then decrements prcount, a global variable that records the number of active user processes, and calls function freestk to free memory that has been allocated for the process’s stack. The remaining actions depend on the process’s state. For a process that is in the ready state, kill removes the process from the ready list and then frees the process table entry by assigning value PR_FREE to the process’s state. Because it no longer appears on the ready list, the process will not be selected for rescheduling; be-cause it has state PR_FREE, the entry in the process table can be reused.Now consider what happens when kill needs to terminate the currently executing process. We say that the process exits. As before, kill validates its argument and decre-ments the count of active processes. If the current process happens to be the last user process, decrementing prcount makes it zero, so kill calls function xdone, which is ex-plained below. Because resched uses an implicit argument to control disposition of the current process, kill must set the current process’s state to the desired state before cal-ling resched. To remove the current process from the system, kill sets the current process’s state to PR_FREE, meaning that the process table slot is unused, and then calls resched.Sec. 6.11        Process Termination And Process Exit 109//**kkiillll..cc--kkiillll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**kkiillll--KKiillllaapprroocceessssaannddrreemmoovveeiittffrroommtthheessyysstteemm**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllkkiillll((ppiidd3322ppiidd//**IIDDooffpprroocceessssttookkiillll**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//iinntt3322ii;;//**IInnddeexxiinnttooddeessccrriippttoorrss**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd))||||((ppiidd====NNUULLLLPPRROOCC))||||((((pprrppttrr==&&pprrooccttaabb[[ppiidd]]))-->>pprrssttaattee))====PPRR__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} iiff((----pprrccoouunntt<<==11)){{//**LLaassttuusseerrpprroocceessssccoommpplleetteess**//xxddoonnee(());;}} sseenndd((pprrppttrr-->>pprrppaarreenntt,,ppiidd));;ffoorr((ii==00;;ii<<33;;ii++++)){{cclloossee((pprrppttrr-->>pprrddeesscc[[ii]]));;}} ffrreeeessttkk((pprrppttrr-->>pprrssttkkbbaassee,,pprrppttrr-->>pprrssttkklleenn));;sswwiittcchh((pprrppttrr-->>pprrssttaattee)){{ccaasseePPRR__CCUURRRR::pprrppttrr-->>pprrssttaattee==PPRR__FFRREEEE;;//**SSuuiicciiddee**//rreesscchheedd(());;ccaasseePPRR__SSLLEEEEPP::ccaasseePPRR__RREECCTTIIMM::uunnsslleeeepp((ppiidd));;pprrppttrr-->>pprrssttaattee==PPRR__FFRREEEE;;bbrreeaakk;;ccaasseePPRR__WWAAIITT::110 More Process Management Chap. 6sseemmttaabb[[pprrppttrr-->>pprrsseemm]]..ssccoouunntt++++;;//**FFaalllltthhrroouugghh**//ccaasseePPRR__RREEAADDYY::ggeettiitteemm((ppiidd));;//**RReemmoovveeffrroommqquueeuuee**////**FFaalllltthhrroouugghh**//ddeeffaauulltt::pprrppttrr-->>pprrssttaattee==PPRR__FFRREEEE;;}} rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}When the last user process exits, kill calls xdone. In some systems, xdone powersdown the device. In others, xdone restarts the device. In our example, xdone merelyprints a message on the console, and halts the processor. The code is found in filexdone.c.//**xxddoonnee..cc--xxddoonnee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**xxddoonnee--PPrriinnttssyysstteemmccoommpplleettiioonnmmeessssaaggeeaassllaassttpprroocceesssseexxiittss**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddxxddoonnee((vvooiidd)){{kkpprriinnttff((""\\nn\\nnAAlllluusseerrpprroocceesssseesshhaavveeccoommpplleetteedd..\\nn\\nn""));;hhaalltt(());;//**HHaalltttthheepprroocceessssoorr**//}}Why should kill invoke function xdone? Doing so may seem unnecessary becausethe code is trivial and could easily be incorporated into kill itself. The motivation forusing a function stems from a desire to separate functionality: a programmer can change the action taken when all processes exit without modifying kill.A more serious question arises because xdone is invoked before the last user proc-ess has been removed from the system. To understand the problem, consider a fault-tolerant design that restarts processes in the case all processes exit. With the current implementation, one of the process table slots remains in use when xdone is called. The exercises consider an alternative implementation.Sec. 6.12        Process Creation 1116.12 Process CreationAs we have seen, processes are dynamic — a process can be created at any time.The system call create starts a new, independent process. In essence, create builds animage of the process as if it had been stopped while running. Once the image has been constructed and the process has been placed on the ready list, ctxsw can switch to it.A look at the code in file create.c explains most of the details.  Create uses func-tion newpid to search the process table for a free (i.e., unused) slot. Once a slot has been found, create allocates space for the new process’s stack, and fills in the process table entry. Create calls getstk to allocate space for a stack (Chapter 9 discussesmemory allocation).The first argument to create specifies the initial function at which the processshould start execution. Create forms a saved environment on the process’s stack as ifthe specified function had been called. Consequently, we refer to the initial config-uration as a pseudo call. To build a pseudo call, create stores initial values for the re-gisters, including the stack pointer and a return address in the pseudo-call on the process’s stack. When ctxsw switches to it, the new process begins executing the code for the designated function, obeying the normal calling conventions for accessing argu-ments and allocating local variables. In short, the initial function for a process behaves exactly as if it had been called.What value should create use as a return address in the pseudo call? The value determines what action the system will take if a process returns from its initial (i.e.,top-level) function. Our example system follows a well-known paradigm:If a process returns from the initial (top-level) function in which its execution started, the process exits.To be precise, we should distinguish between a return from the function itself anda return from the initial call. To see why, observe that C permits recursive functioncalls. Thus, if a process begins in function X which recursively calls X, the first return merely pops one level of recursion and returns to the initial call without causing the process to exit. If the process returns again (or reaches the end of X) without making further calls, the process will exit.To arrange for an exit to occur when the initial call returns, create assigns the ad-dress of function userret as the return address in the pseudo call. The code uses sym-bolic constant INITRET, which has been defined to be function name userret.† If dur-ing the initial call the process reaches the end of the function or explicitly invokes re-turn, control will pass to userret. Function userret terminates the current process by calling kill.Create also fills in the process table entry. In particular, create makes the state of the newly created process PR_SUSP, leaving it suspended, but otherwise ready to run. Finally, create returns the process ID of the newly created process; the process must be resumed before it can execute.†Using a symbolic constant allows the choice to be overridden in a configuration file rather than requir-ing the code to be changed.112 More Process Management Chap. 6Many of the process initialization details depend on the C runtime environment as well as the calling conventions — one cannot write the code to start a process without understanding the details. For example, on an x86 platform, create arranges for argu-ments to be placed on the runtime stack; on an ARM platform, create places some argu-ments in registers and others on the stack. The code that pushes arguments may be dif-ficult to understand because create copies the arguments directly from its own runtime stack onto the stack that it has allocated for the new process. To do so, it finds the ad-dress of the arguments on its own stack and moves through the list using pointer arith-metic. The following example shows how create forms the stack on an x86 platform.//**ccrreeaattee..cc--ccrreeaattee,,nneewwppiidd**//##iinncclluuddee<<xxiinnuu..hh>>llooccaalliinnttnneewwppiidd(());;//**------------------------------------------------------------------------------------------------------------------------------------------------**ccrreeaattee--CCrreeaatteeaapprroocceessssttoossttaarrttrruunnnniinnggaaffuunnccttiioonnoonnxx8866**------------------------------------------------------------------------------------------------------------------------------------------------**//ppiidd3322ccrreeaattee((vvooiidd**ffuunnccaaddddrr,,//**AAddddrreessssoofftthheeffuunnccttiioonn**//uuiinntt3322ssssiizzee,,//**SSttaacckkssiizzeeiinnwwoorrddss**//pprrii1166pprriioorriittyy,,//**PPrroocceesssspprriioorriittyy>>00**//cchhaarr**nnaammee,,//**NNaammee((ffoorrddeebbuuggggiinngg))**//uuiinntt3322nnaarrggss,,//**NNuummbbeerrooffaarrggsstthhaattffoollllooww**//......)){{uuiinntt3322ssaavvsspp,,**ppuusshhsspp;;iinnttmmaasskkmmaasskk;;//**IInntteerrrruuppttmmaasskk**//ppiidd3322ppiidd;;//**SSttoorreessnneewwpprroocceessssiidd**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPooiinntteerrttoopprroocc..ttaabblleeeennttrryy**//iinntt3322ii;;uuiinntt3322**aa;;//**PPooiinnttssttoolliissttooffaarrggss**//uuiinntt3322**ssaaddddrr;;//**SSttaacckkaaddddrreessss**//mmaasskk==ddiissaabbllee(());;iiff((ssssiizzee<<MMIINNSSTTKK))ssssiizzee==MMIINNSSTTKK;;ssssiizzee==((uuiinntt3322))rroouunnddmmbb((ssssiizzee));;iiff((((pprriioorriittyy<<11))||||((((ppiidd==nneewwppiidd(())))====SSYYSSEERRRR))||||((((ssaaddddrr==((uuiinntt3322**))ggeettssttkk((ssssiizzee))))====((uuiinntt3322**))SSYYSSEERRRR)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}Sec. 6.12        Process Creation 113pprrccoouunntt++++;;pprrppttrr==&&pprrooccttaabb[[ppiidd]];;//**IInniittiiaalliizzeepprroocceessssttaabblleeeennttrryyffoorrnneewwpprroocceessss**//pprrppttrr-->>pprrssttaattee==PPRR__SSUUSSPP;;//**IInniittiiaallssttaatteeiissssuussppeennddeedd**//pprrppttrr-->>pprrpprriioo==pprriioorriittyy;;pprrppttrr-->>pprrssttkkbbaassee==((cchhaarr**))ssaaddddrr;;pprrppttrr-->>pprrssttkklleenn==ssssiizzee;;pprrppttrr-->>pprrnnaammee[[PPNNMMLLEENN--11]]==NNUULLLLCCHH;;ffoorr((ii==00;;ii<<PPNNMMLLEENN--11&&&&((pprrppttrr-->>pprrnnaammee[[ii]]==nnaammee[[ii]]))!!==NNUULLLLCCHH;;ii++++));;pprrppttrr-->>pprrsseemm==--11;;pprrppttrr-->>pprrppaarreenntt==((ppiidd3322))ggeettppiidd(());;pprrppttrr-->>pprrhhaassmmssgg==FFAALLSSEE;;//**SSeettuuppssttddiinn,,ssttddoouutt,,aannddssttddeerrrrddeessccrriippttoorrssffoorrtthheesshheellll**//pprrppttrr-->>pprrddeesscc[[00]]==CCOONNSSOOLLEE;;pprrppttrr-->>pprrddeesscc[[11]]==CCOONNSSOOLLEE;;pprrppttrr-->>pprrddeesscc[[22]]==CCOONNSSOOLLEE;;//**IInniittiiaalliizzeessttaacckkaassiifftthheepprroocceesssswwaassccaalllleedd**//**ssaaddddrr==SSTTAACCKKMMAAGGIICC;;ssaavvsspp==((uuiinntt3322))ssaaddddrr;;//**PPuusshhaarrgguummeennttss**//aa==((uuiinntt3322**))((&&nnaarrggss++11));;//**SSttaarrttooffaarrggss**//aa++==nnaarrggss--11;;//**LLaassttaarrgguummeenntt**//ffoorr((;;nnaarrggss>>00;;nnaarrggss----))//**MMaacchhiinneeddeeppeennddeenntt;;ccooppyyaarrggss**//**----ssaaddddrr==**aa----;;//**oonnttooccrreeaatteeddpprroocceessss’’ssttaacckk**//**----ssaaddddrr==((lloonngg))IINNIITTRREETT;;//**PPuusshhoonnrreettuurrnnaaddddrreessss**////**TThheeffoolllloowwiinnggeennttrriieessoonntthheessttaacckkmmuussttmmaattcchhwwhhaattccttxxssww**////**eexxppeeccttssaassaavveeddpprroocceessssssttaatteettooccoonnttaaiinn::rreettaaddddrreessss,,**////**eebbpp,,iinntteerrrruuppttmmaasskk,,ffllaaggss,,rreeggiisstteerrss,,aannddaannoollddSSPP**//**----ssaaddddrr==((lloonngg))ffuunnccaaddddrr;;//**MMaakkeetthheessttaacckkllooookklliikkeeiitt’’ss**////**hhaallff--wwaayytthhrroouugghhaaccaallllttoo**////**ccttxxsswwtthhaatt""rreettuurrnnss""ttootthhee**////**nneewwpprroocceessss**//**----ssaaddddrr==ssaavvsspp;;//**TThhiisswwiillllbbeerreeggiisstteerreebbpp**////**ffoorrpprroocceesssseexxiitt**//ssaavvsspp==((uuiinntt3322))ssaaddddrr;;//**SSttaarrttooffffrraammeeffoorrccttxxssww**//**----ssaaddddrr==00xx0000000000220000;;//**NNeewwpprroocceessssrruunnsswwiitthh**////**iinntteerrrruuppttsseennaabblleedd**//114 More Process Management Chap. 6//**BBaassiiccaallllyy,,tthheeffoolllloowwiinnggeemmuullaatteessaannxx8866""ppuusshhaall""iinnssttrruuccttiioonn**//**----ssaaddddrr==00;;//**%%eeaaxx**//**----ssaaddddrr==00;;//**%%eeccxx**//**----ssaaddddrr==00;;//**%%eeddxx**//**----ssaaddddrr==00;;//**%%eebbxx**//**----ssaaddddrr==00;;//**%%eesspp;;vvaalluueeffiilllleeddiinnbbeellooww**//ppuusshhsspp==ssaaddddrr;;//**RReemmeemmbbeerrtthhiissllooccaattiioonn**//**----ssaaddddrr==ssaavvsspp;;//**%%eebbpp((wwhhiilleeffiinniisshhiinnggccttxxssww))**//**----ssaaddddrr==00;;//**%%eessii**//**----ssaaddddrr==00;;//**%%eeddii**//**ppuusshhsspp==((uunnssiiggnneeddlloonngg))((pprrppttrr-->>pprrssttkkppttrr==((cchhaarr**))ssaaddddrr));;rreessttoorree((mmaasskk));;rreettuurrnnppiidd;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**nneewwppiidd--OObbttaaiinnaanneeww((ffrreeee))pprroocceessssIIDD**------------------------------------------------------------------------------------------------------------------------------------------------**//llooccaallppiidd3322nneewwppiidd((vvooiidd)){{uuiinntt3322ii;;//**IItteerraatteetthhrroouugghhaallllpprroocceesssseess**//ssttaattiiccppiidd3322nneexxttppiidd==11;;//**PPoossiittiioonniinnttaabblleettoottrryyoorr**////**oonneebbeeyyoonnddeennddooffttaabbllee**////**CChheecckkaallllNNPPRROOCCsslloottss**//ffoorr((ii==00;;ii<<NNPPRROOCC;;ii++++)){{nneexxttppiidd%%==NNPPRROOCC;;//**WWrraappaarroouunnddttoobbeeggiinnnniinngg**//iiff((pprrooccttaabb[[nneexxttppiidd]]..pprrssttaattee====PPRR__FFRREEEE)){{rreettuurrnnnneexxttppiidd++++;;}}eellssee{{nneexxttppiidd++++;;}}}} rreettuurrnn((ppiidd3322))SSYYSSEERRRR;;}}As described above, create arranges for a process to invoke function userret if the process returns from the top-level function. In fact, create stores the address of userretin the stack location where a return address would normally appear (using the symbolic constant INITRET). Placing the address of a function in the return address field is al-lowed because a function return merely jumps to the address. File userret.c contains the code.Sec. 6.12        Process Creation 115//**uusseerrrreett..cc--uusseerrrreett**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**uusseerrrreett--CCaalllleeddwwhheennaapprroocceessssrreettuurrnnssffrroommtthheettoopp--lleevveellffuunnccttiioonn**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiidduusseerrrreett((vvooiidd)){{kkiillll((ggeettppiidd(())));;//**FFoorrcceepprroocceessssttooeexxiitt**//}}Create introduces an initial transition in the state diagram: a newly created processstarts in the suspended state. Figure 6.3 illustrates the augmented state diagram.READYCURRENTreschedreschedSUSPENDEDsuspendresumesuspendcreateFigure 6.3The state diagram showing an initial transition to the suspendedstate.6.13 Other Process Manager FunctionsThree additional system calls help manage processes: getpid, getprio, and chprio. As we have seen, getpid allows the current process to obtain its process ID, and getprio allows a caller to obtain the scheduling priority of an arbitrary process. Another useful system call, chprio, allows a process to change the priority of an arbitrary process. The implementation of each of the three functions appears to be completely straightforward. For example, consider the code for getprio. After checking its argument, getprio ex-116 More Process Management Chap. 6tracts the scheduling priority for the specified process from the process table entry, and returns the priority to the caller.//**ggeettpprriioo..cc--ggeettpprriioo**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettpprriioo--RReettuurrnntthheesscchheedduulliinnggpprriioorriittyyooffaapprroocceessss**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllggeettpprriioo((ppiidd3322ppiidd//**PPrroocceessssIIDD**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//uuiinntt3322pprriioo;;//**PPrriioorriittyyttoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} pprriioo==pprrooccttaabb[[ppiidd]]..pprrpprriioo;;rreessttoorree((mmaasskk));;rreettuurrnnpprriioo;;}}Because global variable currpid contains the ID of the currently executing process,the code for getpid is trivial://**ggeettppiidd..cc--ggeettppiidd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettppiidd--RReettuurrnntthheeIIDDoofftthheeccuurrrreennttllyyeexxeeccuuttiinnggpprroocceessss**------------------------------------------------------------------------------------------------------------------------------------------------**//ppiidd3322ggeettppiidd((vvooiidd)){{rreettuurrnn((ccuurrrrppiidd));;}}Sec. 6.13        Other Process Manager Functions 117Function chprio allows the scheduling priority of any process to be changed. Thecode is found in chprio.c.//**cchhpprriioo..cc--cchhpprriioo**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**cchhpprriioo--CChhaannggeetthheesscchheedduulliinnggpprriioorriittyyooffaapprroocceessss**------------------------------------------------------------------------------------------------------------------------------------------------**//pprrii1166cchhpprriioo((ppiidd3322ppiidd,,//**IIDDooffpprroocceessssttoocchhaannggee**//pprrii1166nneewwpprriioo//**NNeewwpprriioorriittyy**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//pprrii1166oollddpprriioo;;//**PPrriioorriittyyttoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd)))){{rreessttoorree((mmaasskk));;rreettuurrnn((pprrii1166))SSYYSSEERRRR;;}} pprrppttrr==&&pprrooccttaabb[[ppiidd]];;oollddpprriioo==pprrppttrr-->>pprrpprriioo;;pprrppttrr-->>pprrpprriioo==nneewwpprriioo;;rreessttoorree((mmaasskk));;rreettuurrnnoollddpprriioo;;}}The implementation of chprio seems to do exactly what is needed. It checks to be sure the specified process exists before changing the priority field in its process table entry. As the exercises point out, however, the code contains two omissions.6.14 SummaryThe chapter expands the support for concurrent execution by adding a layer of process management software on top of a scheduler and context switch. The new layer includes routines to suspend and resume execution as well as routines that create a new process or kill an existing process. The chapter also examines three additional functions that obtain the ID of the current process (getpid), the scheduling priority of the current118 More Process Management Chap. 6process (getprio), or change the scheduling priority of an arbitrary process (chprio). Despite its brevity, the code built thus far forms the basis of a process manager. With proper initialization and support routines, our basic process manager can multiplex a processor among multiple concurrent computations.Function create forms a new process, and leaves the process in the suspended state. Create allocates a stack for the new process, and places values on the stack and in the process table such that ctxsw can switch to the process and begin execution. The initial values are arranged in a pseudo call, as if the process was called from userret. If the process returns from its top-level function, control passes to userret, which calls kill to terminate the process.EXERCISES6.1 As the text suggests, a process can tell which of several events triggered resumption if itspriority is set to a unique value for each separate call to resume. Use the method to createa process that suspends itself and determines which of two other processes resumes it first.6.2    Suppose a system contains three processes, A, B, and C, with equal priority. If process A isexecuting and suspends C, which process will run? Explain.6.3    Suppose a system contains three processes, A, B, and C, priorities 20, 20, and 10, and proc-ess C has been suspended. If process A is executing and resumes process C, which processwill run? Why?6.4 Why does create build a pseudo-call that returns to userret at process exit instead of onethat calls kill directly?6.5  Global variable prcount tells the number of active user processes. Carefully consider thecode in kill and tell whether the count in prcount includes the null process?6.6 When a process kills itself, kill deallocates the stack and then calls resched, which meansthe process continues to use the deallocated stack. Redesign the system so a current proc-ess does not deallocate its own stack, but instead moves to a new state, PR_DYING. Ar-range for whatever process searches the process table to look for dying processes, free the stack, and move the entry to PR_FREE.6.7  As the text mentions, kill calls xdone before the last process has been terminated. Changethe system so the null process continuously monitors the count of user processes and calls xdone when all processes complete.6.8 In the previous exercise, what restrictions does the new implementation impose on xdonethat were not in the current implementation?6.9    Some hardware architectures use a special instruction to allow an application program to in-voke a system call. Investigate such an architecture, and describe exactly how a systemcall passes to the correct operating system function.6.10  Create leaves the new process suspended instead of running. Why?6.11 Function resume saves the resumed process’s priority in a local variable before callingready. Show that if it references prptr->prprio after the call to ready, resume can return a priority value that the resumed process never had (not even after resumption).Exercises1196.12 In function newpid, variable nextpid is a static integer that tells the next process table slotto check for a free one. Starting the search from where it left off eliminates looking pastthe used slots again and again. Speculate on whether the technique is worthwhile in an em-bedded system.6.13  Function chprio contains two design flaws. The first arises because the code does not en-sure that the new priority value is a positive integer. Describe what can happen if the prior-ity of a process is set to –1.6.14 The second design flaw in chprio violates a fundamental design principle. Identify theflaw, describe its consequences, and repair it.6.15 In addition to the functionality discussed in the chapter, system calls are also responsiblefor enforcing system security policies. Choose an operating system and find out how sys-tem calls enforce security.Chapter Contents7.1 Introduction, 1237.2 The Need For Synchronization, 1237.3 A Conceptual View Of Counting Semaphores, 1257.4 Avoidance Of Busy Waiting, 1257.5 Semaphore Policy And Process Selection, 1267.6 The Waiting State, 1277.7 Semaphore Data Structures, 1287.8 The Wait System Call, 1297.9 The Signal System Call, 1307.10 Static And Dynamic Semaphore Allocation, 1317.11 Example Implementation Of Dynamic Semaphores, 1327.12 Semaphore Deletion, 1337.13 Semaphore Reset, 1357.14 Coordination Across Parallel Processors (Multicore), 1367.15 Perspective, 1377.16 Summary, 1377Coordination Of Concurrent Processes
The future belongs to him who knows how to wait.— Russian Proverb7.1 IntroductionPrevious chapters introduce pieces of a process manager, including scheduling, context switching, and functions that create and terminate processes. This chapter con-tinues the exploration of process management by discussing functions that a set of processes can use to coordinate and synchronize their actions. The chapter explains the motivation for such primitives and their implementation. The chapter also considers coordination of multiple processors, such as those on a multicore chip.The next chapter extends our discussion of a process manager by describing a low-level message passing mechanism. Later chapters show how synchronization func-tions are used to perform I/O.7.2 The Need For SynchronizationBecause they execute concurrently, processes need to cooperate when sharing glo-bal resources. In particular, an operating system designer must ensure that only one process attempts to change a given variable at any time. For example, consider the process table. When a new process is created, a slot in the table must be allocated and123124 Coordination Of Concurrent Processes Chap. 7values inserted. If two processes each attempt to create a new process, the system must guarantee that only one of them can execute create at a given time, or errors can result.The previous chapter illustrates one approach system functions can take to guaran-tee that no other process interferes with them: a function disables interrupts and avoids using any functions that call resched. Indeed, system calls such as suspend, resume, create, and kill each use the approach.Why not use the same solution whenever a process needs to guarantee non-interference? The answer is that disabling interrupts has an undesirable global effect onall parts of the system: it stops all activity except for one process, and limits what the process can do. In particular, no I/O can occur while interrupts are disabled. We will learn later that disabling interrupts too long can cause problems (e.g., if packets contin-ue to arrive over a network while interrupts are disabled, the network interface will start to discard them). Therefore, we need a general-purpose coordination mechanism that permits arbitrary subsets of the processes to coordinate the use of individual data items without disabling device interrupts for long periods of time, without interfering with processes outside the subset, and without limiting what the running process can do. For example, it should be possible for one process to prohibit changes to a large data struc-ture long enough to format and print the data, without stopping processes that do not need to access the data structure. The mechanism should be transparent: a programmer should be able to understand the consequences of process coordination. Thus, further synchronization mechanisms are needed that:Allow a subset of processes to contend for access to a resourceProvide a policy that guarantees fair accessThe first item ensures that coordination is local: instead of disabling all interrupts, only those processes contending for a given resource will block waiting for access. Other parts of the system can continue to operate unaffected. The second item ensuresthat if K processes all attempt to access a given resource, each of the K will eventually receive access (i.e., no process is starved).Chapter 2 introduces the fundamental mechanism that solves the problem: counting semaphores. The chapter also provides examples that show how processes use sema-phores to coordinate. As Chapter 2 indicates, semaphores provide an elegant solution for two problems:Mutual exclusionProducer–consumer interactionMutual exclusion.The term mutual exclusion is used to describe a situation where a set of processes needs to guarantee that only one of them operates at a given time. Mutual exclusion includes access to shared data, but can also include access to an arbi-trary shared resource, such as an I/O device.Sec. 7.2        The Need For Synchronization 125Producer–consumer interaction.We use the term producer–consumer interaction to refer to a situation where processes exchange data items. In the simplest form, one process acts as a producer by generating a sequence of data items, and another process acts as a consumer by accepting the data items. In more complex forms, one or more processes can act as producers and one or more processes can act as consumers. The key to coordinating the interaction is that each item produced must be received by ex-actly one consumer (i.e., no items are lost and no items are duplicated).Both forms of process coordination arise throughout an operating system. For ex-ample, consider a set of applications that are producing messages to be displayed on the console. The console device software must coordinate processes to ensure that charac-ters do not arrive faster than the hardware can display them. Outgoing characters can be placed in a buffer in memory. Once the buffer fills, the producer must be blocked until space becomes available. Similarly, if the buffer becomes empty, the device stops sending characters. The key idea is that a producer must be blocked when the consumer is not ready to receive data, and a consumer must be blocked when a producer is not ready to send data.7.3 A Conceptual View Of Counting SemaphoresA counting semaphore mechanism that solves both problems described above has a surprisingly elegant implementation. Conceptually, a semaphore, s, consists of an in-teger count and a set of blocked processes. Once a semaphore has been created,processes use two functions, wait and signal, to operate on the semaphore. A process calls wait(s) to decrement the count of semaphore s, and signal(s) to increment the count. If the semaphore count becomes negative when a process executes wait(s), the process is temporarily blocked and placed in the semaphore’s set of blocked processes. From the point of view of the process, the call to wait does not return for a while. A blocked process becomes ready to run again when another process calls signal to incre-ment the semaphore count. That is, if any processes are blocked waiting for a sema-phore when signal is called, one of the blocked processes will be made ready and al-lowed to execute. Of course, a programmer must use semaphores with caution: if no process ever signals the semaphore, the blocked processes will wait forever.7.4 Avoidance Of Busy WaitingWhat should a process do while waiting on a semaphore? It might seem that after it decrements the semaphore count, a process could repeatedly test the count until the value becomes positive. On a single processor system, however, such busy waiting is unacceptable because other processes will be deprived of the processor. If no other process receives processor service, no process can call signal to terminate the wait. Therefore, operating systems avoid busy waiting. Instead, semaphore implementations follow an important principle:126 Coordination Of Concurrent Processes Chap. 7While a process waits on a semaphore, the process does not execute instructions.7.5 Semaphore Policy And Process SelectionTo implement semaphores without busy waiting, an operating system associates a process list with each semaphore. Only the current process can choose to wait on a semaphore. When a process waits on semaphore s, the system decrements the count as-sociated with s. If the count becomes negative, the process must be blocked. To block a process, the system places the process on the list associated with the semaphore, changes the state so the process is no longer current, and calls resched to allow other processes to run.Later, when signal is called on semaphore s, the semaphore count is incremented.In addition, the signal examines the process list associated with s. If the list is not emp-ty (i.e., at least one process is waiting on the semaphore), signal extracts a process fromthe list and moves the process back to the ready list.A question arises: if multiple processes are waiting, which one should signalselect? Several policies have been used:Highest scheduling priorityFirst-come-first-served (longest waiting time)RandomAlthough it may seem reasonable, selecting the highest priority waiting process violates the principle of fairness. To see why, consider a set of low-priority and high-priority processes that are using a mutual exclusion semaphore. Suppose each process repeatedly waits on the semaphore, uses the resource, and signals the semaphore. If the semaphore system always selects a high-priority process and the scheduling policy al-ways gives the processor to high-priority processes, the low-priority processes can be blocked forever while high-priority processes continue to gain access.To avoid unfairness, many implementations choose a first-come-first-served policy:if processes are waiting, the system always chooses the process that has been waitingthe longest. The implementation of a first-come-first-served policy is both elegant and efficient: the system creates a FIFO queue for each semaphore, and uses the queue to store processes that are waiting. When it needs to block a process, wait inserts the process at the tail; when it needs to unblock a process, signal extracts a process from the head.A first-come-first-served policy can lead to a priority inversion in the sense that a high-priority process can be blocked on a semaphore while a low-priority process exe-cutes. In addition, it can lead to a synchronization problem discussed in an exercise. One alternative consists of choosing among waiting processes at random. The chief disadvantage of random selection lies in computational overhead (e.g., random number generation).Sec. 7.5        Semaphore Policy And Process Selection 127After considering the advantages and disadvantages of various schemes, we chosea first-come-first-served policy for Xinu:Xinu semaphore process selection policy: if one or more processes are waiting for semaphore s when a signal operation occurs for s, the process that has been waiting the longest becomes ready.7.6 The Waiting StateIn what state should a process be placed while it is waiting for a semaphore? Be-cause it is neither using the processor nor eligible to run, the process is neither current nor ready. The suspended state, introduced in the previous chapter cannot be used be-cause functions suspend and resume, which move processes in and out of the suspended state, have no connection with semaphores. More important, processes waiting for semaphores appear on a list, but suspended processes do not — kill must distinguish the two cases when terminating a process. Because existing states do not adequately en-compass processes waiting on a semaphore, a new state must be invented. We call the new state waiting, and use symbolic constant PR_WAIT in the code. Figure 7.1 shows the expanded state transition diagram.
READYCURRENTreschedreschedSUSPENDEDsuspendresumesuspendcreateWAITINGwaitsignal
Figure 7.1  State transitions including the waiting state.128 Coordination Of Concurrent Processes Chap. 77.7 Semaphore Data StructuresThe example system stores semaphore information in a global semaphore table, semtab. Each entry in semtab corresponds to one semaphore. An entry contains an in-teger count for the semaphore, and the ID of a queue that can be used to hold waiting processes. The definition of an entry is given by structure sentry. File semaphore.h contains the details.//**sseemmaapphhoorree..hh--iissbbaaddsseemm**//##iiffnnddeeffNNSSEEMM##ddeeffiinneeNNSSEEMM112200//**NNuummbbeerrooffsseemmaapphhoorreess,,iiffnnoottddeeffiinneedd**//##eennddiiff//**SSeemmaapphhoorreessttaatteeddeeffiinniittiioonnss**//##ddeeffiinneeSS__FFRREEEE00//**SSeemmaapphhoorreettaabblleeeennttrryyiissaavvaaiillaabbllee**//##ddeeffiinneeSS__UUSSEEDD11//**SSeemmaapphhoorreettaabblleeeennttrryyiissiinnuussee**////**SSeemmaapphhoorreettaabblleeeennttrryy**//ssttrruuccttsseennttrryy{{bbyytteessssttaattee;;//**WWhheetthheerreennttrryyiissSS__FFRREEEEoorrSS__UUSSEEDD**//iinntt3322ssccoouunntt;;//**CCoouunnttffoorrtthheesseemmaapphhoorree**//qqiidd1166ssqquueeuuee;;//**QQuueeuueeooffpprroocceesssseesstthhaattaarreewwaaiittiinngg**////**oonntthheesseemmaapphhoorree**//}};;eexxtteerrnnssttrruuccttsseennttrryysseemmttaabb[[]];;##ddeeffiinneeiissbbaaddsseemm((ss))((((iinntt3322))((ss))<<00||||((ss))>>==NNSSEEMM))In structure sentry, field scount contains the current integer count of the sema-phore. The list of processes waiting for a semaphore resides in the queue structure, and field squeue gives the index of the head of the list for a given semaphore. The state field, sstate, tells whether the entry is currently used (i.e., allocated) or free (currently unallocated).Throughout the system, semaphores are identified by an integer ID. As with other identification values, semaphore IDs are assigned to make lookup efficient: the sema-phore table is an array, and each ID is an index in the array. To summarize:A semaphore is identified by its index in the global semaphore table, semtab.Sec. 7.7        Semaphore Data Structures 1297.8 The Wait System CallRecall that the two primary operations on a semaphore are wait and signal.  Wait decrements the count of a semaphore. If the count remains nonnegative, wait returns tothe caller immediately. In essence, a process executing wait on a semaphore with a nonpositive count voluntarily gives up control of the processor. That is, wait enqueues the calling process on the list for the semaphore, changes the process state to PR_WAIT, and calls resched to switch to a ready process. Also recall that our policy maintains the list of processes as a FIFO queue, which means a new process is inserted at the tail of a list. File wait.c contains the code.//**wwaaiitt..cc--wwaaiitt**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**wwaaiitt--CCaauusseeccuurrrreennttpprroocceessssttoowwaaiittoonnaasseemmaapphhoorree**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllwwaaiitt((ssiidd3322sseemm//**SSeemmaapphhoorreeoonnwwhhiicchhttoowwaaiitt**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//ssttrruuccttsseennttrryy**sseemmppttrr;;//**PPttrrttoosseemmppaahhoorreettaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddsseemm((sseemm)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} sseemmppttrr==&&sseemmttaabb[[sseemm]];;iiff((sseemmppttrr-->>ssssttaattee====SS__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} iiff((----((sseemmppttrr-->>ssccoouunntt))<<00)){{//**IIffccaalllleerrmmuussttbblloocckk**//pprrppttrr==&&pprrooccttaabb[[ccuurrrrppiidd]];;pprrppttrr-->>pprrssttaattee==PPRR__WWAAIITT;;//**SSeettssttaatteettoowwaaiittiinngg**//pprrppttrr-->>pprrsseemm==sseemm;;//**RReeccoorrddsseemmaapphhoorreeIIDD**//eennqquueeuuee((ccuurrrrppiidd,,sseemmppttrr-->>ssqquueeuuee));;//**EEnnqquueeuueeoonnsseemmaapphhoorree**//rreesscchheedd(());;//**aannddrreesscchheedduullee**//}}130 Coordination Of Concurrent Processes Chap. 7rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Once enqueued on a semaphore list, a process remains in the waiting state (i.e., not eligible to execute) until the process reaches the head of the queue and some other proc-ess signals the semaphore. When the call to signal moves a waiting process back to the ready list, the process becomes eligible to use the processor, and eventually resumes ex-ecution. From the point of view of the waiting process, its last act consisted of a call to ctxsw. When the process restarts, the call to ctxsw returns to resched, the call to resched returns to wait, and the call to wait returns to the location from which it was called.7.9 The Signal System CallFunction signal takes a semaphore ID as an argument, increments the count of the specified semaphore, and makes the first process ready, if any are waiting. Although it may seem difficult to understand why signal makes a process ready even though the semaphore count remains negative or why wait does not always enqueue the calling process, the reason is both easy to understand and easy to implement.  Wait and signal maintain the following invariant regarding the count of a semaphore:Semaphore invariant: a nonnegative semaphore count means that the queue is empty; a semaphore count of negative N means that the queue contains N waiting processes.In essence, a count of positive N means that wait can be called N more times be-fore any process blocks. Because wait and signal each change the semaphore count,they must each adjust the queue length to reestablish the invariant. When it decrements the count, wait examines the result, and adds the current process to the queue if the new count is negative. Because it increments the count, signal examines the queue and re-moves a process from the queue if the queue is nonempty.//**ssiiggnnaall..cc--ssiiggnnaall**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ssiiggnnaall--SSiiggnnaallaasseemmaapphhoorree,,rreelleeaassiinnggaapprroocceessssiiffoonneeiisswwaaiittiinngg**------------------------------------------------------------------------------------------------------------------------------------------------**//Sec. 7.9        The Signal System Call 131ssyyssccaallllssiiggnnaall((ssiidd3322sseemm//**IIDDooffsseemmaapphhoorreettoossiiggnnaall**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttsseennttrryy**sseemmppttrr;;//**PPttrrttoosseemmppaahhoorreettaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddsseemm((sseemm)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} sseemmppttrr==&&sseemmttaabb[[sseemm]];;iiff((sseemmppttrr-->>ssssttaattee====SS__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} iiff((((sseemmppttrr-->>ssccoouunntt++++))<<00)){{//**RReelleeaasseeaawwaaiittiinnggpprroocceessss**//rreeaaddyy((ddeeqquueeuuee((sseemmppttrr-->>ssqquueeuuee))));;}} rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}7.10 Static And Dynamic Semaphore AllocationAn operating system designer must choose between two approaches for semaphoreallocation:Static allocation: a programmer defines a fixed set of semaphoresat compile time; the set does not change as the system runs.Dynamic allocation: the system includes functions that allow sema-phores to be created on demand and deallocated when they are no longer needed.The advantage of static allocation lies in saving space and reducing processing overhead — the system only contains memory for the needed semaphores, and the sys-tem does not require functions to allocate or deallocate semaphores. Thus, the smallest embedded systems use static allocation.The chief advantage of dynamic allocation arises from the ability to accommodate new uses at runtime. For example, a dynamic allocation scheme allows a user to launch an application that allocates a semaphore, terminate the application, and then launch another application. Thus, larger embedded systems and most large operating systems provide dynamic allocation of resources, including semaphores. The next sections show that dynamic allocation does not introduce much additional code.132 Coordination Of Concurrent Processes Chap. 77.11 Example Implementation Of Dynamic SemaphoresXinu provides a limited form of dynamic allocation: processes can create sema-phores dynamically, and a given process can create multiple semaphores, provided the total number of semaphores allocated simultaneously does not exceed a predefined max-imum. Furthermore, to minimize the allocation overhead, the system preallocates a list in the queue structure for each semaphore when the operating system boots. Thus, only a small amount of work needs be done when a process creates a semaphore.Two system calls, semcreate and semdelete, handle dynamic semaphore allocationand deallocation. Semcreate takes an initial semaphore count as an argument, allocatesa semaphore, assigns the semaphore the specified count, and returns the semaphore ID.To preserve the semaphore invariant, the initial count must be nonnegative. Therefore, semcreate begins by testing its argument. If the argument is valid, semcreate searches the semaphore table, semtab, for an unused entry and initializes the count. To search the table, semcreate calls function newsem, which iterates through all NSEM entries of the table. If no free entry is found, newsem returns SYSERR. Otherwise, newsem changes the state of the entry to S_USED, and returns the table index as the ID.Once a table entry has been allocated, semcreate only needs to initialize the count and return the index of the semaphore to its caller; the head and tail of a queue used to store waiting processes have been allocated when the operating system boots. File semcreate.c contains the code for function newsem as well as function semcreate. Note the use of a static index variable nextsem to optimize searching (i.e., allow a search to start where the last search left off).//**sseemmccrreeaattee..cc--sseemmccrreeaattee,,nneewwsseemm**//##iinncclluuddee<<xxiinnuu..hh>>llooccaallssiidd3322nneewwsseemm((vvooiidd));;//**------------------------------------------------------------------------------------------------------------------------------------------------**sseemmccrreeaattee--CCrreeaatteeaanneewwsseemmaapphhoorreeaannddrreettuurrnntthheeIIDDttootthheeccaalllleerr**------------------------------------------------------------------------------------------------------------------------------------------------**//ssiidd3322sseemmccrreeaattee((iinntt3322ccoouunntt//**IInniittiiaallsseemmaapphhoorreeccoouunntt**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssiidd3322sseemm;;//**SSeemmaapphhoorreeIIDDttoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;iiff((ccoouunntt<<00||||((((sseemm==nneewwsseemm(())))====SSYYSSEERRRR)))){{Sec. 7.11        Example Implementation Of Dynamic Semaphores 133rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} sseemmttaabb[[sseemm]]..ssccoouunntt==ccoouunntt;;//**IInniittiiaalliizzeettaabblleeeennttrryy**//rreessttoorree((mmaasskk));;rreettuurrnnsseemm;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**nneewwsseemm--AAllllooccaatteeaannuunnuusseeddsseemmaapphhoorreeaannddrreettuurrnniittssiinnddeexx**------------------------------------------------------------------------------------------------------------------------------------------------**//llooccaallssiidd3322nneewwsseemm((vvooiidd)){{ssttaattiiccssiidd3322nneexxttsseemm==00;;//**NNeexxttsseemmaapphhoorreeiinnddeexxttoottrryy**//ssiidd3322sseemm;;//**SSeemmaapphhoorreeIIDDttoorreettuurrnn**//iinntt3322ii;;//**IItteerraatteetthhrroouugghh##eennttrriieess**//ffoorr((ii==00;;ii<<NNSSEEMM;;ii++++)){{sseemm==nneexxttsseemm++++;;iiff((nneexxttsseemm>>==NNSSEEMM))nneexxttsseemm==00;;iiff((sseemmttaabb[[sseemm]]..ssssttaattee====SS__FFRREEEE)){{sseemmttaabb[[sseemm]]..ssssttaattee==SS__UUSSEEDD;;rreettuurrnnsseemm;;}}}} rreettuurrnnSSYYSSEERRRR;;}}7.12 Semaphore DeletionFunction semdelete reverses the actions of semcreate.  Semdelete takes the ID of a semaphore as an argument and releases the semaphore table entry for subsequent use. Deallocating a semaphore requires three steps. First, semdelete verifies that the argu-ment specifies a valid semaphore ID and that the corresponding entry in the semaphore table is currently in use. Second, semdelete sets the state of the entry to S_FREE to in-dicate that the table entry can be reused. Finally, semdelete iterates through the set of processes that are waiting on the semaphore and makes each process ready. File semdelete.c contains the code.134 Coordination Of Concurrent Processes Chap. 7//**sseemmddeelleettee..cc--sseemmddeelleettee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**sseemmddeelleettee--DDeelleetteeaasseemmaapphhoorreebbyyrreelleeaassiinnggiittssttaabblleeeennttrryy**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllsseemmddeelleettee((ssiidd3322sseemm//**IIDDooffsseemmaapphhoorreettooddeelleettee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttsseennttrryy**sseemmppttrr;;//**PPttrrttoosseemmaapphhoorreettaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddsseemm((sseemm)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} sseemmppttrr==&&sseemmttaabb[[sseemm]];;iiff((sseemmppttrr-->>ssssttaattee====SS__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} sseemmppttrr-->>ssssttaattee==SS__FFRREEEE;;rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;wwhhiillee((sseemmppttrr-->>ssccoouunntt++++<<00)){{//**FFrreeeeaallllwwaaiittiinnggpprroocceesssseess**//rreeaaddyy((ggeettffiirrsstt((sseemmppttrr-->>ssqquueeuuee))));;}} rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}If processes remain enqueued on a semaphore when the semaphore is deallocated, an operating system must handle each of the processes. In the example implementation, semdelete places each waiting process back on the ready list, allowing the process to resume execution as if the semaphore had been signaled. The example only represents one strategy, and other strategies are possible. For example, some operating systems consider it an error to attempt to deallocate a semaphore on which processes are wait-ing. The exercises suggest exploring alternatives.Sec. 7.12        Semaphore Deletion 135Note that the code to make processes ready uses deferred rescheduling. That is, semdelete calls resched_cntl to start deferral before making processes ready, and only calls resched_cntl to end the deferral period after all waiting processes have been moved to the ready list. The second call will invoke resched to reestablish the schedul-ing invariant.7.13 Semaphore ResetIt is sometimes convenient to reset the count of a semaphore without incurring the overhead of deleting an existing semaphore and creating a new one. The system call semreset, shown in file semreset.c below, resets the count of a semaphore.//**sseemmrreesseett..cc--sseemmrreesseett**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**sseemmrreesseett--RReesseettaasseemmaapphhoorree’’ssccoouunnttaannddrreelleeaasseewwaaiittiinnggpprroocceesssseess**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllsseemmrreesseett((ssiidd3322sseemm,,//**IIDDooffsseemmaapphhoorreettoorreesseett**//iinntt3322ccoouunntt//**NNeewwccoouunntt((mmuussttbbee>>==00))**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttsseennttrryy**sseemmppttrr;;//**PPttrrttoosseemmaapphhoorreettaabblleeeennttrryy**//qqiidd1166sseemmqquueeuuee;;//**SSeemmaapphhoorree’’sspprroocceessssqquueeuueeIIDD**//ppiidd3322ppiidd;;//**IIDDooffaawwaaiittiinnggpprroocceessss**//mmaasskk==ddiissaabbllee(());;iiff((ccoouunntt<<00||||iissbbaaddsseemm((sseemm))||||sseemmttaabb[[sseemm]]..ssssttaattee====SS__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} sseemmppttrr==&&sseemmttaabb[[sseemm]];;sseemmqquueeuuee==sseemmppttrr-->>ssqquueeuuee;;//**FFrreeeeaannyywwaaiittiinnggpprroocceesssseess**//rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;wwhhiillee((((ppiidd==ggeettffiirrsstt((sseemmqquueeuuee))))!!==EEMMPPTTYY))rreeaaddyy((ppiidd));;sseemmppttrr-->>ssccoouunntt==ccoouunntt;;//**RReesseettccoouunnttaassssppeecciiffiieedd**//136 Coordination Of Concurrent Processes Chap. 7rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Semreset must preserve the semaphore invariant. Rather than build a general-purpose solution that allows a caller to specify an arbitrary semaphore count, our imple-mentation takes a simplified approach by requiring the new count to be nonnegative. As a result, once the semaphore count has been changed, the queue of waiting processes will be empty. As with semdelete, semreset must be sure that no processes are already waiting on the semaphore. Thus, after checking its arguments and verifying that the semaphore exists, semreset iterates through the list of waiting processes, removing each from the semaphore queue and making the process ready to execute. As expected, sem-reset uses resched_cntl to defer rescheduling during the time processes are placed on the ready list.7.14 Coordination Across Parallel Processors (Multicore)The semaphore system described above works well on a computer that has a single processor core. However, many modern processor chips include multiple cores. Onecore is usually dedicated to run operating system functions, and other cores are used to execute user applications. On such systems, using semaphores supplied by the operat-ing system to coordinate processes can be inefficient. To see why, consider what hap-pens when an application running on core 2 needs exclusive access to a specific memory location. The application process calls wait, which must pass the request to the operating system on core 1. Communication among cores often involves raising an in-terrupt. Furthermore, while it runs an operating system function, core 1 disables inter-rupts, which defeats one of the reasons to use semaphores.Some multiprocessor systems supply hardware primitives, known as spin locks, that allow multiple processors to contend for mutually exclusive access. The hardware defines a set of K spin locks (K might be less than 1024). Conceptually, each of the spin locks is a single bit, and the spin locks are initialized to zero. The instruction set includes a special instruction, called a test-and-set, that a core can use to coordinate. A test-and-set performs two operations atomically: it sets a spin lock to 1 and returns the value of the spin lock before the operation. The hardware guarantees atomicity, which means that if two or more processors attempt to set a given spin lock simultaneously, one of them will receive 0 as the previous value and the others will receive 1. Once it finishes using the locked item, the core that obtained the lock resets the value to 0, al-lowing another core to obtain the lock.To see how spin locks work, suppose two cores need exclusive access to a shared data item and are using spin lock 5. When a core wants to obtain mutually exclusive access, the core executes a loop:††Because it uses hardware instructions, test-and-set code is usually written in assembly language; it isshown in pseudo code for clarity.Sec. 7.14        Coordination Across Parallel Processors (Multicore) 137wwhhiillee((tteesstt__aanndd__sseett((55)))){{;;}}The loop repeatedly uses the test-and-set instruction to set spin lock 5. If the lock wasset before the instruction executed, the instruction will return 1, and the loop will con-tinue. If the lock was not set before the instruction executed, the hardware will return 0, and the loop terminates. If multiple processors are all trying to set spin lock 5 at the same time, the hardware guarantees that only one will be granted access. Thus, test_and_set is analogous to wait.Once a core finishes using the shared data, the core executes an instruction thatclears the spin lock:cclleeaarr((55));;On multicore machines, vendors include various instructions that can be used as aspin lock. For example, in addition to test-and-set, Intel multicore processors providean atomic compare-and-swap instruction. If multiple cores attempt to execute acompare-and-swap instruction at the same time, one of them will succeed and the others will all find that the comparison fails. A programmer can use such instructions to build the equivalent of a spin lock.It may seem that a spin lock is wasteful because a processor merely blocks (i.e., busy waits) in a loop until access is granted. However, if the probability of two proces-sors contending for access is low, a spin lock mechanism is much more efficient than a system call (e.g., waiting on a semaphore). Therefore, a programmer must be careful in choosing when to use spin locks and when to use system calls.7.15 PerspectiveThe counting semaphore abstraction is significant for two reasons. First, it pro-vides a powerful mechanism that can be used to control both mutual exclusion and producer–consumer synchronization, the two primary process coordination paradigms. Second, the implementation is surprisingly compact and extremely efficient. To appre-ciate the small size, reconsider functions wait and signal. If the code to test arguments and returns results is removed, only a few lines of code remain. As we examine the im-plementation of other abstractions, the point will become more significant: despite their importance, only a trivial amount of code is needed to implement counting semaphores.7.16 SummaryInstead of disabling interrupts, which stops all activities other than the current process, operating systems offer synchronization primitives that allow subsets of processes to coordinate without affecting other processes. A fundamental coordination mechanism, known as a counting semaphore, allows processes to coordinate without us-138 Coordination Of Concurrent Processes Chap. 7ing busy-waiting. Each semaphore consists of an integer count plus a queue ofprocesses. The semaphore adheres to an invariant that specifies a count of negative N means the queue contains N processes.The two fundamental primitives, signal and wait, permit a caller to increment or decrement the semaphore count. If a call to wait makes the semaphore count negative,the calling process is placed in the waiting state and the processor passes to another process. In essence, a process that waits for a semaphore voluntarily enqueues itself on the list of processes waiting for the semaphore, and calls resched to allow other processes to execute.Either static or dynamic allocation can be used with semaphores. The example code includes functions semcreate and semdelete to permit dynamic allocation. If a semaphore is deallocated while processes are waiting, the processes must be handled. The example code makes the processes ready as if the semaphore had been signaled.Multiprocessors can use a mutual exclusion mechanism known as spin locks. Although spin locks seem inefficient because they require a processor to repeatedly test for access, they can be more efficient than an arrangement where one processor inter-rupts another to place a system call.EXERCISES7.1   The text notes that some operating systems consider semaphore deletion to be in error ifprocesses remain enqueued waiting for the semaphore. Rewrite semdelete to returnSYSERR for a busy semaphore.7.2 As an alternative to the semaphore deletion mechanism illustrated in the chapter, considerusing deferred deletion. That is, rewrite semdelete to place a deleted semaphore in a de-ferred state until all processes have been signaled. Modify signal to release the semaphore table entry when the last waiting process has been removed from the queue.7.3  In the previous exercise, can deferred deletion have unexpected side effects? Explain.7.4 As a further alternative to the deferred deletion of an active semaphore, modify wait to re-turn a value DELETED if the semaphore was deleted while the calling process was waiting. (Choose a value for DELETED that differs from SYSERR and OK.) How can a process determine whether the semaphore on which it was waiting has been deleted? Be careful: remember that a high-priority process can execute at any time. Thus, after a low-priority process becomes ready, a higher-priority process can obtain the processor and create a new semaphore that reuses the semaphore table entry before the low-priority process completes execution of wait. Hint: consider adding a sequence field to the semaphore table entry.7.5 Instead of allocating a central semaphore table, arrange to have each process allocate spacefor semaphore entries as needed, and use the address of an entry as the semaphore ID. Compare the approach to the centralized table in the example code. What are the advan-tages and disadvantages of each?7.6 Wait, signal, semcreate, and semdelete coordinate among themselves for use of the sema-phore table. Is it possible to use a semaphore to protect use of the semaphore table? Ex-plain.Exercises1397.7 Consider a possible optimization: instead of using ready, arrange for semdelete to examinethe priority of each waiting process before the process is placed on the ready list. If noneof the processes has higher priority than the current process, do not reschedule, but if anyof them has a higher priority, call resched. What is the cost of the optimization and what is the potential savings?7.8  Construct a new system call, signaln(sem, n) that signals semaphore sem n times. Can youfind an implementation that is more efficient than n calls to signal? Explain.7.9  The example code uses a FIFO policy for semaphores. That is, when a semaphore is sig-naled, the process that has been waiting the longest becomes ready. Imagine a modificationin which the processes waiting for a semaphore are kept on a priority queue ordered by process priority (i.e., when a semaphore is signaled, the highest priority waiting process be-comes ready). What is the chief disadvantage of a priority approach?7.10  Languages meant specifically for writing concurrent programs often have coordination andsynchronization embedded in the language constructs directly. For example, it might be possible to declare functions in groups such that the compiler automatically inserts code to prohibit more than one process from executing a given group at a given time. Find an ex-ample of a language designed for concurrent programming, and compare process coordina-tion with the semaphores in the Xinu code.7.11 When a programmer is required to manipulate semaphores explicitly, what types of mis-takes can a programmer make?7.12 When it moves a waiting process to the ready state, wait sets field prsem in the processtable entry to the ID of the semaphore on which the process is waiting. Will the value everbe used?7.13 If a programmer makes a mistake, it is more likely that the error will produce 0 or 1 thanan arbitrary integer. To help prevent errors, change newsem to begin allocating semaphores from the high end of the table, leaving slots 0 and 1 unused until all other entries have been exhausted. Suggest better ways of identifying semaphores that increase the ability to detect errors.7.14  Function semdelete behaves in an unexpected way when deleting a semaphore with a non-negative count. Identify the behavior and rewrite the code to correct it.7.15 Draw a call graph of all operating system functions from Chapters 4 through 7, showingwhich functions a given function invokes. Can a multi-level structure be deduced from the graph? Explain.Chapter Contents8.1 Introduction, 1438.2 Two Types Of Message Passing Services, 1438.3 Limits On Resources Used By Messages, 1448.4 Message Passing Functions And State Transitions, 1458.5 Implementation Of Send, 1468.6 Implementation Of Receive, 1488.7 Implementation Of Non-Blocking Message Reception, 1498.8 Perspective, 1498.9 Summary, 1508Message Passing
The message of history is clear: the past lies before us.— Anonymous8.1 IntroductionPrevious chapters explain the basic components of a process manager, including: scheduling, context switching, and counting semaphores that provide coordination among concurrent processes. The chapters show how processes are created and howthey terminate, and explain how an operating system keeps information about each process in a central table.This chapter concludes our examination of basic process management facilities. The chapter introduces the concept of message passing, describes possible approaches, and shows an example of a low-level message passing system. Chapter 11 explains how a high-level message passing facility can be built using the basic process manage-ment mechanisms.8.2 Two Types Of Message Passing ServicesWe use the term message passing to refer to a form of inter-process communica-tion in which one process transfers (usually a small amount of) data to another. Insome systems, processes deposit and retrieve messages from named pickup points thatare sometimes called mailboxes. In other systems, a message must be addressed direct-ly to a process. Message passing is both convenient and powerful, and some operating systems use it as the basis for all communication and coordination among processes.143144 Message Passing Chap. 8For example, an operation such as transmitting data across a computer network can be implemented using message passing primitives.Some message passing facilities provide process coordination because the mecha-nism delays a receiver until a message arrives. Thus, message passing can replace proc-ess suspension and resumption. Can message passing also replace synchronization primitives such as semaphores? The answer depends on the implementation of message passing. There are two types:Synchronous. If a receiver attempts to receive a message beforethe message has arrived, the receiver blocks; if a sender tries tosend a message before a receiver is ready, the sender blocks. Send-ing and receiving processes must coordinate or one can become blocked waiting for the other.Asynchronous.  A message can arrive at any time, and a receiver isnotified. A receiver does not need to know in advance how many messages will arrive or how many senders will send messages.Although it may lack generality and convenience, a synchronous message passing facility can serve in place of a semaphore mechanism. For example, consider aproducer–consumer paradigm. Each time it generates new data, a producer process can send a message to the consumer process. Similarly, instead of waiting on a semaphore, the consumer can wait for a message. Using message passing to implement mutual ex-clusion is more complex, but usually possible.The chief advantage of a synchronous message passing system arises because it fits well with a traditional computational paradigm. To receive a message in a synchronous system, a process calls a system function, and the call does not return until a message arrives. In contrast, an asynchronous message passing system either requires a process to poll (i.e., check for a message periodically) or requires a mechanism that allows the operating system to stop a process temporarily, allows the process to handle a message, and then resumes normal execution. Although it introduces additional overhead or complexity, asynchronous message passing can be convenient if a process does not know how many messages it will receive, when the messages will be sent, or which processes will send messages.8.3 Limits On Resources Used By MessagesXinu supports two forms of message passing that illustrate a completely synchro-nous paradigm and a partially asynchronous paradigm. The two facilities also illustratethe difference between direct and indirect message delivery: one provides a direct ex-change of messages among processes, and the other arranges for messages to be ex-changed through rendezvous points. This chapter begins the discussion by examining a facility that provides direct communication from one process to another. Chapter 11 discusses a second message passing facility. Separating message passing into two in-Sec. 8.3        Limits On Resources Used By Messages 145dependent pieces has the advantage of making low-level message passing among processes efficient, while allowing a programmer to choose a more complex rendezvous approach when needed.The Xinu process-to-process message passing system has been designed carefullyto ensure that a process does not block while sending a message, and waiting messagesdo not consume all of memory. To make such guarantees, the message passing facility follows three guidelines:Limited message size. The system limits each message to a small,fixed size. In our example code, each message consists of a single word (i.e., an integer or a pointer).No message queues. The system permits a given process to storeonly one unreceived message per process at any time. There are no message queues.First message semantics. If several messages are sent to a givenprocess before the process receives any of them, only the first mes-sage is stored and delivered; subsequent senders do not block.The concept of first message semantics makes the mechanism useful for determin-ing which of several events completes first. A process that needs to wait for events can arrange for each event to send a unique message. The process then waits for a message, and the operating system guarantees that the process will receive the first message that is sent.8.4 Message Passing Functions And State TransitionsThree system calls manipulate messages: send, receive, and recvclr.  Send takes a message and a process ID as arguments, and delivers the message to the specified proc-ess. Receive, which does not require arguments, causes the current process to wait until a message arrives, and then returns the message to its caller.  Recvclr provides a non-blocking version of receive. If the current process has received a message when recvclr is called, the call returns the message exactly like receive. If no message is waiting, however, recvclr returns the value OK to its caller immediately, without delaying to wait for a message to arrive. As the name implies, recvclr can be used to remove an old message before engaging in a round of message passing.The question arises: in what state should a process be while waiting for a message? Because waiting for a message differs from being ready to execute, waiting for a sema-phore, waiting for the processor, suspended animation, or current execution, none of the existing states suffices. Thus, another state must be added to our design. The new state, receiving, is denoted in the example software with the symbolic constant PR_RECV. Adding the state produces the transition diagram illustrated in Figure 8.1.146 Message Passing Chap. 8
READYCURRENTreschedreschedSUSPENDEDsuspendresumesuspendcreateWAITINGwaitsignalRECEIVINGreceivesend
Figure 8.1  Illustration of state transitions including the receiving state.8.5 Implementation Of SendA message passing system requires agreement between senders and receivers be-cause a sender must store a message in a location from which the receiver can extractthe message. A message cannot be stored in the sender’s memory because a sending process can exit before the message is received. Most operating systems do not permit a sender to place a message in a receiver’s address space because allowing a process to write into the memory allocated to another process poses a security threat. In our ex-ample system, restrictions on the size of messages eliminate the problem. Our imple-mentation reserves space for one message in field prmsg of the recipient’s process table entry.To deposit a message, function send first checks that the specified recipient process exists. It then checks to ensure the recipient does not have a message outstanding. To do so, send examines field prhasmsg in the recipient’s process table entry. If the reci-pient has no outstanding message, send deposits the new message in the prmsg field and sets prhasmsg to TRUE to indicate that a message is waiting. As a final step, if the re-cipient is waiting for the arrival of a message (i.e., the recipient process has state PR_RECV or state PR_RECTIM), send calls ready to make the process ready and re-Sec. 8.5        Implementation Of Send 147establish the scheduling invariant. In the case of PR_RECTIM, which is discussed laterin the text, send must first call unsleep to remove the process from the queue of sleep-ing processes. File send.c contains the code.//**sseenndd..cc--sseenndd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**sseenndd--PPaassssaammeessssaaggeettooaapprroocceessssaannddssttaarrttrreecciippiieennttiiffwwaaiittiinngg**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllsseenndd((ppiidd3322ppiidd,,//**IIDDooffrreecciippiieennttpprroocceessss**//uummssgg3322mmssgg//**CCoonntteennttssooffmmeessssaaggee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} pprrppttrr==&&pprrooccttaabb[[ppiidd]];;iiff((((pprrppttrr-->>pprrssttaattee====PPRR__FFRREEEE))||||pprrppttrr-->>pprrhhaassmmssgg)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} pprrppttrr-->>pprrmmssgg==mmssgg;;//**DDeelliivveerrmmeessssaaggee**//pprrppttrr-->>pprrhhaassmmssgg==TTRRUUEE;;//**IInnddiiccaatteemmeessssaaggeeiisswwaaiittiinngg**////**IIffrreecciippiieennttwwaaiittiinnggoorriinnttiimmeedd--wwaaiittmmaakkeeiittrreeaaddyy**//iiff((pprrppttrr-->>pprrssttaattee====PPRR__RREECCVV)){{rreeaaddyy((ppiidd));;}}eellsseeiiff((pprrppttrr-->>pprrssttaattee====PPRR__RREECCTTIIMM)){{uunnsslleeeepp((ppiidd));;rreeaaddyy((ppiidd));;}} rreessttoorree((mmaasskk));;//**RReessttoorreeiinntteerrrruuppttss**//rreettuurrnnOOKK;;}}148 Message Passing Chap. 88.6 Implementation Of ReceiveA process calls receive (or recvclr) to obtain an incoming message. Receive exam-ines the process table entry for the current process, and uses the prhasmsg field to deter-mine whether a message is waiting. If no message has arrived, receive changes the process state to PR_RECV, and calls resched, to allow other processes to run. When another process sends the receiving process a message, the call to resched returns. Once execution passes the if statement, receive extracts the message, sets prhasmsg to FALSE, and returns the message to its caller. File receive.c contains the code://**rreecceeiivvee..cc--rreecceeiivvee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rreecceeiivvee--WWaaiittffoorraammeessssaaggeeaannddrreettuurrnntthheemmeessssaaggeettootthheeccaalllleerr**------------------------------------------------------------------------------------------------------------------------------------------------**//uummssgg3322rreecceeiivvee((vvooiidd)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//uummssgg3322mmssgg;;//**MMeessssaaggeettoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;pprrppttrr==&&pprrooccttaabb[[ccuurrrrppiidd]];;iiff((pprrppttrr-->>pprrhhaassmmssgg====FFAALLSSEE)){{pprrppttrr-->>pprrssttaattee==PPRR__RREECCVV;;rreesscchheedd(());;//**BBlloocckkuunnttiillmmeessssaaggeeaarrrriivveess**//}} mmssgg==pprrppttrr-->>pprrmmssgg;;//**RReettrriieevveemmeessssaaggee**//pprrppttrr-->>pprrhhaassmmssgg==FFAALLSSEE;;//**RReesseettmmeessssaaggeeffllaagg**//rreessttoorree((mmaasskk));;rreettuurrnnmmssgg;;}}Look carefully at the code and notice that receive copies the message from theprocess table entry into local variable msg and then returns the value in msg. Interest-ingly, receive does not modify field prmsg in the process table. Thus, it may seem thata more efficient implementation would avoid copying into a local variable and simply return the message from the process table:return proctab[currpid].prmsg;Sec. 8.6        Implementation Of Receive 149Unfortunately, such an implementation is incorrect; an exercise asks readers to consider why the implementation can produce incorrect results.8.7 Implementation Of Non-Blocking Message ReceptionRecvclr operates much like receive except that it always returns immediately. If amessage is waiting, recvclr returns the message; otherwise, recvclr returns OK.//**rreeccvvccllrr..cc--rreeccvvccllrr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rreeccvvccllrr--CClleeaarriinnccoommiinnggmmeessssaaggee,,aannddrreettuurrnnmmeessssaaggeeiiffoonneewwaaiittiinngg**------------------------------------------------------------------------------------------------------------------------------------------------**//uummssgg3322rreeccvvccllrr((vvooiidd)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//uummssgg3322mmssgg;;//**MMeessssaaggeettoorreettuurrnn**//mmaasskk==ddiissaabbllee(());;pprrppttrr==&&pprrooccttaabb[[ccuurrrrppiidd]];;iiff((pprrppttrr-->>pprrhhaassmmssgg====TTRRUUEE)){{mmssgg==pprrppttrr-->>pprrmmssgg;;//**RReettrriieevveemmeessssaaggee**//pprrppttrr-->>pprrhhaassmmssgg==FFAALLSSEE;;//**RReesseettmmeessssaaggeeffllaagg**//}}eellssee{{mmssgg==OOKK;;}} rreessttoorree((mmaasskk));;rreettuurrnnmmssgg;;}}8.8 PerspectiveLike the counting semaphore abstraction in the previous chapter, the code for a basic message passing facility is extremely compact and efficient. Look at the functions and notice how few lines of code perform each operation. Furthermore, observe that storing the message buffer in the process table is important because doing so isolates message passing from memory management and allows message passing to be posi-tioned at a low level in the hierarchy.150 Message Passing Chap. 88.9 SummaryMessage passing facilities provide inter-process communication that allows a proc-ess to send information to another process. A completely synchronous message passing system blocks either the sender or receiver, depending on how many messages have been sent and received. Our example system includes two facilities for message pass-ing: a low-level mechanism that provides direct communication among processes and a high-level mechanism that uses rendezvous points.The Xinu low-level message passing mechanism limits the message size to a single word, restricts each process to at most one outstanding message, and uses first-message semantics. Message storage is associated with the process table — a message sent to process P is stored in the process table entry for P. The use of first-message semantics allows a process to determine which of several events occurs first.The low-level message facility comprises three functions: send, receive, and recvclr. Of the three functions, only receive is blocking — it blocks the calling process until a message arrives. A process can use recvclr to remove an old message before starting an interaction that uses message passing.EXERCISES8.1 Write a program that prints a prompt, and then loops printing the prompt again every 8seconds until someone types a character. Hint: sleep(8) delays the calling process for 8 seconds.8.2   Assume send and receive do not exist, and build code to perform message passing usingsuspend and resume.8.3  The example implementation uses first-message semantics. What facilities exist to handlelast-message semantics?8.4 Implement versions of send and receive that record up to K messages per process (makesuccessive calls to send block).8.5    Investigate systems in which the innermost level of the system implements message passinginstead of context switching. What is the advantage? The chief liability?8.6 Consider the modification of receive mentioned in the text that returns the message directlyfrom the process table entry:return proctab[currpid].prmsg;Explain why such an implementation is incorrect.8.7 Implement versions of send and receive that define a fixed set of thirty-two possible mes-sages. Instead of using integers to represent messages, use one bit of a word to representeach message, and allow a process to accumulate all thirty-two messages.8.8 Observe that because receive uses SYSERR to indicate an error, sending a message with thesame value as SYSERR is ambiguous. Furthermore, recvclr returns OK if no message iswaiting. Modify recvclr to return SYSERR if no message is waiting, and modify send so itrefuses to send SYSERR (i.e., checks its argument and returns an error if the value isSYSERR).Chapter Contents9.1 Introduction, 1539.2 Types Of Memory, 1539.3 Definition Of A Heavyweight Process, 1549.4 Memory Management In Our Example System, 1559.5 Program Segments And Regions Of Memory, 1569.6 Dynamic Memory Allocation, 1579.7 Design Of The Low–level Memory Manager, 1589.8 Allocation Strategy And Memory Persistence, 1599.9 Keeping Track Of Free Memory, 1599.10 Implementation Of Low–level Memory Management, 1609.11 Data Structure Definitions Used With Free Memory, 1619.12 Allocating Heap Storage, 1629.13 Allocating Stack Storage, 1659.14 Releasing Heap And Stack Storage, 1679.15 Perspective, 1709.16 Summary, 1709Basic Memory Management
Memory is the ghost of experience.— Anonymous9.1 IntroductionPrevious chapters explain concurrent computation and the facilities that an operat-ing system provides to manage concurrent processes. The chapters discuss process creation and termination, scheduling, context switching, coordination, and inter-process communication.This chapter begins the discussion of a second key topic: facilities that an operat-ing system uses to manage memory. The chapter focuses on basics: dynamic allocationof stack and heap storage. It presents a set of functions that allocate and free memory,and explains how an embedded system handles memory for processes. The nextchapter continues the discussion of memory management by describing address spaces, high-level memory management facilities, and virtual memory.9.2 Types Of MemoryBecause it is essential for program execution and data storage, main memory ranks high among the important resources that an operating system manages. An operating system maintains information about the size and location of available free memory blocks, and allocates memory to concurrent programs upon request. The system recov-ers the memory allocated to a process when the process terminates, making the memory available for reuse. We will assume that code remains resident in memory.153154 Basic Memory Management Chap. 9In many embedded systems, main memory consists of a contiguous set of locations with addresses 0 through N–1. However, some systems have complex address spaces where certain regions are reserved (e.g., for memory-mapped devices or backward com-patibility). Our example platforms illustrate the two styles: the BeagleBone Black has a contiguous set of memory locations, and the Galileo provides a set of discontiguous blocks.Broadly speaking, memory can be divided into two categories:Stable Storage, such as Flash memory that retains values after thepower is removedRandom Access Memory (RAM) that only retains values while thesystem is powered onIn terms of addresses, the two types of memory occupy separate locations. For exam-ple, addresses 0 through K–1might correspond to Flash memory, and addresses K through N–1might correspond to dynamic RAM.†Some systems further distinguish regions of memory by using specific types ofmemory technologies. For example, RAM might be divided into two regions that use:Static RAM (SRAM): faster, but more expensiveDynamic RAM (DRAM): less expensive, but slowerBecause SRAM is more expensive, systems usually have a small amount of SRAM and a larger amount of DRAM. If memory types differ, a programmer must carefully place variables and code that are referenced the most frequently in SRAM, and items that are referenced less often in DRAM.9.3 Definition Of A Heavyweight ProcessOperating systems include mechanisms that prevent an application from reading or modifying areas of memory that have been assigned to another application. For exam-ple, Chapter 10 discusses how each process can be assigned a separate virtual address space. The approach, which is known as a heavyweight process abstraction, creates an address space, and then creates a process to run in the address space. Usually, code for a heavyweight process is loaded dynamically — an application must be compiled and stored in a file on disk before the application can be used in a heavyweight process. Thus, when creating the heavyweight process, a programmer specifies the file on disk that contains the compiled code, and the operating system loads the specified applica-tion into a new virtual address space and starts a process executing the application.Interestingly, some operating systems that support a heavyweight process abstrac-tion also incorporate a lightweight process abstraction (i.e., threads of execution). In-stead of a single process executing in an address space, the operating system starts a†Usually, K and N are each a power of 2.Sec. 9.3        Definition Of A Heavyweight Process 155single process, but then permits the process to create additional threads that all executein the same address space.In the hybrid system described above, a thread is similar to a Xinu process. Each thread has a separate runtime stack used to hold activation records for function calls (in-cluding a copy of local variables). The stacks are allocated from the data area in the heavyweight process’s address space. All the threads within a given heavyweight proc-ess share global variables; the global variables are allocated in the data area of the heavyweight process’s address space. Sharing implies the need for coordination —threads within a heavyweight process must use synchronization primitives, such as semaphores, to control access to the variables they share. Figure 9.1 illustrates threads within a heavyweight process...................heavyweight process’s address spaceshared variables and thread stackslightweight processes (threads)data in process
code in processFigure 9.1Illustration of a heavyweight process that contains multiple light-weight processes (threads). All threads share the address space.9.4 Memory Management In Our Example SystemThe largest embedded systems, such as those used in video game consoles, have the memory management hardware and operating system support needed for demand paged virtual memory. On the smallest embedded systems, however, the hardware can-not support multiple address spaces, nor can it protect processes from one another. As a consequence, the operating system and all processes occupy a single address space.Although running multiple processes in a single address space does not offer pro-tection, the approach has advantages. Because they can pass pointers among them-selves, processes can share large amounts of data without copying from one addressspace to another. Furthermore, the operating system itself can easily dereference an ar-bitrary pointer because the interpretation of an address does not depend on the process156 Basic Memory Management Chap. 9context. Finally, having just one address space makes the memory manager muchsimpler than the memory managers found in more sophisticated systems.9.5 Program Segments And Regions Of MemoryA C compiler divides a memory image into four contiguous regions known as: Text segmentData segmentBss segmentFree spaceText segment. The text segment, which begins at the lowest usable memory ad-dress, contains compiled code for each of the functions that are part of the memory im-age (including the code for function main, which is compiled and linked like other func-tions). A compiler may also choose to place constants in the text segment because con-stants are read, but never changed. For example, string constants can be placed in the text segment. If the hardware includes a protection mechanism, addresses in the text segment are classified as read-only, which means that an error occurs if the program at-tempts to store into any of the text locations at runtime.Data segment. The data segment, which follows the text segment, contains storage for all global variables that are assigned an initial value. In C, such variables are de-clared to be global by placing the declarations outside of function declarations. Values in the data segment are classified as read-write because they may be both accessed and modified.Bss segment. The term bss abbreviates block started by symbol, and is taken from the assembly language of a PDP-11, the computer on which C was designed. The bss segment, which follows the data segment, contains global variables that are not initial-ized explicitly. Following C conventions, Xinu writes zero into each bss location be-fore execution begins.Free space. Addresses beyond the bss segment are considered free (i.e., unallocat-ed) when execution begins. To simplify the discussion, we will assume free space con-sists of a single, contiguous region. In practice, some hardware platforms (e.g., the Galileo platform) may divide the free space into a set of discontiguous blocks.As described in Chapter 3, a C program loader defines three external symbols, etext, edata, and end,† that correspond to the first memory location beyond the text seg-ment, the first memory location beyond the data segment, and the first memory location beyond the bss segment. Figure 9.2 illustrates the memory layout when Xinu begins to execute and the three external symbols.†External symbol names have an underscore prepended by the loader. Thus, if we use etext in a C pro-gram, it becomes _etext in the linked image.Sec. 9.5        Program Segments And Regions Of Memory 157textdatabssfree spaceetext edata endmax addressstart addressFigure 9.2  Illustration of the memory layout when Xinu begins.The external symbols shown in Figure 9.2 are not variables, but instead are names assigned to memory locations when the image is linked. Thus, a program should onlyuse one of the external symbols to reference a location and should not load or store a value. For example, the text segment might occupy memory locations from the starting address through etext – 1. To compute the size, a program declares etext to be an exter-nal integer, and references&etext in an expression.How can a program determine the free space available for use? Our example plat-forms illustrate two approaches. In the case of the BeagleBone Black, the hardware manual specifies the available addresses. In the case of the Galileo, when it is powered on, the hardware and boot loader work together to probe memory, build a table of avail-able address blocks, and pass the table to whatever operating system is being booted. We will see that the version of Xinu used on the BeagleBone Black contains constants that specify the address range, and the version of Xinu that runs on a Galileo is passed a list of available address blocks when it boots.9.6 Dynamic Memory AllocationAlthough they are allocated fixed locations in the address space and must remain resident in physical memory at all times, program text and global variables only account for part of the memory used by an executing process. The remaining memory can be allocated dynamically for:StackHeapStack. Each process needs space for a stack that holds the activation record associ-ated with each function the process invokes. In addition to arguments, an activationrecord contains storage for local variables.Heap. A process or set of processes may also use heap storage. Items from theheap are allocated dynamically and persist independent of specific function calls.Xinu accommodates both types of dynamic memory. First, when creating a new process, Xinu allocates a stack for the process. Stacks are allocated from the highest block in free space that accommodates the request. Second, whenever a process re-quests heap storage, Xinu allocates the necessary amount of space from the lowest free158 Basic Memory Management Chap. 9block that accommodates the request. Figure 9.3 shows an example of the memory lay-out when three processes are executing and heap storage has been allocated.textdatabssheapstack1stack2stack3freeetext edata endFigure 9.3  Illustration of memory after three processes have been created.9.7 Design Of The Low–level Memory ManagerA set of functions and associated data structures are used to manage free memory.The low-level memory manager provides five functions:getstk — Allocate stack space when a process is createdfreestk — Release a stack when a process terminatesgetmem — Allocate heap storage on demandfreemem— Release heap storage as requestedmeminit — Initialize the free list at startupOur design treats free space as a single, exhaustable resource — the low-level memory manager allocates space provided a request can be satisfied. Furthermore, the low-level memory manager does not partition the free space into memory available for process stacks and memory available for heap variables. Requests of one type can take the remaining free space, and leave none for the other type. Of course, such an alloca-tion only works if processes cooperate. Otherwise, a given process can consume all free memory, leaving no space for other processes. Chapter 10 illustrates an alternative ap-proach by describing a set of high-level memory management functions that prevent ex-haustion by partitioning memory among subsystems. The high-level memory manager also demonstrates how processes can block until memory becomes available.Functions getstk and freestk are not intended for general use. Instead, when itforms a new process, create calls getstk to allocate a stack. Getstk obtains a block ofmemory from the highest address of free space, and returns a pointer to the block. Create records the size and location of the allocated stack space in the process table en-try. Later, when the process becomes current, the context switch moves the stack ad-dress into the stack pointer register, allowing the stack to be used for function calls. Fi-nally, when the process terminates, kill calls function freestk to release the process’s stack and return the block to the free list.Functions getmem and freemem perform analogous functions for heap storage. Un-like the stack allocation functions, getmem and freemem allocate heap space from thelowest available free memory address.Sec. 9.8        Allocation Strategy And Memory Persistence 1599.8 Allocation Strategy And Memory PersistenceBecause only create and kill allocate and free process stacks, the system can guarantee that the stack space allocated to a process will be released when the process exits. However, the system does not record the set of blocks that a process allocates from the heap by calling getmem. Therefore, the system does not automatically release heap storage. As a consequence, the burden of returning heap space is left to the pro-grammer:Heap space persists independent of the process that allocates thespace. Before it exits, a process must explicitly release storage that it has allocated from the heap, or the space will remain allocated.Of course, returning allocated heap space does not guarantee that the heap will never be exhausted. On the one hand, demand can exceed the available space. On the other hand, the free space can become fragmented into small, discontiguous pieces that are each too small to satisfy a request. A later chapter continues the discussion of allo-cation policies, and shows one approach to avoiding fragmentation of the free space.9.9 Keeping Track Of Free MemoryA memory manager must keep information about all free memory blocks. To do so, the memory manager forms a list, where each item on the list specifies a memory address at which a block starts and a length. In systems where the entire free memory is contiguous, the initial list will contain only one item that corresponds to the block of memory between the end of the program and the highest available address. In systems where the free memory is divided into blocks, the initial list will contain one node for each block. In either case, when a process requests a block of memory, the memory manager searches the list, finds a free area, allocates the requested size block, and up-dates the list to show that more of the free memory has been allocated. Similarly, whenever a process releases a previously allocated block of memory, the memory manager adds the block to the list of free blocks. Figure 9.4 illustrates an example set of four free memory blocks.Block Address Length1 0x84F800 40962 0x850F70 81923 0x8A03F0 81924 0x8C01D0 4096Figure 9.4  An example set of free memory blocks.160 Basic Memory Management Chap. 9A memory manager must examine each transaction carefully to avoid generating an arbitrarily long list of small blocks. When a block is released, the memory manager scans the list to see if the released block is adjacent to the end of one of the existingfree blocks. If so, the size of the existing block can be increased without adding a new entry to the list. Similarly, if the new block is adjacent to the beginning of an existing block, the entry can be updated. Finally, if a released block exactly fills the gap between two free blocks on the list, the memory manager will combine the two existing entries on the list into one giant block that covers all the memory from the two on the list plus the released block. We use the term coalesce to describe combining entries. The point is: if a memory manager is built correctly, once all allocated blocks have been released, the free list will be back to the initial state (i.e., the exact set of memory regions that were free when the operating system started).9.10 Implementation Of Low–level Memory ManagementWhere should the list of free memory blocks be stored? Our example implementa-tion follows a standard approach by using free memory itself to store the list. After all,a free memory block is not being used, so the contents are no longer needed. Thus, the free memory blocks can be chained together to form a linked list by placing a pointer in each block to the next block.In the code, global variable memlist contains a pointer to the first free block. Thekey to understanding the implementation lies in the invariant maintained at all times:All free blocks of memory are kept on a linked list; blocks on the free list are ordered by increasing address.The example set of blocks in Figure 9.4 shows two items associated with each en-try: an address and a size. In our linked list implementation, each node in the list pointsto (i.e., gives the address) of the next node. However, we must also store the size ofeach block. Therefore, each block of free memory contains two items: a pointer to the next free block of memory and an integer that gives the size of the current block. Fig-ure 9.5 illustrates the concept.zx yfree block of x bytes free block of y bytesglobal variablememliststructurememblk imposed on free block
Figure 9.5 Illustration of a free memory list that contains two memoryblocks.Sec. 9.10        Implementation Of Low–level Memory Management 1619.11 Data Structure Definitions Used With Free MemoryFile memory.h contains declarations related to memory management. Structurememblk is imposed on each free node.//**mmeemmoorryy..hh--rroouunnddmmbb,,ttrruunnccmmbb,,ffrreeeessttkk**//##ddeeffiinneePPAAGGEE__SSIIZZEE44009966//**--------------------------------------------------------------------------------------------------------------------------------------------**rroouunnddmmbb,,ttrruunnccmmbb--RRoouunnddoorrttrruunnccaatteeaaddddrreessssttoommeemmoorryybblloocckkssiizzee**--------------------------------------------------------------------------------------------------------------------------------------------**//##ddeeffiinneerroouunnddmmbb((xx))((cchhaarr**))((((77++((uuiinntt3322))((xx))))&&((~~77))))##ddeeffiinneettrruunnccmmbb((xx))((cchhaarr**))((((((uuiinntt3322))((xx))))&&((~~77))))//**--------------------------------------------------------------------------------------------------------------------------------------------**ffrreeeessttkk----FFrreeeessttaacckkmmeemmoorryyaallllooccaatteeddbbyyggeettssttkk**--------------------------------------------------------------------------------------------------------------------------------------------**//##ddeeffiinneeffrreeeessttkk((pp,,lleenn))ffrreeeemmeemm((((cchhaarr**))((((uuiinntt3322))((pp))\\--((((uuiinntt3322))rroouunnddmmbb((lleenn))))\\++((uuiinntt3322))ssiizzeeooff((uuiinntt3322)))),,\\((uuiinntt3322))rroouunnddmmbb((lleenn))))ssttrruuccttmmeemmbbllkk{{//**SSeeeerroouunnddmmbb&&ttrruunnccmmbb**//ssttrruuccttmmeemmbbllkk**mmnneexxtt;;//**PPttrrttoonneexxttffrreeeemmeemmoorryybbllkk**//uuiinntt3322mmlleennggtthh;;//**SSiizzeeooffbbllkk((iinncclluuddeessmmeemmbbllkk))**//}};;eexxtteerrnnssttrruuccttmmeemmbbllkkmmeemmlliisstt;;//**HHeeaaddooffffrreeeemmeemmoorryylliisstt**//eexxtteerrnnvvooiidd**mmiinnhheeaapp;;//**SSttaarrttooffhheeaapp**//eexxtteerrnnvvooiidd**mmaaxxhheeaapp;;//**HHiigghheessttvvaalliiddhheeaappaaddddrreessss**////**AAddddeeddbbyylliinnkkeerr**//eexxtteerrnniinntttteexxtt;;//**SSttaarrttoofftteexxttsseeggmmeenntt**//eexxtteerrnniinntteetteexxtt;;//**EEnnddoofftteexxttsseeggmmeenntt**//eexxtteerrnniinnttddaattaa;;//**SSttaarrttooffddaattaasseeggmmeenntt**//eexxtteerrnniinntteeddaattaa;;//**EEnnddooffddaattaasseeggmmeenntt**//eexxtteerrnniinnttbbssss;;//**SSttaarrttooffbbsssssseeggmmeenntt**//eexxtteerrnniinntteebbssss;;//**EEnnddooffbbsssssseeggmmeenntt**//eexxtteerrnniinntteenndd;;//**EEnnddooffpprrooggrraamm**//162 Basic Memory Management Chap. 9In struct memblk, field mnext points to the next block on the list or contains the value NULL to indicate that a block is the final block on the list. Field mlength speci-fies the length of the current block in bytes, including the header. Note that the lengthis declared to be an unsigned long, which accommodates any size block up to the entire 32-bit physical address space.Variable memlist, which constitutes the head of the list, is defined as consisting of a memblk structure. Thus, the head of the list has exactly the same form that we impose on other nodes in the list. In memlist, however, the mlength field (which is normally used to store the size of a block) is not meaningful because the size of memlist is sizeof(struct memblk). Consequently, we can use the length field for another purpose. Xinu uses the field to store the total size of free memory (i.e., a sum of the length field in each free block). Having a count of the free memory can help when debugging or to assess whether the system is approaching the maximum possible size.Note that each block on the free list must hold a complete memblk structure (i.e.,eight bytes). The design choice has a consequence: our free list cannot store a freeblock of less then eight bytes. How can we guarantee that no process attempts to free a smaller amount of memory? We can tell programmers that they must free exactly the same amount they request, and design the memory management functions to ensure all requests are at least eight bytes. But another problem can arise if the memory manager extracts a piece from a free block: subtraction can leave a remainder of less than eight bytes. To solve the problem, our memory manager rounds all requests to a multiple of memblk structures. Our solution has a useful property described later: subtracting a multiple of eight from a multiple of eight always produces a multiple of eight.File memory.h defines two inline functions, roundmb and truncmb, that handle the rounding. Function roundmb rounds requests to multiples of eight bytes, and truncmb is used to truncate a memory size to a multiple of eight bytes. Truncation is only usedat startup: if the initial size of a free block is not a multiple of eight, the size must be truncated down rather than rounded up. To make the implementation efficient, the code for the two functions uses constants and Boolean operations rather than the sizeof func-tion and division. Using Boolean operations is only possible because the size of a memory block is a power of two. We can summarize:Rounding all requests to multiples of the memblk structure ensuresthat each request satisfies the size constraint and guarantees that no free block will ever be too small to link into the free list.9.12 Allocating Heap StorageFunction getmem allocates heap storage by finding a free block that is sufficient for the request. Our implementation uses a first-fit allocation strategy by allocating the first block on the free list that satisfies a request. Getmem subtracts the requested memory from the free block and adjusts the free list accordingly. File getmem.c contains the code.Sec. 9.12        Allocating Heap Storage 163//**ggeettmmeemm..cc--ggeettmmeemm**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettmmeemm--AAllllooccaatteehheeaappssttoorraaggee,,rreettuurrnniinngglloowweessttwwoorrddaaddddrreessss**------------------------------------------------------------------------------------------------------------------------------------------------**//cchhaarr**ggeettmmeemm((uuiinntt3322nnbbyytteess//**SSiizzeeooffmmeemmoorryyrreeqquueesstteedd**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttmmeemmbbllkk**pprreevv,,**ccuurrrr,,**lleeffttoovveerr;;mmaasskk==ddiissaabbllee(());;iiff((nnbbyytteess====00)){{rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))SSYYSSEERRRR;;}} nnbbyytteess==((uuiinntt3322))rroouunnddmmbb((nnbbyytteess));;//**UUsseemmeemmbbllkkmmuullttiipplleess**//pprreevv==&&mmeemmlliisstt;;ccuurrrr==mmeemmlliisstt..mmnneexxtt;;wwhhiillee((ccuurrrr!!==NNUULLLL)){{//**SSeeaarrcchhffrreeeelliisstt**//iiff((ccuurrrr-->>mmlleennggtthh====nnbbyytteess)){{//**BBlloocckkiisseexxaaccttmmaattcchh**//pprreevv-->>mmnneexxtt==ccuurrrr-->>mmnneexxtt;;mmeemmlliisstt..mmlleennggtthh--==nnbbyytteess;;rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))((ccuurrrr));;}}eellsseeiiff((ccuurrrr-->>mmlleennggtthh>>nnbbyytteess)){{//**SSpplliittbbiiggbblloocckk**//lleeffttoovveerr==((ssttrruuccttmmeemmbbllkk**))((((uuiinntt3322))ccuurrrr++nnbbyytteess));;pprreevv-->>mmnneexxtt==lleeffttoovveerr;;lleeffttoovveerr-->>mmnneexxtt==ccuurrrr-->>mmnneexxtt;;lleeffttoovveerr-->>mmlleennggtthh==ccuurrrr-->>mmlleennggtthh--nnbbyytteess;;mmeemmlliisstt..mmlleennggtthh--==nnbbyytteess;;rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))((ccuurrrr));;}}eellssee{{//**MMoovveettoonneexxttbblloocckk**//pprreevv==ccuurrrr;;ccuurrrr==ccuurrrr-->>mmnneexxtt;;164 Basic Memory Management Chap. 9}}}} rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))SSYYSSEERRRR;;}}After verifying that its argument is valid and the free list is not empty, getmem uses roundmb to round the memory request to a multiple of memblk bytes, and thensearches the free list to find the first block of memory large enough to satisfy the re-quest. Because the free list is singly linked, getmem uses two pointers, prev and curr, to walk the list. The code maintains the following invariant during the search: when curr points to a free block, prev points to its predecessor on the list (possibly the head of the list, memlist). As it runs through the list, the code must ensure the invariant remains intact. Consequently, when a free block is discovered that is large enough to satisfy the request, prev will point to the predecessor.At each step of the iteration, getmem compares the size of the current block tonbytes, the size of the request. There are three cases. If the size of the current block isless than the size requested, getmem moves to the next block on the list and continuesthe search. If the size of the current block exactly matches the size of the request, get-mem removes the block from the free list (by making the mnext field in the predecessor block point to the successor block), and returns a pointer to the current block. Finally, if the size of the current block is greater than the size requested, getmem partitions the current block into two pieces: one of size nbytes that will be returned to the caller, and a remaining piece that will be left on the free list. To divide a free block into two pieces, getmem computes the address of the remaining piece, and places the address in variable leftover. Computing such an address is conceptually simple: the leftover piece lies nbytes beyond the beginning of the block. However, adding nbytes to pointer curr will not produce the desired result because C performs pointer arithmetic. To force C to use integer arithmetic instead of pointer arithmetic, variable curr is cast to an unsigned in-teger before adding nbytes:(uint32) currOnce a sum has been computed, another cast is applied to change the result back into a memory block pointer. After leftover has been computed, the mnext field of the prev block is updated, and the mnext and mlength fields in the leftover block are as-signed.The code relies on a fundamental mathematical relationship: subtracting two multi-ples of K will produce a multiple of K. In the example, K is the size of a memblk struc-ture, eight bytes. Thus, if the system begins by using roundmb to round the size of free memory, and always uses roundmb to round requests, each free block and each leftover piece will be large enough to hold a memblk structure.Sec. 9.13        Allocating Stack Storage 1659.13 Allocating Stack StorageFunction getstk allocates a block of memory for a process stack. We will see thatgetstk is invoked whenever a process is created. The code appears in file getstk.c.Because the free list is kept in order by memory address and stack space is allocat-ed from the highest available block, getstk must search the entire list of free blocks.During the search, getstk records the address of any block that satisfies the request,which means that after the search completes, the last recorded address points to the free block with the highest address that satisfies the request.† As with getmem, getstk main-tains the invariant that during the search, variables curr and prev point to a free block of memory and the predecessor of the free block, respectively. Whenever a block is found that has sufficient size to satisfy the request, getstk sets variable fits to the address of the block and sets variable fitsprev to the address of its predecessor. Thus, when the search completes, fits points to the usable free block with the highest memory address (or will remain equal to NULL if no block satisfies the request).Once the search completes and a block has been found, two cases arise, analogous to the cases in getmem. If the size of the block on the free list is exactly the size re-quested, getstk unlinks the block from the free list and returns the address of the block to its caller. Otherwise, getstk partitions the block into two pieces, allocating a piece of size nbytes, and leaves the remainder on the free list. Because getstk returns the piece from the highest part of the selected block, the computation differs slightly from that in getmem.
†The strategy of allocating the block with the highest address that satisfies a request is known as thelast-fit strategy.166 Basic Memory Management Chap. 9//**ggeettssttkk..cc--ggeettssttkk**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettssttkk--AAllllooccaatteessttaacckkmmeemmoorryy,,rreettuurrnniinngghhiigghheessttwwoorrddaaddddrreessss**------------------------------------------------------------------------------------------------------------------------------------------------**//cchhaarr**ggeettssttkk((uuiinntt3322nnbbyytteess//**SSiizzeeooffmmeemmoorryyrreeqquueesstteedd**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttmmeemmbbllkk**pprreevv,,**ccuurrrr;;//**WWaallkktthhrroouugghhmmeemmoorryylliisstt**//ssttrruuccttmmeemmbbllkk**ffiittss,,**ffiittsspprreevv;;//**RReeccoorrddbblloocckktthhaattffiittss**//mmaasskk==ddiissaabbllee(());;iiff((nnbbyytteess====00)){{rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))SSYYSSEERRRR;;}} nnbbyytteess==((uuiinntt3322))rroouunnddmmbb((nnbbyytteess));;//**UUsseemmbblloocckkmmuullttiipplleess**//pprreevv==&&mmeemmlliisstt;;ccuurrrr==mmeemmlliisstt..mmnneexxtt;;ffiittss==NNUULLLL;;ffiittsspprreevv==NNUULLLL;;//**JJuussttttooaavvooiiddaaccoommppiilleerrwwaarrnniinngg**//wwhhiillee((ccuurrrr!!==NNUULLLL)){{//**SSccaanneennttiirreelliisstt**//iiff((ccuurrrr-->>mmlleennggtthh>>==nnbbyytteess)){{//**RReeccoorrddbblloocckkaaddddrreessss**//ffiittss==ccuurrrr;;//**wwhheennrreeqquueessttffiittss**//ffiittsspprreevv==pprreevv;;}} pprreevv==ccuurrrr;;ccuurrrr==ccuurrrr-->>mmnneexxtt;;}} iiff((ffiittss====NNUULLLL)){{//**NNoobblloocckkwwaassffoouunndd**//rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))SSYYSSEERRRR;;}} iiff((nnbbyytteess====ffiittss-->>mmlleennggtthh)){{//**BBlloocckkiisseexxaaccttmmaattcchh**//ffiittsspprreevv-->>mmnneexxtt==ffiittss-->>mmnneexxtt;;}}eellssee{{//**RReemmoovveettooppsseeccttiioonn**//Sec. 9.13        Allocating Stack Storage 167ffiittss-->>mmlleennggtthh--==nnbbyytteess;;ffiittss==((ssttrruuccttmmeemmbbllkk**))((((uuiinntt3322))ffiittss++ffiittss-->>mmlleennggtthh));;}} mmeemmlliisstt..mmlleennggtthh--==nnbbyytteess;;rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))((((uuiinntt3322))ffiittss++nnbbyytteess--ssiizzeeooff((uuiinntt3322))));;}}9.14 Releasing Heap And Stack StorageOnce it finishes using a block of heap storage, a process calls function freemem to return the block to the free list, making the memory eligible for subsequent allocation. Because blocks on the free list are kept in order by address, freemem uses the block’s address to find the correct location on the list. In addition, freemem handles the task of coalescing the block with adjacent free blocks. There are three cases: the new block of memory can be adjacent to the previous block, adjacent to the succeeding block, or ad-jacent to both. When any of the three cases occurs, freemem combines the new block with adjacent block(s) to form one large block on the free list. Coalescing helps avoid memory fragmentation.The code for freemem can be found in file freemem.c. As ingetmem, two pointers, prev and next, run through the list of free blocks. Freemem searches the list until the address of the block to be returned lies between prev and next. Once the correct posi-tion has been found, the code performs coalescing.Coalescing is handled in three steps. The code first checks for coalescing with the previous block. That is, freemem adds the length of the previous block to the block’s address to compute the address one beyond the previous block.  Freemem compares the result, which is found in variable top, to the address of the block being inserted. If the address of the inserted block equals top, freemem increases the size of the previous block to include the new block. Otherwise, freemem inserts the new block in the list. Of course, if the previous pointer points to the head of the memlist, no coalescing can be performed.Once it has handled coalescing with the previous block, freemem checks for coalescing with the next block. Once again, freemem computes the address that lies one beyond the current block, and tests whether the address is equal to the address of the next block. If so, the current block is adjacent to the next block, so freemem increases the size of the current block to include the next block, and unlinks the next block from the list.The important point is that freemem handles all three special cases:When adding a block to the free list, the memory manager must checkto see whether the new block is adjacent to the previous block, adja-cent to the next block, or adjacent to both.168 Basic Memory Management Chap. 9//**ffrreeeemmeemm..cc--ffrreeeemmeemm**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ffrreeeemmeemm--FFrreeeeaammeemmoorryybblloocckk,,rreettuurrnniinnggtthheebblloocckkttootthheeffrreeeelliisstt**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllffrreeeemmeemm((cchhaarr**bbllkkaaddddrr,,//**PPooiinntteerrttoommeemmoorryybblloocckk**//uuiinntt3322nnbbyytteess//**SSiizzeeooffbblloocckkiinnbbyytteess**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttmmeemmbbllkk**nneexxtt,,**pprreevv,,**bblloocckk;;uuiinntt3322ttoopp;;mmaasskk==ddiissaabbllee(());;iiff((((nnbbyytteess====00))||||((((uuiinntt3322))bbllkkaaddddrr<<((uuiinntt3322))mmiinnhheeaapp))||||((((uuiinntt3322))bbllkkaaddddrr>>((uuiinntt3322))mmaaxxhheeaapp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} nnbbyytteess==((uuiinntt3322))rroouunnddmmbb((nnbbyytteess));;//**UUsseemmeemmbbllkkmmuullttiipplleess**//bblloocckk==((ssttrruuccttmmeemmbbllkk**))bbllkkaaddddrr;;pprreevv==&&mmeemmlliisstt;;//**WWaallkkaalloonnggffrreeeelliisstt**//nneexxtt==mmeemmlliisstt..mmnneexxtt;;wwhhiillee((((nneexxtt!!==NNUULLLL))&&&&((nneexxtt<<bblloocckk)))){{pprreevv==nneexxtt;;nneexxtt==nneexxtt-->>mmnneexxtt;;}} iiff((pprreevv====&&mmeemmlliisstt)){{//**CCoommppuutteettooppooffpprreevviioouussbblloocckk**//ttoopp==((uuiinntt3322))NNUULLLL;;}}eellssee{{ttoopp==((uuiinntt3322))pprreevv++pprreevv-->>mmlleennggtthh;;}} //**EEnnssuurreenneewwbblloocckkddooeessnnoottoovveerrllaapppprreevviioouussoorrnneexxttbblloocckkss**//iiff((((((pprreevv!!==&&mmeemmlliisstt))&&&&((uuiinntt3322))bblloocckk<<ttoopp))||||((((nneexxtt!!==NNUULLLL))&&&&((uuiinntt3322))bblloocckk++nnbbyytteess>>((uuiinntt3322))nneexxtt)))){{rreessttoorree((mmaasskk));;Sec. 9.14        Releasing Heap And Stack Storage 169rreettuurrnnSSYYSSEERRRR;;}} mmeemmlliisstt..mmlleennggtthh++==nnbbyytteess;;//**EEiitthheerrccooaalleesscceewwiitthhpprreevviioouussbblloocckkoorraaddddttooffrreeeelliisstt**//iiff((ttoopp====((uuiinntt3322))bblloocckk)){{//**CCooaalleesscceewwiitthhpprreevviioouussbblloocckk**//pprreevv-->>mmlleennggtthh++==nnbbyytteess;;bblloocckk==pprreevv;;}}eellssee{{//**LLiinnkkiinnttoolliissttaassnneewwnnooddee**//bblloocckk-->>mmnneexxtt==nneexxtt;;bblloocckk-->>mmlleennggtthh==nnbbyytteess;;pprreevv-->>mmnneexxtt==bblloocckk;;}} //**CCooaalleesscceewwiitthhnneexxttbblloocckkiiffaaddjjaacceenntt**//iiff((((((uuiinntt3322))bblloocckk++bblloocckk-->>mmlleennggtthh))====((uuiinntt3322))nneexxtt)){{bblloocckk-->>mmlleennggtthh++==nneexxtt-->>mmlleennggtthh;;bblloocckk-->>mmnneexxtt==nneexxtt-->>mmnneexxtt;;}} rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Because free memory is treated as a single resource that can be used for stacks or heap storage, releasing stack memory follows the same algorithm as releasing heap storage. The only difference between heap and stack allocations arises because getmem returns the lowest address of an allocated block and getstk returns the highest address. In the current implementation, freestk is an inline function that invokes freemem. Be-fore calling freemem, freestk must convert its argument from the highest address in a block to the lowest. The code is found in memory.h.† Although the current implemen-tation uses a single underlying list, keeping freestk separate from freemem maintains a conceptual distinction, and makes it easier to modify the implementation later. The point is:Although the current implementation uses the same underlying func-tion to release heap and stack storage, having separate system calls for freestk and freemem maintains the conceptual distinction and makes the system easier to change later.†File memory.h can be found on page 161.170 Basic Memory Management Chap. 99.15 PerspectiveAlthough the mechanisms are relatively straightforward, the design of a memory management subsystem reveals one of the most surprisingly subtle problems in operat-ing systems. The problem arises from a fundamental conflict. On the one hand, an operating system is designed to run without stopping. Therefore, operating system fa-cilities must be resource-preserving: when a process finishes with a resource, the system must recapture the resource and make it available to other processes. On the other hand, any memory management mechanism that allows processes to allocate and free blocks of arbitrary size is not resource-preserving because memory can become frag-mented, with free memory divided into small, discontiguous blocks. Thus, a designer must be aware that the choice represents a tradeoff. Allowing arbitrary-size allocations makes the system easier to use, but also introduces a potential for problems.9.16 SummaryWe use the term heavyweight process to refer to an application that runs in aseparate address space; a lightweight process abstraction permits one or more processesto run in each address space.A Xinu image contains three segments: a text segment consisting of compiled code, a data segment that contains initialized data values, and a bss segment that con-tains uninitialized variables. When a system starts, physical memory not allocated to the three segments is considered free, and a low-level memory manager allocates the free memory on demand.When Xinu starts, the low-level memory manager forms a linked list of all free memory blocks; both stack and heap storage is allocated from the list as needed. Heap storage is allocated by finding the first free memory block that satisfies the request (i.e., the free block with the lowest address). A request for stack storage is satisfied from the highest free memory block that satisfies the request. Because the list of free memory blocks is singly linked in order by address, allocating stack space requires searching the entire free list.Our low-level memory manager treats free space as an exhaustable resource with no partition between stack and heap storage. Because the memory manager does not contain mechanisms to prevent a process from allocating all free memory, a program-mer must plan carefully to avoid starvation.EXERCISES9.1 Write a function that walks the list of free memory blocks and prints a line with the addressand length of each block.Exercises1719.2   In the previous exercise, what can occur if your function does not disable interrupts whilesearching the list?9.3    An early version of the low-level memory manager had no provision for returning blocks ofmemory to the free list. Speculate about memory allocation in an embedded system: are freemem and freestk necessary? Why or why not?9.4 Replace the low-level memory management functions with a set of functions that allocateheap and stack memory permanently (i.e., without providing a mechanism to return storageto a free list). How do the sizes of the new allocation routines compare to the sizes of getstk and getmem?9.5 Does the approach of allocating stack and heap storage from opposite ends of free spacehelp minimize fragmentation? To find out, consider a series of requests that intermix allo-cation and freeing of stack storage of 1000 bytes and heap storage of 500 bytes. Compare the approach described in the chapter to an approach that allocates stack and heap requests from the same end of free space (i.e., an approach in which all allocation uses getmem). Find a sequence of requests that result in fragmentation if stack and heap requests are not allocated from separate ends.9.6  At startup, function meminit is called to form an initial list of free memory. Compare mem-init for the Galileo and BeagleBone Black platforms. Which is smaller? Which is more general? Explain the basic tradeoff.9.7 Many embedded systems go through a prototype stage, in which the system is built on ageneral platform, and a final stage, in which minimal hardware is designed for the system.In terms of memory management, one question concerns the size of the stack needed byeach process. Modify the code to allow the system to measure the maximum stack spaceused by a process and report the maximum stack size when the process exits.9.8 Consider a hardware platform where the operating system must probe to find the size ofmemory at startup (i.e., read from an address and either receive an exception or some ran-dom value). Describe a strategy to find the maximum valid address efficiently.Chapter Contents10.1 Introduction, 17510.2 Partitioned Space Allocation, 17610.3 Buffer Pools, 17610.4 Allocating A Buffer, 17810.5 Returning Buffers To The Buffer Pool, 17910.6 Creating A Buffer Pool, 18110.7 Initializing The Buffer Pool Table, 18310.8 Virtual Memory And Memory Multiplexing, 18410.9 Real And Virtual Address Spaces, 18510.10 Hardware For Demand Paging, 18610.11 Address Translation With A Page Table, 187 10.12 Metadata In A Page Table Entry, 18810.13 Demand Paging And Design Questions, 189 10.14 Page Replacement And Global Clock, 190 10.15 Perspective, 19110.16 Summary, 19110High-level Memory Management and Virtual Memory
Yea, from the table of my memory I’ll wipe away all fond trivial records.— William Shakespeare10.1 IntroductionEarlier chapters consider abstractions that an operating system uses to manage computation and coordinate concurrent processes. The previous chapter describes alow-level memory management facility that treats memory as an exhaustable resource. The chapter discusses address spaces, program segments, and functions that manage a global free list. Although they are necessary, low-level memory management facilities are not sufficient for all needs.This chapter completes the discussion of memory management by introducing high-level facilities. The chapter explains the motivation for partitioning memory resources into independent subsets. It presents a high-level memory management mech-anism that allows memory to be divided into independent buffer pools, and explains how allocation and use of the memory in a given pool does not affect the use of memory in other pools. The chapter also describes virtual memory, and explains how virtual memory hardware operates.175176 High-level Memory Management and Virtual Memory Chap. 1010.2 Partitioned Space AllocationFunctions getmem and freemem that were described in the previous chapter consti-tute a basic memory manager. The design places no limit on the amount of memorythat a given process can allocate, nor do the functions attempt to divide free space “fair-ly.” Instead, the allocation functions merely honor requests on a first-come-first-served basis until no free memory remains. Once free memory has been exhausted, the func-tions reject further requests without blocking processes or waiting for memory to be released. Although it is relatively efficient, a global allocation strategy that forces all processes to contend for the same memory can lead to deprivation, a situation in which one or more processes cannot obtain memory because all memory has been consumed. As a consequence, global memory allocation schemes do not work well for all parts of the operating system.To understand why a system cannot rely on global allocation, consider software for network communication. Packets arrive at random. Because a network applicationtakes time to process a given packet, additional packets may arrive while one is being handled. If each incoming packet is placed in a memory buffer, exhaustive allocation can lead to disaster because incoming packets will pile up occupying memory and wait-ing to be processed. In the worst case, all the available memory will be allocated to packet buffers, and none will be available for other operating system functions. In par-ticular, if disk I/O uses memory, all disk I/O may stop until memory becomes avail-able. If the application processing network packets attempts to write to a file, deadlock can occur: the network process can block waiting for a disk buffer, but all memory is used for network buffers and no network buffer can be released until disk I/O com-pletes.To prevent deadlocks, higher-level memory management must be designed to parti-tion free memory into independent subsets, and ensure that allocation and deallocationof a given subset remains independent from the allocation and deallocation of other sub-sets. By limiting the amount of memory that can be used for a particular function, the system can guarantee that excessive requests will not lead to global deprivation. Fur-thermore, the system can assume that memory allocated for a particular function will al-ways be returned, so it can arrange to suspend processes until their memory request can be satisfied, eliminating the overhead introduced by busy waiting. Partitioning cannot guarantee that no deadlocks will occur, but it does limit unintentional deadlocks that arise when one subsystem takes memory needed by another subsystem.10.3 Buffer PoolsThe mechanism we have chosen to handle partitioned memory is known as a buffer pool manager. Memory is divided into a set of buffer pools. Each buffer pool contains a fixed number of memory blocks, and all blocks in a given pool are the same size. The term buffer was chosen to reflect the intended use in I/O routines and communica-tion software (e.g., disk buffers or buffers for network packets).Sec. 10.3        Buffer Pools177The memory space for a particular set of buffers is allocated when the pool is created; once a pool has been allocated, there is no way to increase the number ofbuffers in the pool or to change the buffer size.Each buffer pool is identified by an integer, known as a pool identifier or bufferpool ID. Like other IDs in Xinu, a buffer pool ID is used as an index into the bufferpool table, buftab. Once a pool has been created, a process uses the pool ID wheneverit requests a buffer from a pool or releases a previously allocated buffer back to a pool. Requests to allocate or release a buffer from a pool do not need to specify the length of a buffer because the size of buffers is fixed when the pool is created.The data structure used to hold information about buffer pools consists of a single table. Each entry in the table holds a buffer size, a semaphore ID, and a pointer to alinked list of buffers for the pool. Pertinent declarations can be found in file bufpool.h://**bbuuffppooooll..hh**//##iiffnnddeeffNNBBPPOOOOLLSS##ddeeffiinneeNNBBPPOOOOLLSS2200//**MMaaxxiimmuummnnuummbbeerrooffbbuuffffeerrppoooollss**//##eennddiiff##iiffnnddeeffBBPP__MMAAXXBB##ddeeffiinneeBBPP__MMAAXXBB88119922//**MMaaxxiimmuummbbuuffffeerrssiizzeeiinnbbyytteess**//##eennddiiff##ddeeffiinneeBBPP__MMIINNBB88//**MMiinniimmuummbbuuffffeerrssiizzeeiinnbbyytteess**//##iiffnnddeeffBBPP__MMAAXXNN##ddeeffiinneeBBPP__MMAAXXNN22004488//**MMaaxxiimmuummnnuummbbeerrooffbbuuffffeerrssiinnaappooooll**//##eennddiiffssttrruuccttbbppeennttrryy{{//**DDeessccrriippttiioonnooffaassiinngglleebbuuffffeerrppooooll**//ssttrruuccttbbppeennttrryy**bbppnneexxtt;;//**ppooiinntteerrttoonneexxttffrreeeebbuuffffeerr**//ssiidd3322bbppsseemm;;//**sseemmaapphhoorreetthhaattccoouunnttssbbuuffffeerrss**////**ccuurrrreennttllyyaavvaaiillaabblleeiinntthheeppooooll**//uuiinntt3322bbppssiizzee;;//**ssiizzeeooffbbuuffffeerrssiinntthhiissppooooll**//}};;eexxtteerrnnssttrruuccttbbppeennttrryybbuuffttaabb[[]];;//**BBuuffffeerrppoooollttaabbllee**//eexxtteerrnnbbppiidd3322nnbbppoooollss;;//**ccuurrrreennttnnuummbbeerrooffaallllooccaatteeddppoooollss**//Structure bpentry defines the contents of an entry in the buffer pool table, buftab. The buffers for a given pool are linked into a list, with field bpnext pointing to the first buffer on the list. Semaphore bpsem controls allocation from the pool, and integer bpsize gives the length of buffers in the pool.178 High-level Memory Management and Virtual Memory Chap. 1010.4 Allocating A BufferThe buffer pool mechanism differs from the low-level memory manager in another way: the mechanism is synchronous. That is, a process that requests a buffer will be blocked until the request can be satisfied. As in many of the previous examples, the implementation uses semaphores to control access to a buffer pool. Each buffer pool has a semaphore, and the code that allocates a buffer calls wait on a pool’s semaphore. The call returns immediately if buffers remain in the pool, but blocks the caller if no buffers remain. Eventually, when another process returns a buffer to a pool, the sema-phore is signaled, which allows a waiting process to obtain the buffer and resume exe-cution.Three functions provide an interface to buffer pools. A process calls function mkpool to create a buffer pool and obtain an ID. Once a pool as been created, a process can call function getbuf to obtain a buffer, and function freebuf to release a buffer back to the pool.  Getbuf works as expected, waiting on the semaphore until a buffer is avail-able, and then unlinking the first buffer from the list. The code is found in file getbuf.c://**ggeettbbuuff..cc--ggeettbbuuff**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettbbuuff--GGeettaabbuuffffeerrffrroommaapprreeeessttaabblliisshheeddbbuuffffeerrppooooll**------------------------------------------------------------------------------------------------------------------------------------------------**//cchhaarr**ggeettbbuuff((bbppiidd3322ppoooolliidd//**IInnddeexxooffppoooolliinnbbuuffttaabb**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttbbppeennttrryy**bbppppttrr;;//**PPooiinntteerrttooeennttrryyiinnbbuuffttaabb**//ssttrruuccttbbppeennttrryy**bbuuffppttrr;;//**PPooiinntteerrttooaabbuuffffeerr**//mmaasskk==ddiissaabbllee(());;//**CChheecckkaarrgguummeennttss**//iiff((((ppoooolliidd<<00||||ppoooolliidd>>==nnbbppoooollss)))){{rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))SSYYSSEERRRR;;}} bbppppttrr==&&bbuuffttaabb[[ppoooolliidd]];;Sec. 10.4        Allocating A Buffer 179//**WWaaiittffoorrppoooollttoohhaavvee>>00bbuuffffeerrssaannddaallllooccaatteeaabbuuffffeerr**//wwaaiitt((bbppppttrr-->>bbppsseemm));;bbuuffppttrr==bbppppttrr-->>bbppnneexxtt;;//**UUnnlliinnkkbbuuffffeerrffrroommppooooll**//bbppppttrr-->>bbppnneexxtt==bbuuffppttrr-->>bbppnneexxtt;;//**RReeccoorrddppoooollIIDDiinnffiirrssttffoouurrbbyytteessooffbbuuffffeerraannddsskkiipp**//**((bbppiidd3322**))bbuuffppttrr==ppoooolliidd;;bbuuffppttrr==((ssttrruuccttbbppeennttrryy**))((ssiizzeeooff((bbppiidd3322))++((cchhaarr**))bbuuffppttrr));;rreessttoorree((mmaasskk));;rreettuurrnn((cchhaarr**))bbuuffppttrr;;}}Observant readers may have noticed that getbuf does not return the address of the buffer to its caller. Instead, getbuf stores the pool ID in the first four bytes of the allo-cated space, and returns the address just beyond the ID. From a caller’s point of view, a call to getbuf returns the address of a buffer; the caller does not need to worry that earlier bytes hold the pool ID. The system is transparent: when the pool is created, ex-tra space is allocated in each buffer to hold the pool ID. When a buffer is released, freebuf uses the hidden pool ID to determine the pool to which a buffer belongs. The technique of using hidden information to identify a buffer pool turns out to be especial-ly useful when buffers are returned by a process other than the one that allocated the buffer.10.5 Returning Buffers To The Buffer PoolFunction freebuf returns a buffer to the pool from which it was allocated. Thecode is found in file freebuf.c:180 High-level Memory Management and Virtual Memory Chap. 10//**ffrreeeebbuuff..cc--ffrreeeebbuuff**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ffrreeeebbuuff--FFrreeeeaabbuuffffeerrtthhaattwwaassaallllooccaatteeddffrroommaappoooollbbyyggeettbbuuff**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllffrreeeebbuuff((cchhaarr**bbuuffaaddddrr//**AAddddrreessssooffbbuuffffeerrttoorreettuurrnn**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttbbppeennttrryy**bbppppttrr;;//**PPooiinntteerrttooeennttrryyiinnbbuuffttaabb**//bbppiidd3322ppoooolliidd;;//**IIDDooffbbuuffffeerr’’ssppooooll**//mmaasskk==ddiissaabbllee(());;//**EExxttrraaccttppoooollIIDDffrroommiinntteeggeerrpprriioorrttoobbuuffffeerraaddddrreessss**//bbuuffaaddddrr--==ssiizzeeooff((bbppiidd3322));;ppoooolliidd==**((bbppiidd3322**))bbuuffaaddddrr;;iiff((ppoooolliidd<<00||||ppoooolliidd>>==nnbbppoooollss)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**GGeettaaddddrreessssooffccoorrrreeccttppoooolleennttrryyiinnttaabbllee**//bbppppttrr==&&bbuuffttaabb[[ppoooolliidd]];;//**IInnsseerrttbbuuffffeerriinnttoolliissttaannddssiiggnnaallsseemmaapphhoorree**//((((ssttrruuccttbbppeennttrryy**))bbuuffaaddddrr))-->>bbppnneexxtt==bbppppttrr-->>bbppnneexxtt;;bbppppttrr-->>bbppnneexxtt==((ssttrruuccttbbppeennttrryy**))bbuuffaaddddrr;;ssiiggnnaall((bbppppttrr-->>bbppsseemm));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Recall that when it allocates a buffer, getbuf stores the pool ID in the four bytesthat precede the buffer address. Freebuf moves back four bytes from the beginning ofthe buffer, and extracts the pool ID. After verifying that the pool ID is valid, getbufuses the ID to locate the entry in the table of buffer pools. It then links the buffer backSec. 10.5        Returning Buffers To The Buffer Pool 181into the linked list of buffers, and signals the pool semaphore bpsem, allowing other processes to use the buffer.10.6 Creating A Buffer PoolFunction mkbufpool creates a new buffer pool and returns its ID. Mkbufpool takestwo arguments: the size of buffers in the pool and the number of buffers. Mkbufpoolbegins by checking its arguments. If the buffer size is out of range, the requestednumber of buffers is negative, or the buffer pool table is full, mkbufpool reports an er-ror.  Mkbufpool computes the size of memory required to hold the buffers, and calls get-mem to allocate the needed memory. If the memory allocation succeeds, mkbufpool al-locates an entry in the buffer pool table, and fills in entries. It creates a semaphore, saves the buffer size, and stores the address of the allocated memory in the linked list pointer, bpnext.Once the table entry has been initialized, mkbufpool iterates through the allocated memory, dividing the block into a set of buffers. It links each buffer onto the free list. Note that when mkbufpool creates the free list, each block of memory contains the size of the buffer the user requested plus the size of a buffer pool ID (four bytes). Thus, after the buffer pool ID is stored in the block, sufficient bytes remain for the buffer that the user requested. After the free list has been formed, mkbufpool returns the pool ID to its caller.182 High-level Memory Management and Virtual Memory Chap. 10//**mmkkbbuuffppooooll..cc--mmkkbbuuffppooooll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**mmkkbbuuffppooooll--AAllllooccaatteemmeemmoorryyffoorraabbuuffffeerrppoooollaannddlliinnkktthheebbuuffffeerrss**------------------------------------------------------------------------------------------------------------------------------------------------**//bbppiidd3322mmkkbbuuffppooooll((iinntt3322bbuuffssiizz,,//**SSiizzeeooffaabbuuffffeerriinntthheeppooooll**//iinntt3322nnuummbbuuffss//**NNuummbbeerrooffbbuuffffeerrssiinntthheeppooooll**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//bbppiidd3322ppoooolliidd;;//**IIDDooffppoooolltthhaattiissccrreeaatteedd**//ssttrruuccttbbppeennttrryy**bbppppttrr;;//**PPooiinntteerrttooeennttrryyiinnbbuuffttaabb**//cchhaarr**bbuuff;;//**PPooiinntteerrttoommeemmoorryyffoorrbbuuffffeerr**//mmaasskk==ddiissaabbllee(());;iiff((bbuuffssiizz<<BBPP__MMIINNBB||||bbuuffssiizz>>BBPP__MMAAXXBB||||nnuummbbuuffss<<11||||nnuummbbuuffss>>BBPP__MMAAXXNN||||nnbbppoooollss>>==NNBBPPOOOOLLSS)){{rreessttoorree((mmaasskk));;rreettuurrnn((bbppiidd3322))SSYYSSEERRRR;;}} //**RRoouunnddrreeqquueessttttooaammuullttiipplleeooff44bbyytteess**//bbuuffssiizz==((((bbuuffssiizz++33))&&((~~33))));;bbuuff==((cchhaarr**))ggeettmmeemm((nnuummbbuuffss**((bbuuffssiizz++ssiizzeeooff((bbppiidd3322))))));;iiff((((iinntt3322))bbuuff====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnn((bbppiidd3322))SSYYSSEERRRR;;}} ppoooolliidd==nnbbppoooollss++++;;bbppppttrr==&&bbuuffttaabb[[ppoooolliidd]];;bbppppttrr-->>bbppnneexxtt==((ssttrruuccttbbppeennttrryy**))bbuuff;;bbppppttrr-->>bbppssiizzee==bbuuffssiizz;;iiff((((bbppppttrr-->>bbppsseemm==sseemmccrreeaattee((nnuummbbuuffss))))====SSYYSSEERRRR)){{nnbbppoooollss----;;rreessttoorree((mmaasskk));;rreettuurrnn((bbppiidd3322))SSYYSSEERRRR;;}} bbuuffssiizz++==ssiizzeeooff((bbppiidd3322));;ffoorr((nnuummbbuuffss----;;nnuummbbuuffss>>00;;nnuummbbuuffss----)){{Sec. 10.6        Creating A Buffer Pool 183bbppppttrr==((ssttrruuccttbbppeennttrryy**))bbuuff;;bbuuff++==bbuuffssiizz;;bbppppttrr-->>bbppnneexxtt==((ssttrruuccttbbppeennttrryy**))bbuuff;;}} bbppppttrr==((ssttrruuccttbbppeennttrryy**))bbuuff;;bbppppttrr-->>bbppnneexxtt==((ssttrruuccttbbppeennttrryy**))NNUULLLL;;rreessttoorree((mmaasskk));;rreettuurrnnppoooolliidd;;}}10.7 Initializing The Buffer Pool TableFunction bufinit initializes the buffer pool table. Initialization occurs once before the buffer pools are used (i.e., the table is initialized when the system boots). The code, found in file bufinit.c, is trivial://**bbuuffiinniitt..cc--bbuuffiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttbbppeennttrryybbuuffttaabb[[NNBBPPOOOOLLSS]];;//**BBuuffffeerrppoooollttaabbllee**//bbppiidd3322nnbbppoooollss;;//**------------------------------------------------------------------------------------------------------------------------------------------------**bbuuffiinniitt--IInniittiiaalliizzeetthheebbuuffffeerrppoooollddaattaassttrruuccttuurree**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussbbuuffiinniitt((vvooiidd)){{nnbbppoooollss==00;;rreettuurrnnOOKK;;}}All that bufinit needs to do is set the global count of allocated buffer pools. In the example code, buffer pools can be allocated dynamically. However, once it has been allocated, a pool cannot be deallocated. An exercise suggests extending the mechanism to permit dynamic deallocation.184 High-level Memory Management and Virtual Memory Chap. 1010.8 Virtual Memory And Memory MultiplexingMost large computer systems virtualize memory and present an application with an abstract view of memory. Each application appears to occupy a large address space; ona system with a small physical memory, the address space can exceed the size of physi-cal memory. The operating system multiplexes physical memory among all processes that need to use it, moving all or part of the application into physical memory as need-ed. That is, code and data for processes are kept on secondary storage (i.e., disk), and moved into main memory temporarily when the process is executing. Although few embedded systems rely on virtual memory, many processors include virtual memory hardware.The chief design question in virtual memory management systems concerns theform of multiplexing. Several possibilities have been used:SwappingSegmentationPagingSwapping refers to an approach that moves all code and data associated with a par-ticular computation into main memory when the scheduler makes the computation current. Swapping works best for a long-running computation, such as a word proces-sor that runs while a human types a document — the computation is moved into main memory, and remains resident for a long period.Segmentation refers to an approach that moves pieces of the code and data associ-ated with a computation into main memory as needed. One can imagine, for example, placing each function and the associated variables in a separate segment. When a func-tion is called, the operating system loads the segment containing the function into main memory. Seldom-used functions (e.g., a function that displays an error message) remain on secondary storage. In theory, segmentation uses less memory than swapping because segmentation allows pieces of a computation to be loaded into memory as needed. Although the approach has intuitive appeal, few operating systems use dynam-ic segmentation.Paging refers to an approach that divides each program into small, fixed-size pieces called pages. The system keeps the most recently referenced pages in main memory, and moves copies of other pages to secondary storage. Pages are fetched on demand — when a running program references memory location i, the memory hardware checks to see whether the page containing location i is resident (i.e., currently in memory). If the page is not resident, the operating system suspends the process (al-lowing other processes to execute), and issues a request to the disk to obtain a copy of the needed page. Once the page has been placed in main memory, the operating system makes the process ready. When the process retries the reference to location i, the refer-ence succeeds.Sec. 10.9        Real And Virtual Address Spaces 18510.9 Real And Virtual Address SpacesIn many operating systems, the memory manager supplies each computation with its own, independent address space. That is, an application is given a private set of memory locations that are numbered 0 throughM–1. The operating system works with the underlying hardware to map each address space to a set of memory locations in memory. As a result, when an application references address zero, the reference is mapped to the memory location that corresponds to zero for the process. When another application references address zero, the reference is mapped to a different location. Thus, although multiple applications can reference address zero, each reference maps to a separate location, and the applications do not interfere with one another. To be pre-cise, we use the term physical address space or real address space to define the set of addresses that the memory hardware provides, and the term virtual address space to describe the set of addresses available to a given computation. At any time, memory functions in the operating system map one or more virtual address spaces onto the underlying physical address space. For example, Figure 10.1 illustrates how three virtu-al address spaces of K locations can be mapped onto an underlying physical address space that contains 3K locations.virtual space 3virtual space 2virtual space 1physical memory
......................0K–1
0K–1
0K–10K–1K2K – 12K3K – 1
Figure 10.1Illustration of three virtual address spaces mapped onto a singleunderlying physical address space.From the point of view of a running computation, only addresses in the virtual ad-dress space can be referenced. Furthermore, because the system maps each addressfrom a given virtual space to a specific region of memory, the running computation can-not accidentally read or overwrite memory that has been allocated to another computa-tion. As a result, a system that provides each computation with its own virtual address186 High-level Memory Management and Virtual Memory Chap. 10space helps detect programming errors and prevent problems. The point can be sum-marized:A memory management system that maps each virtual address space into a unique block of memory prevents one computation from reading or writing memory allocated to another computation.In Figure 10.1, each virtual address space is smaller than the underlying physical address space. However, most memory management systems permit a virtual address space to be larger than the memory on the machine. For example, a demand paging system only keeps pages that are being referenced in main memory, and leaves copies of other pages on disk.The original research on virtual memory arose from two motivations. First, the small size of physical memory limited the size of programs that were feasible. Second, with only one program running, a processor remained idle during I/O cycles. On the one hand, if multiple programs can be placed in memory, an operating system can switch the processor among them, allowing one to execute while another waits for an I/O operation. On the other hand, squeezing more programs into a fixed memory means each program will have less allocated memory, forcing the programs to be small. So, demand paging arose as a mechanism that handled both problems. By dividing pro-grams into many pieces, a demand paging system can choose to keep parts of many programs in memory, keeping the processor busy when a program waits for I/O. By al-lowing pieces of a program’s address space to be resident in memory without requiring space for the entire program, a demand paging system can support an address space that is larger than physical memory.10.10 Hardware For Demand PagingAn operating system that maps between virtual and real addresses cannot operate without hardware support. To understand why, observe that each address, including ad-dresses generated at runtime, must be mapped. Thus, if a program computes a value C and then jumps to location C, the memory system must map C to the corresponding real memory address. Only a hardware unit can perform the mapping efficiently.The hardware needed for demand paging consists of a page table and an address translation unit. A page table resides in kernel memory, and there is one page table for each process. Typically, the hardware contains a register that points to the current page table and a second register that specifies the length; after it has created a page table in memory, the operating system assigns values to the registers and turns on demand pag-ing. Similarly, when a context switch occurs, the operating system changes the page table registers to point to the page table for the new process. Figure 10.2 illustrates the arrangement.Sec. 10.10        Hardware For Demand Paging 187
Process 1 Page TableProcess N Page TableProcess 2 Page Table (active)...LPage Table Base RegisterPage Table Length Register
L
Figure 10.2  Page tables in memory and hardware registers that specify whichpage table to use at a given time.10.11 Address Translation With A Page TableConceptually, a page table consists of an array of pointers to memory locations. In addition to a pointer, each entry contains a bit that specifies whether the entry is valid (i.e., whether it has been initialized).Address translation hardware uses the currentpage table to translate a memory address; translation is applied to the instruction ad-dresses as well as addresses used to fetch or store data. Translation consists of array lookup: the hardware treats the high-order bits of an address as a page number, uses the page number as an index into the page table, and follows the pointer to the location of the page in memory.In practice, a page table entry does not contain a complete memory pointer. In-stead, pages are restricted to start in memory locations that have zeroes in the low-order bits, and the low-order bits are omitted from each page table entry. For example, sup-pose a computer has 32-bit addressing and uses 4096-byte pages (i.e., each page con-tains 212 bytes). If memory is divided into a set of 4096-byte frames, the starting ad-dress of each frame (i.e., the address of the first byte in the frame) will have zeroes in the 12 low-order bits. Therefore, to point to a frame in memory, a page table entry only needs to contain the upper 20 bits.To translate an address, A, the hardware uses the upper bits of A as an index intothe page table, extracts the address of a frame in memory where the page resides, andthen uses the low-order bits of A as an offset into the frame. We can imagine that the translation forms a physical memory address as Figure 10.3 illustrates.188 High-level Memory Management and Virtual Memory Chap. 10PO
FOFpage tablePth Entry in PageTable (20 bits)Virtual Address (32 bits)
Resulting Physical Address (32 bits)Page Number (20 bits) Offset (12 bits)
Figure 10.3  An example of virtual address translation used with paging.Our description implies that each address translation requires a page table access (i.e., a memory access). However, such overhead would be intolerable. To make trans-lation efficient, a processor employs a special-purpose hardware unit known as a Trans-lation Look-aside Buffer (TLB). The TLB caches recently accessed page table entries, and can look up the answer much faster than a conventional memory access. To achieve high speed, a TLB uses a form of parallel hardware known as a Content-Addressable Memory (CAM). Given an address, CAM hardware searches a set of stored values in parallel, returning the answer in only a few clock cycles. As a result, a TLB enables a processor to run as fast with address translation turned on as it can with ad-dress translation disabled.10.12 Metadata In A Page Table EntryIn addition to a frame pointer, each page table entry contains three bits of metadatathat the hardware and operating system use. Figure 10.4 lists the bits and their mean-ing.Sec. 10.12        Metadata In A Page Table Entry 189Name MeaningUse Bit Set by hardware whenever the pageis referenced (fetch or store)Modify Bit Set by hardware whenever a storeoperation changes data on the pagePresence Bit Set by OS to indicate whether thepage is resident in memoryFigure 10.4  The three metabits in each page table entry and their meanings.10.13 Demand Paging And Design QuestionsThe term demand paging refers to a system where an operating system places the pages for all processes on secondary storage, and only reads a page into memory whenthe page is needed (i.e., on demand). Special processor hardware is required to support demand paging: if a process attempts to access a page that is not resident in memory, the hardware must suspend execution of the current instruction and notify the operating system by signaling a page fault exception. When a page fault occurs, the operating system finds an unused frame in memory, reads the needed page from disk, and then in-structs the processor to resume the instruction that caused the fault.When a computer first starts, memory is relatively empty, which makes finding a free frame easy. Eventually, however, all frames in memory will be filled and the operating system must select one of the filled frames, copy the page back to disk (if the page has been modified), fetch the new page, and change the page tables accordingly. The selection of a page to move back to disk forms a key problem for operating sys-tems designers.The design of a paging system centers on the relationship between pages and processes. When process X encounters a page fault, should the operating system moveone of process X’s pages back to disk, or should the system select a page from another process? While a page is being fetched from disk, the operating system can run another process. How can the operating system ensure that at least some process has enough pages to run without also generating a page fault?† Should some pages be locked in memory? If so, which ones? How will the page selection policy interact with other policies, such as scheduling? For example, should the operating system guarantee each high-priority process a minimum number of resident pages? If the system allows processes to share memory, what policies apply to the shared pages?One of the interesting tradeoffs in the design of a paging system arises from the balance between I/O and processing. Paging overhead and the latency a process experi-ences can be reduced by giving a process the maximal amount of physical memory when the process runs. However, many processes are I/O-bound, which means that a given process is likely to block waiting for I/O. When one process blocks, overall per-†If insufficient frames exist in memory, a paging system can thrash, which means the frequency of page faults becomes so high that the system spends all its time paging and each process spends long periods waiting for pages.190 High-level Memory Management and Virtual Memory Chap. 10formance is maximized if another process is ready to execute and the operating system can switch context. That is, processor utilization and overall throughput of a system can be increased by having many processes ready to execute. So the question arises: should a given process be allowed to use many frames of memory or should memory be divided among processes?10.14 Page Replacement And Global ClockVarious page replacement policies have been proposed and tried:Least Recently Used (LRU)Least Frequently Used (LFU)First In First Out (FIFO)Interestingly, a provably optimal replacement policy has been discovered. Known as Belady’s optimal page replacement algorithm, the policy chooses to replace the page that will be referenced farthest in the future. Of course, the method is totally impracti-cal because the operating system cannot know how pages will be used in the future. However, Belady’s algorithm allows researchers to assess how well replacement poli-cies perform.In terms of practical systems, a single algorithm has become the de facto standardfor page replacement. Known as global clock or second chance, the algorithm was de-vised as part of the MULTICS operating system and has relatively low overhead. The term global means that all processes compete with one another (i.e., when process X generates a page fault, the operating system can choose a frame from another process, Y). The alternative name of the algorithm arises because global clock is said to give used frames a “second chance” before they are reclaimed.Global clock starts running whenever a page fault occurs. The algorithm maintains a pointer that sweeps through all the frames in memory, stopping when a free frame is found. The next time it runs, the algorithm starts at the frame just beyond where it left off.To determine whether to select a frame, global clock checks the Use and Modifybits in the page table of the frame. If the Use  /  Modify bits have value (0,0), globalclock chooses the frame. If the bits are (1,0), global clock resets them to (0,0) and by-passes the frame. Finally, if the bits are (1,1), global clock changes them to (1,0) and bypasses the frame, keeping a copy of the modified bit to know whether the page has been modified. In the worst case, global clock sweeps through all frames twice before reclaiming one.In practice, most implementations use a separate process to run the global clock al-gorithm (which allows the clock to perform disk I/O). Furthermore, global clock doesnot stop immediately once a frame has been found. Instead, the algorithm continues to run, and collects a small set of candidate pages. Collecting a set allows subsequent page faults to be handled quickly and avoids the overhead associated with running the global clock algorithm frequently (i.e., avoids frequent context switching).Sec. 10.15        Perspective19110.15 PerspectiveAlthough address space management and virtual memory subsystems comprisemany lines of code in an operating system, the most significant intellectual aspects ofthe problem arise from the choice of allocation policies and the consequent tradeoffs. Allowing each subsystem to allocate arbitrary amounts of memory maximizes flexibility and avoids the problem of a subsystem being deprived when free memory exists. Parti-tioning memory maximizes protection and avoids the problem of having one subsystem deprive other subsystems. Thus, a tradeoff exists between flexibility and protection.Despite years of research, no general solution for page replacement has emerged,the tradeoffs have not been quantified, and no general guidelines exist. Similarly,despite years of research on virtual memory systems, no demand paging algorithms ex-ist that work well for small memories. Fortunately, economics and technology havemade many of the problems associated with memory management irrelevant: DRAMchip density increased rapidly, making huge memories inexpensive. As a result, com-puter vendors avoid memory management altogether by making the memory on each new product much larger than the memory on the previous product. Because memory is so large, the operating system can satisfy the needs of a process without taking frames from other processes. That is, a demand paging system works well not because we have devised excellent replacement algorithms, but because memories have grown so large that replacement algorithms are seldom invoked.10.16 SummaryLow-level memory allocation mechanisms treat all of free memory as a single, ex-haustible resource. High-level memory management facilities that allow memory to be partitioned into separate regions provide guarantees that prevent one subsystem from us-ing all available memory.The high-level memory management functions in Xinu use a buffer pool paradigmin which a fixed set of buffers is allocated in each pool. Once a pool has been created,a group of processes can allocate and free buffers dynamically. The buffer pool inter-face is synchronous: a given process will block until a buffer becomes available.Large operating systems use virtual memory mechanisms to allocate a separate ad-dress space for each process. The most popular virtual memory mechanism, paging, divides the address space into fixed-size pages, and loads pages on demand. Hardware is needed to support paging because each memory reference must be mapped from a virtual address to a corresponding physical address. Paging systems only perform satis-factorily if memory is large enough to avoid running the page replacement algorithm frequently.192 High-level Memory Management and Virtual Memory Chap. 10EXERCISES10.1  Design a new getmem that subsumes getbuf. Hint: allow the user to suballocate from apreviously allocated block of memory.10.2  Mkbufpool forms a linked list of all buffers in a pool. Explain how to modify the codeso it allocates memory but does not link buffers together until a call to getbuf requires anew buffer to be allocated.10.3  Is freebufmore efficient than freemem? Justify your answer.10.4 Revise the buffer pool allocation mechanism to allow deallocation of buffer pools.10.5 The current implementation of buffer pools hides a pool ID in memory just prior to thebuffer. Rewrite freebuf to eliminate the need for a pool ID. Ensure your version of freebuf will detect an invalid address (i.e., will not return a buffer to a pool unless the buffer was previously allocated from the pool).10.6 Consider a modification of the buffer pool mechanism in which mkbufpool stores thepool ID in the first four bytes of a buffer and then uses the next four bytes in the bufferto store a pointer when linking the buffer onto a free list. What are the advantages ofsuch an approach?10.7  Suppose a processor has support for paging. Describe paging hardware that can be usedto protect a process’s stack from access by other processes, even if demand paging is not implemented (i.e., all pages remain resident and no replacement is performed).10.8 Implement the scheme devised in the previous exercise to protect stacks in Xinu.10.9 Build a demand paging version of Xinu.10.10 Sketch the data structures an operating system needs to maintain for demand paging.Hint: think of a page replacement algorithm, such as global clock.Chapter Contents11.1 Introduction, 19511.2 Inter–process Communication Ports, 19511.3 The Implementation Of Ports, 19611.4 Port Table Initialization, 19711.5 Port Creation, 19911.6 Sending A Message To A Port, 20011.7 Receiving A Message From A Port, 20211.8 Port Deletion And Reset, 20411.9 Perspective, 20711.10 Summary, 20711High-level Message Passing
I’m always uneasy with messages.— Neil Tennant11.1 IntroductionChapter 8 describes a low-level message passing facility that permits a process to pass a message directly to another process. Although it provides a useful function, the low-level message passing system cannot be used to coordinate multiple receivers, nor can a given process participate in several message exchanges without interference among them.This chapter completes the discussion of message passing by introducing a high-level facility that provides a synchronous interface for buffered message exchange. The message mechanism allows an arbitrary subset of processes to pass messages without affecting other processes. It introduces the concept of named rendezvous points that ex-ist independent of processes. The implementation uses the buffer pool mechanism from the previous chapter.11.2 Inter–process Communication PortsXinu uses the term inter-process communication port to refer to a rendezvous point through which processes can exchange messages. Message passing through ports differs from process-to-process message passing described in Chapter 8 because ports195196 High-level Message Passing Chap. 11allow multiple outstanding messages, allow multiple processes to receive from a port,and processes sending or receiving messages are blocked until requests can be satisfied. Each port is configured to hold up to a specified number of messages; each message oc-cupies a 32-bit word. Once it has produced a message, a process can use function ptsend to send the message to a port. Messages are deposited in a port in FIFO order. Once a message has been sent, the sending process can continue to execute. At any time, a process can call function ptrecv to receive the next message from a port.Both message sending and receiving are synchronous. As long as space remains ina port, a sender can deposit a message with no delay. Once a port becomes full, how-ever, an additional sending process will be blocked until a message has been removedand space becomes available. Similarly, if a process tries to receive a message from an empty port, the process will be blocked until a message arrives. Requests are also han-dled in FIFO order. For example, if multiple processes are waiting on an empty port, the process that has been waiting the longest will receive the message. Similarly, if multiple processes are blocked waiting to send, the process that has been waiting the longest is allowed to proceed when a space becomes available.11.3 The Implementation Of PortsEach port consists of a queue to hold messages and two semaphores. One of the semaphores controls producers, blocking any process that attempts to add messages to a full port. The other semaphore controls consumers, blocking any process that attempts to remove a message from an empty port.Because ports can be created dynamically, it is impossible to know the total count of items that will be enqueued at all ports at any given time. Although each message is small (one word), the total space required for port queues must be limited to prevent the port functions from using all the free space. To guarantee a limit on the total space used, the port functions allocate a fixed number of nodes to hold messages, and share the set among all ports. Initially, the message nodes are linked into a free list given by variable ptfree. Function ptsend removes a node from the free list, stores the message in the node, and adds the node to the queue associated with the port to which the mes-sage has been sent. Function ptrecv extracts the next message from a specified port, re-turns the node containing the message to the free list, and delivers the message to its caller.Structure ptnode in file ports.h defines the contents of a node that contains one message. A ptnode structure contains two fields: ptmsg holds a 32-bit message, and ptnext points to the next message.Structure ptentry defines the contents of an entry in the port table. Fields ptssem and ptrsem contain the IDs of semaphores that control sending and receiving. Field ptstate specifies whether the entry is currently being used, and field ptmaxcnt specifies the maximum messages that are allowed in the port at any time. Fields pthead and pttail point to the first node on the message list and the last, respectively. We will dis-cuss the sequence field, ptseq, later.Sec. 11.3        The Implementation Of Ports 197//**ppoorrttss..hh--iissbbaaddppoorrtt**//##ddeeffiinneeNNPPOORRTTSS3300//**MMaaxxiimmuummnnuummbbeerrooffppoorrttss**//##ddeeffiinneePPTT__MMSSGGSS110000//**TToottaallmmeessssaaggeessiinnssyysstteemm**//##ddeeffiinneePPTT__FFRREEEE11//**PPoorrttiissffrreeee**//##ddeeffiinneePPTT__LLIIMMBBOO22//**PPoorrttiissbbeeiinnggddeelleetteedd//rreesseett**//##ddeeffiinneePPTT__AALLLLOOCC33//**PPoorrttiissaallllooccaatteedd**//ssttrruuccttppttnnooddee{{//**NNooddeeoonnlliissttooffmmeessssaaggeess**//uuiinntt3322ppttmmssgg;;//**AAoonnee--wwoorrddmmeessssaaggee**//ssttrruuccttppttnnooddee**ppttnneexxtt;;//**PPooiinntteerrttoonneexxttnnooddeeoonnlliisstt**//}};;ssttrruuccttpptteennttrryy{{//**EEnnttrryyiinntthheeppoorrttttaabbllee**//ssiidd3322ppttsssseemm;;//**SSeennddeerrsseemmaapphhoorree**//ssiidd3322ppttrrsseemm;;//**RReecceeiivveerrsseemmaapphhoorree**//uuiinntt1166ppttssttaattee;;//**PPoorrttssttaattee((FFRREEEE//LLIIMMBBOO//AALLLLOOCC))**//uuiinntt1166ppttmmaaxxccnntt;;//**MMaaxxmmeessssaaggeessttoobbeeqquueeuueedd**//iinntt3322ppttsseeqq;;//**SSeeqquueenncceecchhaannggeeddaattccrreeaattiioonn**//ssttrruuccttppttnnooddee**pptthheeaadd;;//**LLiissttooffmmeessssaaggeeppooiinntteerrss**//ssttrruuccttppttnnooddee**ppttttaaiill;;//**TTaaiillooffmmeessssaaggeelliisstt**//}};;eexxtteerrnnssttrruuccttppttnnooddee**ppttffrreeee;;//**LLiissttooffffrreeeennooddeess**//eexxtteerrnnssttrruuccttpptteennttrryyppoorrttttaabb[[]];;//**PPoorrttttaabbllee**//eexxtteerrnniinntt3322ppttnneexxttiidd;;//**NNeexxttppoorrttIIDDttoottrryywwhheenn**////**llooookkiinnggffoorraaffrreeeesslloott**//##ddeeffiinneeiissbbaaddppoorrtt((ppoorrttiidd))((((ppoorrttiidd))<<00||||((ppoorrttiidd))>>==NNPPOORRTTSS))11.4 Port Table InitializationBecause initialization code is designed after basic operations have been implement-ed, we have been discussing initialization functions after other functions. In the case of ports, however, we will discuss initialization first, because doing so will make the remaining functions easier to understand. File ptinit.c contains the code to initialize ports and a declaration of the port table. Global variable ptnextid gives the index in ar-ray porttab at which the search will start when a new port is needed. Initialization con-sists of marking each port free, forming the linked list of free nodes, and initializing ptnextid. To create a free list, ptinit uses getmem to allocate a block of memory, and then moves through the memory, linking individual message nodes together to form a free list.198 High-level Message Passing Chap. 11//**ppttiinniitt..cc--ppttiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttppttnnooddee**ppttffrreeee;;//**LLiissttooffffrreeeemmeessssaaggeennooddeess**//ssttrruuccttpptteennttrryyppoorrttttaabb[[NNPPOORRTTSS]];;//**PPoorrttttaabbllee**//iinntt3322ppttnneexxttiidd;;//**NNeexxttttaabblleeeennttrryyttoottrryy**////**------------------------------------------------------------------------------------------------------------------------------------------------**ppttiinniitt--IInniittiiaalliizzeeaallllppoorrttss**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllppttiinniitt((iinntt3322mmaaxxmmssggss//**TToottaallmmeessssaaggeessiinnaallllppoorrttss**//)){{iinntt3322ii;;//**RRuunnsstthhrroouugghhtthheeppoorrttttaabbllee**//ssttrruuccttppttnnooddee**nneexxtt,,**ccuurrrr;;//**UUsseeddttoobbuuiillddaaffrreeeelliisstt**////**AAllllooccaatteemmeemmoorryyffoorraallllmmeessssaaggeessoonnaallllppoorrttss**//ppttffrreeee==((ssttrruuccttppttnnooddee**))ggeettmmeemm((mmaaxxmmssggss**ssiizzeeooff((ssttrruuccttppttnnooddee))));;iiff((ppttffrreeee====((ssttrruuccttppttnnooddee**))SSYYSSEERRRR)){{ppaanniicc((""ppiinniitt--iinnssuuffffiicciieennttmmeemmoorryy""));;}} //**IInniittiiaalliizzeeaallllppoorrttttaabblleeeennttrriieessttooffrreeee**//ffoorr((ii==00;;ii<<NNPPOORRTTSS;;ii++++)){{ppoorrttttaabb[[ii]]..ppttssttaattee==PPTT__FFRREEEE;;ppoorrttttaabb[[ii]]..ppttsseeqq==00;;}} ppttnneexxttiidd==00;;//**CCrreeaatteeaaffrreeeelliissttooffmmeessssaaggeennooddeesslliinnkkeeddttooggeetthheerr**//ffoorr((ccuurrrr==nneexxtt==ppttffrreeee;;----mmaaxxmmssggss>>00;;ccuurrrr==nneexxtt)){{ccuurrrr-->>ppttnneexxtt==++++nneexxtt;;}} //**SSeetttthheeppooiinntteerriinntthheeffiinnaallnnooddeettooNNUULLLL**//ccuurrrr-->>ppttnneexxtt==NNUULLLL;;rreettuurrnnOOKK;;}}Sec. 11.5        Port Creation19911.5 Port CreationPort creation consists of allocating an entry in the port table from among those thatare free. Function ptcreate performs the allocation and returns a port identifier (portID) to its caller.  Ptcreate takes an argument that specifies the maximum count of out-standing messages that the port will allow. Thus, when a port is created, the calling process can determine how many messages can be enqueued on the port before any sender blocks.//**ppttccrreeaattee..cc--ppttccrreeaattee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppttccrreeaattee--CCrreeaatteeaappoorrtttthhaattaalllloowwss""ccoouunntt""oouuttssttaannddiinnggmmeessssaaggeess**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllppttccrreeaattee((iinntt3322ccoouunntt//**SSiizzeeooffppoorrtt**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//iinntt3322ii;;//**CCoouunnttssaallllppoossssiibblleeppoorrttss**//iinntt3322ppttnnuumm;;//**CCaannddiiddaatteeppoorrttnnuummbbeerrttoottrryy**//ssttrruuccttpptteennttrryy**ppttppttrr;;//**PPooiinntteerrttooppoorrttttaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((ccoouunntt<<00)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ffoorr((ii==00;;ii<<NNPPOORRTTSS;;ii++++)){{//**CCoouunnttaallllttaabblleeeennttrriieess**//ppttnnuumm==ppttnneexxttiidd;;//**GGeettaanneennttrryyttoocchheecckk**//iiff((++++ppttnneexxttiidd>>==NNPPOORRTTSS)){{ppttnneexxttiidd==00;;//**RReesseettffoorrnneexxttiitteerraattiioonn**//}} //**CChheecckkttaabblleeeennttrryytthhaattccoorrrreessppoonnddssttooIIDDppttnnuumm**//ppttppttrr==&&ppoorrttttaabb[[ppttnnuumm]];;iiff((ppttppttrr-->>ppttssttaattee====PPTT__FFRREEEE)){{ppttppttrr-->>ppttssttaattee==PPTT__AALLLLOOCC;;ppttppttrr-->>ppttsssseemm==sseemmccrreeaattee((ccoouunntt));;200 High-level Message Passing Chap. 11ppttppttrr-->>ppttrrsseemm==sseemmccrreeaattee((00));;ppttppttrr-->>pptthheeaadd==ppttppttrr-->>ppttttaaiill==NNUULLLL;;ppttppttrr-->>ppttsseeqq++++;;ppttppttrr-->>ppttmmaaxxccnntt==ccoouunntt;;rreessttoorree((mmaasskk));;rreettuurrnnppttnnuumm;;}}}} rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}11.6 Sending A Message To A PortThe basic operations on ports, sending and receiving messages, are handled by functions ptsend and ptrecv. Each requires the caller to specify the port on which the operation is to be performed by passing a port ID as an argument. Function ptsend adds a message to those that are waiting at the port. It waits for space in the port, enqueues the message given by its argument, signals the receiver semaphore to indicate another message is available, and returns. The code is found in file ptsend.c://**ppttsseenndd..cc--ppttsseenndd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppttsseenndd--SSeennddaammeessssaaggeettooaappoorrttbbyyaaddddiinnggiittttootthheeqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllppttsseenndd((iinntt3322ppoorrttiidd,,//**IIDDooffppoorrttttoouussee**//uummssgg3322mmssgg//**MMeessssaaggeettoosseenndd**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpptteennttrryy**ppttppttrr;;//**PPooiinntteerrttoottaabblleeeennttrryy**//iinntt3322sseeqq;;//**LLooccaallccooppyyooffsseeqquueenncceennuumm..**//ssttrruuccttppttnnooddee**mmssggnnooddee;;//**AAllllooccaatteeddmmeessssaaggeennooddee**//ssttrruuccttppttnnooddee**ttaaiillnnooddee;;//**LLaassttnnooddeeiinnppoorrttoorrNNUULLLL**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppoorrtt((ppoorrttiidd))||||((ppttppttrr==&&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee!!==PPTT__AALLLLOOCC)){{Sec. 11.6        Sending A Message To A Port 201rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**WWaaiittffoorrssppaacceeaannddvveerriiffyyppoorrtthhaassnnoottbbeeeennrreesseett**//sseeqq==ppttppttrr-->>ppttsseeqq;;//**RReeccoorrddoorriiggnnaallsseeqquueennccee**//iiff((wwaaiitt((ppttppttrr-->>ppttsssseemm))====SSYYSSEERRRR||||ppttppttrr-->>ppttssttaattee!!==PPTT__AALLLLOOCC||||ppttppttrr-->>ppttsseeqq!!==sseeqq)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} iiff((ppttffrreeee====NNUULLLL)){{ppaanniicc((""PPoorrttssyysstteemmrraannoouuttooffmmeessssaaggeennooddeess""));;}} //**OObbttaaiinnnnooddeeffrroommffrreeeelliissttbbyyuunnlliinnkkiinngg**//mmssggnnooddee==ppttffrreeee;;//**PPooiinnttttooffiirrssttffrreeeennooddee**//ppttffrreeee==mmssggnnooddee-->>ppttnneexxtt;;//**UUnnlliinnkkffrroommtthheeffrreeeelliisstt**//mmssggnnooddee-->>ppttnneexxtt==NNUULLLL;;//**SSeettffiieellddssiinntthheennooddee**//mmssggnnooddee-->>ppttmmssgg==mmssgg;;//**LLiinnkkiinnttooqquueeuueeffoorrtthheessppeecciiffiieeddppoorrtt**//ttaaiillnnooddee==ppttppttrr-->>ppttttaaiill;;iiff((ttaaiillnnooddee====NNUULLLL)){{//**QQuueeuueeffoorrppoorrttwwaasseemmppttyy**//ppttppttrr-->>ppttttaaiill==ppttppttrr-->>pptthheeaadd==mmssggnnooddee;;}}eellssee{{//**IInnsseerrttnneewwnnooddeeaattttaaiill**//ttaaiillnnooddee-->>ppttnneexxtt==mmssggnnooddee;;ppttppttrr-->>ppttttaaiill==mmssggnnooddee;;}} ssiiggnnaall((ppttppttrr-->>ppttrrsseemm));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}The initial code in ptsend merely verifies that argument portid specifies a valid port ID. What happens next is more interesting.  Ptsend makes a local copy of the se-quence number, ptseq, and then processes the request. It waits on the sender sema-phore, and then verifies that the port is still allocated and that the sequence number agrees. It may seem odd that ptsend verifies the port ID a second time. However, if the port is already full when ptsend runs, the calling process can be blocked. Further-202 High-level Message Passing Chap. 11more, while the process is blocked waiting to send, the port may be deleted (and even recreated). To understand how the sequence number helps, recall that ptcreate incre-ments the sequence number when a port is created. The idea is to have waiting processes verify that the wait did not terminate because the port was deleted. If it did, the port will either remain unused or the sequence number will be incremented. Thus, the code following the call to wait verifies that the original port remains allocated.The implementation of ptsend enqueues messages in FIFO order. It relies on pttail to point to the last node on the queue if the queue is nonempty. Furthermore, ptsend al-ways makes pttail point to a new node after the node has been added to the list. Final-ly, ptsend signals the receiver semaphore after the new message has been added to the queue, allowing a receiver to consume the message.As in earlier code, an invariant helps a programmer understand the implementation.The invariant states:Semaphore ptrsem has a nonnegative count n if n messages are wait-ing in the port; it has negative count –n if n processes are waiting for messages.The call to panic also deserves comment because this is its first occurrence. In our design, running out of message nodes is a catastrophe from which the system cannot re-cover. It means that the arbitrary limit on message nodes, set to prevent ports from us-ing all the free memory, is insufficient. Perhaps the processes using ports are perform-ing incorrectly. Perhaps the request is valid, but the message limit was set too low; there is no way to know. Under such circumstances it is often better to announce failure and stop rather than attempt to go on. In our system, panic handles such situa-tions by printing the specified error message and halting the processor. Panic could be changed to reboot the entire system. (The exercises suggest alternative ways of han-dling the problem.)11.7 Receiving A Message From A PortFunction ptrecv implements a basic consumer operation. It removes a messagefrom a specified port and returns the message to its caller. The code is found in fileptrecv.c://**ppttrreeccvv..cc--ppttrreeccvv**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppttrreeccvv--RReecceeiivveeaammeessssaaggeeffrroommaappoorrtt,,bblloocckkiinnggiiffppoorrtteemmppttyy**------------------------------------------------------------------------------------------------------------------------------------------------Sec. 11.7        Receiving A Message From A Port 203**//uuiinntt3322ppttrreeccvv((iinntt3322ppoorrttiidd//**IIDDooffppoorrttttoouussee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpptteennttrryy**ppttppttrr;;//**PPooiinntteerrttoottaabblleeeennttrryy**//iinntt3322sseeqq;;//**LLooccaallccooppyyooffsseeqquueenncceennuumm..**//uummssgg3322mmssgg;;//**MMeessssaaggeettoorreettuurrnn**//ssttrruuccttppttnnooddee**mmssggnnooddee;;//**FFiirrssttnnooddeeoonnmmeessssaaggeelliisstt**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppoorrtt((ppoorrttiidd))||||((ppttppttrr==&&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee!!==PPTT__AALLLLOOCC)){{rreessttoorree((mmaasskk));;rreettuurrnn((uuiinntt3322))SSYYSSEERRRR;;}} //**WWaaiittffoorrmmeessssaaggeeaannddvveerriiffyytthhaatttthheeppoorrttiissssttiillllaallllooccaatteedd**//sseeqq==ppttppttrr-->>ppttsseeqq;;//**RReeccoorrddoorriiggnnaallsseeqquueennccee**//iiff((wwaaiitt((ppttppttrr-->>ppttrrsseemm))====SSYYSSEERRRR||||ppttppttrr-->>ppttssttaattee!!==PPTT__AALLLLOOCC||||ppttppttrr-->>ppttsseeqq!!==sseeqq)){{rreessttoorree((mmaasskk));;rreettuurrnn((uuiinntt3322))SSYYSSEERRRR;;}} //**DDeeqquueeuueeffiirrssttmmeessssaaggeetthhaattiisswwaaiittiinnggiinntthheeppoorrtt**//mmssggnnooddee==ppttppttrr-->>pptthheeaadd;;mmssgg==mmssggnnooddee-->>ppttmmssgg;;iiff((ppttppttrr-->>pptthheeaadd====ppttppttrr-->>ppttttaaiill))//**DDeelleetteellaassttiitteemm**//ppttppttrr-->>pptthheeaadd==ppttppttrr-->>ppttttaaiill==NNUULLLL;;eellsseeppttppttrr-->>pptthheeaadd==mmssggnnooddee-->>ppttnneexxtt;;mmssggnnooddee-->>ppttnneexxtt==ppttffrreeee;;//**RReettuurrnnttooffrreeeelliisstt**//ppttffrreeee==mmssggnnooddee;;ssiiggnnaall((ppttppttrr-->>ppttsssseemm));;rreessttoorree((mmaasskk));;rreettuurrnnmmssgg;;}}Ptrecv checks its argument, waits until a message is available, verifies that the porthas not been deleted or reused, and dequeues the message node. It records the value of204 High-level Message Passing Chap. 11the message in local variable msg before returning the message node to the free list, and then returns the value to its caller.11.8 Port Deletion And ResetIt is sometimes useful to delete or to reset a port. In either case, the system must dispose of waiting messages (if the port contains messages), return message nodes tothe free list, and permit waiting processes to continue execution. How should the port system dispose of waiting messages? It could choose to throw them away, or to return them to the processes that sent them. To permit maximum flexibility, our design does not make a choice. Instead, it permits a caller to specify how to dispose of messages. Functions ptdelete and ptreset perform port deletion and reset operations. Each function takes an argument that specifies a function to be called to dispose of each waiting mes-sage. The code is found in files ptdelete.c and ptreset.c://**ppttddeelleettee..cc--ppttddeelleettee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppttddeelleettee--DDeelleetteeaappoorrtt,,ffrreeeeiinnggwwaaiittiinnggpprroocceesssseessaannddmmeessssaaggeess**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllppttddeelleettee((iinntt3322ppoorrttiidd,,//**IIDDooffppoorrttttooddeelleettee**//iinntt3322((**ddiisspp))((iinntt3322))//**FFuunnccttiioonnttooccaallllttooddiissppoossee**//))//**ooffwwaaiittiinnggmmeessssaaggeess**//{{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpptteennttrryy**ppttppttrr;;//**PPooiinntteerrttooppoorrttttaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppoorrtt((ppoorrttiidd))||||((ppttppttrr==&&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee!!==PPTT__AALLLLOOCC)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} __ppttcclleeaarr((ppttppttrr,,PPTT__FFRREEEE,,ddiisspp));;ppttnneexxttiidd==ppoorrttiidd;;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Sec. 11.8        Port Deletion And Reset 205//**ppttrreesseett..cc--ppttrreesseett**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppttrreesseett--RReesseettaappoorrtt,,ffrreeeeiinnggwwaaiittiinnggpprroocceesssseessaannddmmeessssaaggeessaannddlleeaavviinnggtthheeppoorrttrreeaaddyyffoorrffuurrtthheerruussee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllppttrreesseett((iinntt3322ppoorrttiidd,,//**IIDDooffppoorrttttoorreesseett**//iinntt3322((**ddiisspp))((iinntt3322))//**FFuunnccttiioonnttooccaallllttooddiissppoossee**//))//**ooffwwaaiittiinnggmmeessssaaggeess**//{{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpptteennttrryy**ppttppttrr;;//**PPooiinntteerrttooppoorrttttaabblleeeennttrryy**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppoorrtt((ppoorrttiidd))||||((ppttppttrr==&&ppoorrttttaabb[[ppoorrttiidd]]))-->>ppttssttaattee!!==PPTT__AALLLLOOCC)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} __ppttcclleeaarr((ppttppttrr,,PPTT__AALLLLOOCC,,ddiisspp));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Both ptdelete and ptreset verify that their arguments are correct, and then call _ptclear to perform the work of clearing messages and waiting processes.† The dispo-sal function can cause a context switch, which means other processes can run and use ports. Therefore, while it proceeds to clear a port, _ptclear places the port in a “limbo”state (PT_LIMBO). The limbo state guarantees that no other processes can use the port — functions ptsend and ptrecv will refuse to operate on a port that is not allocated, and pcreate will not allocate the port unless it is free. Thus, even if the disposal function switches context, no problems will occur.Before declaring a port eligible for use again, _ptclear calls dispose repeatedly, passing it each waiting message. Finally, after all messages have been removed, _ptclear deletes or resets the semaphores as specified by its second argument. Before disposing of messages, _ptclear increments the port sequence number so that waiting processes can tell that the port has changed when they awaken. The code is found in file ptclear.c:†The name _ptclear begins with an underscore to indicate that the function is internal to the system andis not intended to be called by an application process (i.e., is not part of the system’s API).206 High-level Message Passing Chap. 11//**ppttcclleeaarr..cc--__ppttcclleeaarr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**__ppttcclleeaarr--UUsseeddbbyyppttddeelleetteeaannddppttrreesseettttoocclleeaarroorrrreesseettaappoorrtt**((iinntteerrnnaallffuunnccttiioonnaassssuummeessiinntteerrrruuppttssddiissaabblleeddaanndd**aarrgguummeennttsshhaavveebbeeeenncchheecckkeeddffoorrvvaalliiddiittyy))**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiidd__ppttcclleeaarr((ssttrruuccttpptteennttrryy**ppttppttrr,,//**TTaabblleeeennttrryyttoocclleeaarr**//uuiinntt1166nneewwssttaattee,,//**NNeewwssttaatteeffoorrppoorrtt**//iinntt3322((**ddiissppoossee))((iinntt3322))//**DDiissppoossaallffuunnccttiioonnttooccaallll**//)){{ssttrruuccttppttnnooddee**wwaallkk;;//**PPooiinntteerrttoowwaallkkmmeessssaaggeelliisstt**////**PPllaacceeppoorrttiinnlliimmbboossttaatteewwhhiilleewwaaiittiinnggpprroocceesssseessaarreeffrreeeedd**//ppttppttrr-->>ppttssttaattee==PPTT__LLIIMMBBOO;;ppttppttrr-->>ppttsseeqq++++;;//**RReesseettaacccceessssiioonnnnuummbbeerr**//wwaallkk==ppttppttrr-->>pptthheeaadd;;//**FFiirrssttiitteemmoonnmmssgglliisstt**//iiff((wwaallkk!!==NNUULLLL)){{//**IIffmmeessssaaggeelliissttnnoonneemmppttyy**////**WWaallkkmmeessssaaggeelliissttaannddddiissppoosseeooffeeaacchhmmeessssaaggee**//ffoorr((;;wwaallkk!!==NNUULLLL;;wwaallkk==wwaallkk-->>ppttnneexxtt)){{((**ddiissppoossee))((wwaallkk-->>ppttmmssgg));;}} //**LLiinnkkeennttiirreemmeessssaaggeelliissttiinnttootthheeffrreeeelliisstt**//((ppttppttrr-->>ppttttaaiill))-->>ppttnneexxtt==ppttffrreeee;;ppttffrreeee==ppttppttrr-->>pptthheeaadd;;}} iiff((nneewwssttaattee====PPTT__AALLLLOOCC)){{ppttppttrr-->>ppttttaaiill==ppttppttrr-->>pptthheeaadd==NNUULLLL;;sseemmrreesseett((ppttppttrr-->>ppttsssseemm,,ppttppttrr-->>ppttmmaaxxccnntt));;sseemmrreesseett((ppttppttrr-->>ppttrrsseemm,,00));;}}eellssee{{sseemmddeelleettee((ppttppttrr-->>ppttsssseemm));;Sec. 11.8        Port Deletion And Reset 207sseemmddeelleettee((ppttppttrr-->>ppttrrsseemm));;}} ppttppttrr-->>ppttssttaattee==nneewwssttaattee;;rreettuurrnn;;}}11.9 PerspectiveBecause it provides a synchronous interface, our port mechanism allows a process to wait for the next message to arrive. A synchronous interface can be powerful — a clever programmer can use the mechanism to coordinate processes (e.g., to implement mutual exclusion). Interestingly, the ability to coordinate processes also introduces a potential problem: deadlock. That is, a set of processes that uses ports to exchange messages can end up with all processes in the set blocked, waiting for a message to ar-rive with no processes left running to send a message. Therefore, a programmer using ports must be careful to guarantee that such deadlocks cannot occur.11.10 SummaryThe chapter introduces a high-level message passing mechanism, called communi-cation ports, that permits processes to exchange messages through rendezvous points. Each port consists of a fixed length queue of messages. Function ptsend deposits a message at the tail of the queue, and function ptrecv extracts an item from the head of the queue. Processes that attempt to receive from an empty port are blocked until a message arrives; processes that attempt to send to a full port are blocked until space be-comes available.EXERCISES11.1  Consider the primitives send—receive and ptsend—ptrecv. Is it possible to design a sin-gle message passing scheme that encompasses both? Explain.11.2     An important distinction is made between statically allocated and dynamically allocatedresources. For example, ports are dynamically allocated while inter-process messageslots are statically allocated. What is the key problem with dynamic allocation in amulti-process environment?11.3 Change the message node allocation scheme so that a semaphore controls nodes on thefree list. Have ptsend wait for a free node if none exists. What potential problems, ifany, does the new scheme introduce?11.4     Panic is used for conditions like internal inconsistency or potential deadlock. Often theconditions causing a panic are irreproducible, so their cause is difficult to pinpoint. Dis-cuss what you might do to trace the cause of the panic in ptsend.208 High-level Message Passing Chap. 1111.5 As alternatives to the call to panic in ptsend, consider allocating more nodes or retryingthe operation. What are the liabilities of each?11.6 Rewrite ptsend and ptrecv to return a special value when the port is deleted while theyare waiting. What is the chief disadvantage of the new mechanism?11.7      Modify the routines in previous chapters that allocate, use, and delete objects so they usesequence numbers to detect deletion as the communication port functions do.11.8 Ptsend and ptrecv cannot transmit a message with value equal to SYSERR because ptrecvcannot distinguish between a message with that value and an error. Redesign the func-tions to transmit any value.11.9 Although each call to ptcreate specifies a count of messages, the implementation doesnot check that the set of allocated message nodes is sufficient to handle all possible re-quests. Modify ptcreate to ensure that the sum of messages on all ports is less than PT_MSGS.11.10    If the previous exercise is implemented, what important change can be made to ptsend?Chapter Contents12.1 Introduction, 21112.2 The Advantage Of Interrupts, 21212.3 Interrupt Processing, 21212.4 Vectored Interrupts, 21312.5 Integration Of Interrupts And Exceptions, 21412.6 ARM Exception Vectors Using Code, 21512.7 Assignment Of Device Interrupt Vector Numbers, 21912.8 Interrupt Dispatching, 22012.9 The Structure Of Interrupt Software, 22112.10 Disabling Interrupts, 22312.11 Constraints On Functions That Interrupt Code Invokes, 225 12.12 The Need To Reschedule During An Interrupt, 22512.13 Rescheduling During An Interrupt, 226 12.14 Perspective, 22712.15 Summary, 22812Interrupt Processing
The joy of music should never be interrupted by a commercial.— Leonard Bernstein12.1 IntroductionPrevious chapters focus on processor and memory management. The chapters on processor management introduce the concept of concurrent processing, show how processes are created and terminated, and describe how processes coordinate. The chapters on memory management illustrate low-level mechanisms used to manage dynamic allocation and the release of stack and heap storage.This chapter begins a discussion of input and output (I/O) facilities. The chapter reviews the concept of an interrupt, and introduces the overall software architecture that an operating system uses to handle interrupts. It describes how an operating system passes control to the appropriate interrupt handler software when an interrupt occurs. More important, the chapter explains the complex relationship between interrupts and the operating system abstraction of concurrent processes, and gives general guidelines that interrupt code must follow to provide a correct and safe implementation of con-current processes in the presence of interrupts. Later chapters continue the discussion by examining specific devices, including a real-time clock that enables preemptive proc-ess scheduling. The chapters explain how interrupt handler software forms part of a driver.211212 Interrupt Processing Chap. 1212.2 The Advantage Of InterruptsThe interrupt mechanism invented for third-generation computer systems providesa powerful facility that separates I/O activities from processing. Many of the servicesan operating system offers would not be possible without hardware that supports inter-rupts.The motivation for an interrupt mechanism arises from the observation that I/O hardware can function in parallel with processing. Instead of relying on the processor to provide complete control over I/O, each I/O device contains hardware that can operate independently. The processor only needs to start or stop a device — once start-ed, a device proceeds to transfer data without further help. Because most I/O proceeds much slower than computation, the processor can start multiple devices and allow the operations to proceed in parallel. After starting I/O, the processor can perform other computation (i.e., execute a process) until a device interrupts to signal completion. The key idea is:An interrupt mechanism permits the processor and I/O devices to operate in parallel. Although the details differ, the hardware includes a mechanism that automatically “interrupts” normal processing and informs the operating system when a device completes an operation or needs attention.12.3 Interrupt ProcessingHardware in a processor performs three basic steps when an interrupt occurs:Set the hardware to prevent further interrupts from occurring whilean interrupt is being processedSave sufficient state to allow the processor to resume executiontransparently once the interrupt has been handledBranch to a predetermined memory location where the operatingsystem has placed code to process the interruptEach processor includes details that complicate interrupt processing. For example, when it saves state, the hardware in most systems does not save a complete copy of all processor registers. Instead, the hardware records a few basic values, such as a copy of the instruction pointer,† and requires the operating system to save any other registers that will be used during interrupt processing. To ensure that interrupt processing does not change any values visible to the process that was executing, the operating system must restore all the saved registers before returning to normal processing once the inter-rupt handling is complete.†The instruction pointer, sometimes called a program counter, contains the address of the instruction tobe executed next.Sec. 12.4        Vectored Interrupts 21312.4 Vectored InterruptsWhen an interrupt occurs, the operating system must have a way to identify which device caused the interrupt. A variety of hardware mechanisms have been invented that handle device identification. For example, on some systems, the processor uses the bus to ask the interrupting device to identify itself. On other systems, a separate controller unit handles communication with devices. Some designs use a separate co-processor in-stead of a controller. After considering other aspects of interrupt handling, we will see how the example platforms handle interrupts.How should a device identify itself? The most popular technique is known as a vectored interrupt. Each device is assigned a unique integer, 0, 1, 2, and so on. Using terminology that has become popular, the integer is called an Interrupt Request Number (IRQ). When an interrupt occurs, the device specifies its IRQ. A vectored interrupt mechanism helps make interrupt processing extremely efficient: the IRQ can be used as an index into an interrupt vector array. The operating system preloads each location in the interrupt vector with a pointer to a function that handles the interrupt. When a de-vice with IRQ i interrupts, control branches to:interrupt_vector[i]Figure 12.1 illustrates the conceptual organization of interrupt vectors as an array of pointers.. . .
code to handle device 0code to handle device 1code to handle device 2code to handle device 3code to handle device N –1
0123Figure 12.1The conceptual organization of interrupt vectors as an array ofpointers, where each entry gives the address of code that handles the interrupt for a specific device.214 Interrupt Processing Chap. 1212.5 Integration Of Interrupts And ExceptionsAlthough the vectored approach was invented to handle interrupts from I/O de-vices, the scheme has been extended to handle exceptions. That is, the vector can have additional slots that are devoted to handle error conditions, such as page faults, divide-by-zero errors, protection violations, illegal instructions, and illegal memory references. The processor hardware is constructed such that it generates an exception when an error occurs. In fact, exception processing is so fundamental that some platforms use the term exception vectorto refer to the array of pointers instead of the term interrupt vec-tor. The two example platforms illustrate two approaches vendors have used to com-bine exceptions and interrupts.12.5.1  Galileo (Intel)The Galileo uses a single, large vector that contains entries for both exceptions and device interrupts. The first entries in the array correspond to exceptions, and devicesare assigned IRQ values above the exceptions. For example, vector position zero is reserved for arithmetic division errors. When a program attempts to divide by zero, the hardware detects the problem and raises exception 0. In essence, the hardware behaves exactly as if an interrupt had occurred with IRQ 0 (i.e., the program counter is saved and control passes to the address given by interrupt_vector[0]). Similarly, if it en-counters an illegal opcode, the processor raises exception 5 exactly as if an interrupt had occurred with IRQ 5.12.5.2  BeagleBone Black (ARM)The BeagleBone Black uses a two-level approach. At the top level, the processor defines eight possible exceptions: Reset, Undefined instruction, Software interrupt, Pre-Fetch Abort, Data Abort, Unused, IRQ, and FIQ. All errors, such as divide-by-zero, are classified as one of the exceptions. Two of the exceptions (IRQ and FIQ) correspond to I/O device interrupts.† When a device generates an IRQ interrupt, the hardware raises an IRQ exception. The processor uses an exception vector to branch to the code that handles the exception. That is, all device interrupts follow the same ex-ception vector pointer. The code that handles the IRQ exception must interrogate the hardware, obtain the IRQ for the interrupting device, and then use a second level of in-direction to find the code that handles the specific device. The point is:Exceptions, such as divide-by-zero and page faults, follow a vectored approach. The Galileo illustrates how interrupts and exceptions are integrated into a single exception vector. The BeagleBone Black il-lustrates a two-level scheme in which device interrupts correspond to one particular exception and the operating system must use a second level of indirection to reach the handler for a specific device.†IRQ corresponds to a normal interrupt; FIQ can be used to optimize interrupt processing for devicehardware that does not need the processor to save as much state.Sec. 12.5        Integration Of Interrupts And Exceptions 21512.6 ARM Exception Vectors Using CodeThe ARM architecture adds one more wrinkle to exception vector processing: in-stead of containing pointers to handlers as the Intel architecture does, an ARM excep-tion vector contains instructions that the processor executes. When exception i occurs,the processor starts executing the code at:exception_vector[i]Each location in the exception vector is only one instruction long (i.e., four bytes), which means the instruction must branch to the code for the exception. The instructionin the exception vector for device interrupts jumps to the device dispatch code, the in-struction in the exception vector for software interrupts jumps to the software interrupt code, and so on.An operating system must initialize exception vectors, and may need to change the vectors later. Because ARM exception vectors contain code rather than data, changing the contents means creating an executable instruction, which can be dangerous. Toavoid modifying code at runtime, Xinu uses indirect branch instructions. That is, Xinu defines an additional array of pointers that is parallel to the exception vectors, and makes each exception vector contain an indirect jump instruction that references the corresponding location in the parallel array of pointers. Figure 12.2 illustrates the con-cept.exception vectors array of pointers
jump indirectjump indirectjump indirectjump indirectjump indirectjump indirectjump indirectjump indirect
code for exception 0code for exception 1code for exception 2code for exception 3code for exception 4code for exception 5code for exception 6code for exception 7
vector for exception 0vector for exception 1vector for exception 2vector for exception 3vector for exception 4vector for exception 5vector for exception 6vector for exception 7
Figure 12.2An ARM exception vector with instructions that each jump in-directly through an item in an array of pointers.Using an extra array has both a practical and conceptual advantage. It is practical because the operating system only needs to change a pointer to change the function as-sociated with a given exception; there is no need to create executable instructions at runtime. The conceptual advantage should also be clear: the scheme makes the ARM exception mechanism match the model presented in Figure 12.1 on page 213.216 Interrupt Processing Chap. 12How is the parallel array mechanism from Figure 12.2 implemented? Because a normal jump instruction takes two words, Xinu places the parallel array immediately after the exception vectors, and uses PC-relative addressing, which makes the jump fitinto a single word. More important, because the ith  location of the parallel array is a constant distance from the ith exception vector, every exception vector location contains the same offset in the jump instruction.† Figure 12.3 illustrates the implementation.
exception vectors array of pointersEach vector contains ldr pc, [pc #24]Figure 12.3ARM exception vectors and an indirect array are contiguous inmemory.Function initevec near the end of file intr.S assigns the relative jump instruction to locations in the exception vector, assigns the address of a default exception handler to each position in the parallel array, and then changes the pointer associated with IRQs to point to the IRQ exception hander, irq_except.//**iinnttrr..SS--eennaabbllee,,ddiissaabbllee,,rreessttoorree,,hhaalltt,,ppaauussee,,iirrqq__eexxcceepptt((AARRMM))**//##iinncclluuddee<<aarrmmvv77aa..hh>>..tteexxtt..gglloobbllddiissaabbllee..gglloobbllrreessttoorree..gglloobblleennaabbllee..gglloobbllppaauussee..gglloobbllhhaalltt..gglloobblliirrqq__eexxcceepptt..gglloobblliirrqq__ddiissppaattcchh..gglloobblliinniitteevveecc..gglloobblleexxppjjmmppiinnssttrr//**------------------------------------------------------------------------------------------------------------------------------------------------**ddiissaabbllee--DDiissaabblleeiinntteerrrruuppttssaannddrreettuurrnntthheepprreevviioouussssttaattee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddiissaabbllee::mmrrssrr00,,ccppssrr//**CCooppyytthheeCCPPSSRRiinnttoorr00**//ccppssiiddii//**DDiissaabblleeiinntteerrrruuppttss**//mmoovvppcc,,llrr//**RReettuurrnntthheeCCPPSSRR**//†The offset in the indirect jump is 24 bytes instead of 32 bytes because the program counter points twowords beyond the instruction being executed.Sec. 12.6        ARM Exception Vectors Using Code 217//**------------------------------------------------------------------------------------------------------------------------------------------------**rreessttoorree--RReessttoorreeiinntteerrrruuppttssttoovvaalluueeggiivveennbbyymmaasskkaarrgguummeenntt**------------------------------------------------------------------------------------------------------------------------------------------------**//rreessttoorree::ppuusshh{{rr11,,rr22}}//**SSaavveerr11,,rr22oonnssttaacckk**//mmrrssrr11,,ccppssrr//**CCooppyyCCPPSSRRiinnttoorr11**//llddrrrr22,,==00xx0011FF0000222200aannddrr11,,rr11,,rr22//**EExxttrraaccttffllaaggssaannddootthheerriimmppoorrttaanntt**//bbiiccrr00,,rr00,,rr22//**bbiittssffrroommtthheemmaasskk**//oorrrrrr11,,rr11,,rr00mmssrrccppssrr__ccffssxx,,rr11//**RReessttoorreetthheeCCPPSSRR**//ppoopp{{rr11,,rr22}}//**RReessttoorreerr11,,rr22**//mmoovvppcc,,llrr//**RReettuurrnnttooccaalllleerr**////**------------------------------------------------------------------------------------------------------------------------------------------------**eennaabbllee--EEnnaabblleeiinntteerrrruuppttss**------------------------------------------------------------------------------------------------------------------------------------------------**//eennaabbllee::ccppssiieeii//**EEnnaabblleeiinntteerrrruuppttss**//mmoovvppcc,,llrr//**RReettuurrnn**////**------------------------------------------------------------------------------------------------------------------------------------------------**ppaauusseeoorrhhaalltt--PPllaacceetthheepprroocceessssoorriinnaahhaarrddlloooopp**------------------------------------------------------------------------------------------------------------------------------------------------**//hhaalltt::ppaauussee::ccppssiiddii//**DDiissaabblleeiinntteerrrruuppttss**//ddlloooopp::bbddlloooopp//**DDeeaaddlloooopp**////**------------------------------------------------------------------------------------------------------------------------------------------------**iirrqq__eexxcceepptt--DDiissppaattcchhaannIIRRQQeexxcceeppttiioonnttoohhiigghheerrlleevveellIIRRQQddiissppaattcchheerr**------------------------------------------------------------------------------------------------------------------------------------------------**//iirrqq__eexxcceepptt::ssuubbllrr,,llrr,,##44//**CCoorrrreecctttthheerreettuurrnnaaddddrreessss**//ssrrssddbbsspp!!,,##1199//**SSaavveerreettuurrnnssttaatteeoonntthheessuuppeerrvviissoorr**////**mmooddeessttaacckk**//ccppss##1199//**CChhaannggeettoossuuppeerrvviissoorrmmooddee**//ppuusshh{{rr00--rr1122,,llrr}}//**SSaavveeaallllrreeggiisstteerrss**//bblliirrqq__ddiissppaattcchh//**CCaallllIIRRQQddiissppaattcchh**//ppoopp{{rr00--rr1122,,llrr}}//**RReessttoorreeaallllrreeggiisstteerrss**//rrffeeiiaasspp!!//**RReettuurrnnffrroommtthheeeexxcceeppttiioonnuussiinnggiinnffoo**////**ssttoorreeddoonntthheessttaacckk**//218 Interrupt Processing Chap. 12//**------------------------------------------------------------------------------------------------------------------------------------------------**ddeeffeexxpp__hhaannddlleerr--DDeeffaauullttEExxcceeppttiioonnhhaannddlleerr**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeeffeexxpp__hhaannddlleerr::llddrrrr00,,==eexxppmmssgg11mmoovvrr11,,llrrbbllkkpprriinnttffllddrrrr00,,==eexxppmmssgg22bbllppaanniicc//**------------------------------------------------------------------------------------------------------------------------------------------------**iinniitteevveecc--IInniittiiaalliizzeetthheeeexxcceeppttiioonnvveeccttoorr**------------------------------------------------------------------------------------------------------------------------------------------------**//iinniitteevveecc:: mmrrccpp1155,,00,,rr00,,cc11,,cc00,,00//**RReeaaddtthheecc11--ccoonnttrroollrreeggiisstteerr**//bbiiccrr00,,rr00,,##AARRMMVV77AA__CC11CCTTLL__VV//**VVbbiitt==00,,nnoorrmmaalleexxpp..bbaassee**//mmccrrpp1155,,00,,rr00,,cc11,,cc00,,00//**WWrriitteetthheecc11--ccoonnttrroollrreeggiisstteerr**//llddrrrr00,,==AARRMMVV77AA__EEVV__SSTTAARRTT//**EExxcceeppttiioonnbbaasseeaaddddrreessss**//mmccrrpp1155,,00,,rr00,,cc1122,,cc00,,00//**SSttoorreeeexxccpp..bbaasseeaaddddrr..iinncc1122**//llddrrrr00,,==AARRMMVV77AA__EEVV__SSTTAARRTT//**SSttaarrttaaddddrreessssooffeexxpp..vveeccttoorr**//llddrrrr11,,==AARRMMVV77AA__EEVV__EENNDD//**EEnnddaaddddrreessssooffeexxpp..vveeccttoorr**//llddrrrr22,,==eexxppjjmmppiinnssttrr//**CCooppyytthheeeexxppjjuummppiinnssttrr**//llddrrrr22,,[[rr22]]//**iinnttoorreeggiisstteerrrr22**//eexxppvveecc::ssttrrrr22,,[[rr00]]//**SSttoorreetthheejjuummppiinnssttrruuccttiioonn**//aaddddrr00,,rr00,,##44//**iinntthheeeexxcceeppttiioonnvveeccttoorr**//ccmmpprr00,,rr11bbnneeeexxppvveeccllddrrrr00,,==AARRMMVV77AA__EEHH__SSTTAARRTT//**IInnssttaalllltthheeddeeffaauulltteexxcceeppttiioonn**//llddrrrr11,,==AARRMMVV77AA__EEHH__EENNDD//**hhaannddlleerrffoorraalllleexxcceeppttiioonnss**//llddrrrr22,,==ddeeffeexxpp__hhaannddlleerreexxpphhnndd::ssttrrrr22,,[[rr00]]aaddddrr00,,rr00,,##44ccmmpprr00,,rr11bbnneeeexxpphhnnddllddrrrr00,,==AARRMMVV77AA__IIRRQQHH__AADDDDRR//**IInnssttaalllltthheeIIRRQQhhaannddlleerrttoo**//llddrrrr11,,==iirrqq__eexxcceepptt//**oovveerrrriiddeetthheeddeeffaauulltt**//ssttrrrr11,,[[rr00]]//**eexxcceeppttiioonnhhaannddlleerr**//mmoovvppcc,,llrr//**------------------------------------------------------------------------------------------------------------------------------------------------**eexxppjjmmppiinnssttrr--AAPPCCrreellaattiivveejjuummppiinnssttrruuccttiioonn,,ccooppiieeddiinnttooeexxpp..vveeccttoorr**------------------------------------------------------------------------------------------------------------------------------------------------**//Sec. 12.6        ARM Exception Vectors Using Code 219eexxppjjmmppiinnssttrr::llddrrppcc,,[[ppcc,,##2244]]The last statement of the file is the relative jump instruction. We use the assem-bler to create the instruction, which is both easier to read and less prone to errors than defining a constant.12.7 Assignment Of Device Interrupt Vector NumbersThe position of exceptions in an exception vector are chosen when a system is designed and never change. For example, we said that the Galileo hardware is built soan illegal instruction error always raises exception 5. On the BeagleBone Black, an ille-gal instruction raises exception 6. However, IRQ values cannot be preassigned unless the set of devices is fixed when the hardware is built (e.g., an SoC that has three de-vices). To understand why, observe that most computer systems allow an owner to pur-chase and install new device hardware. To accommodate an arbitrary set of devices, three basic approaches have been used for IRQ assignment:Manual device configurationAutomated assignment during bootstrapDynamic assignment for pluggable devicesManual device configuration. On early hardware, a human had to assign a unique IRQ to each device before the device was connected to a computer. Typically, the as-signment was made using switches or wire jumpers on the device circuit board. Once an assignment was made to the hardware, the operating system had to be configured to match the hardware. Manual assignment had the problems of being tedious and error-prone — if a human accidentally assigned the same IRQ to two different devices, or the vector number configured into the operating system did not match the IRQ value con-figured into device hardware, devices would fail to operate correctly.Automated assignment during bootstrap. As bus hardware became more sophisti-cated, techniques were developed that automated interrupt vector assignments. Au-tomated assignment requires programmable devices. That is, the operating system uses the bus to find devices that are attached to the bus, and assigns each device an IRQ. In essence, programmable devices allow the paradigm to be reversed: instead of assigning an IRQ to a device and then configuring the operating system to match the assignment, programmable devices allow the operating system to choose an IRQ and then assign the number to the device. Because the operating system handles assignment when a com-puter boots, the automated approach eliminates human error, and makes it possible for users to attach new hardware to their computer without understanding IRQ assignment.Dynamic assignment for pluggable devices. A final approach is used to accommo-date devices that can be plugged into a computer while the operating system is running.220 Interrupt Processing Chap. 12For example, consider a Universal Serial Bus (USB) that allows devices to be connected or disconnected at runtime. A USB uses two levels of interrupt binding. At the first level, a computer contains a USB host controller device that attaches to the computer’s bus. When it boots, the operating system recognizes the host controller, and assigns it a unique IRQ value using the same automated assignment used for other devices. The operating system configures a device driver for the USB host controller, and the driver includes a function that handles interrupts. We will use the term master driver to describe the software that handles USB host controller interrupts.At runtime, when a user plugs a device into a USB port, a second level binding oc-curs. The USB controller hardware detects the new device, and generates an interrupt.The master driver receives control, and communicates across the USB to obtain the type and model of the new device. The master dynamically loads a driver for the new de-vice, and records the driver location. Later, when the USB device interrupts, the master obtains control, determines which of the devices plugged into the USB generated the in-terrupt, and forwards control to the appropriate driver. Finally, when a user disconnects a USB device, the master receives an interrupt, determines which device has been un-plugged, and removes its record of the device.12.8 Interrupt DispatchingSeveral questions arise about the design of an interrupt and/or exception mecha-nism. How large is an interrupt or exception vector? Does an entry in a vector contain more than the address of a handler? Where is the vector stored? Does the hardware or operating system perform indexing? A variety of designs have been used. Most sys-tems choose a maximum size for the vector. Some systems place the vector at a fixed location in memory; a slightly more advanced design allows the operating system to choose a memory location and then inform the hardware.We use the term interrupt dispatching to refer to the steps that are taken to obtaina device number, use the device number as an index into a vector, extract the address ofa handler, and pass control to the handler. To make dispatching efficient and toseparate I/O details from the processor, many systems use a special-purpose hardware device known as an interrupt controller.†The example platforms illustrate two types of interrupt controllers. The controller used on the BeagleBone Black handles communication over the bus, but does not store interrupt vectors. Instead, when an interrupt occurs, the controller obtains an integer IRQ from the device, raises an IRQ exception, and passes the IRQ value to the proces-sor. The operating system manages the interrupt vectors, and performs the steps of us-ing the IRQ as an index into the interrupt vector and passing control to the appropriate handler. The interrupt controller for the Galileo stores the entire interrupt vector. When a device interrupts, the controller obtains the IRQ, uses the IRQ as an index into the interrupt vector array, and calls the appropriate handler. On the Galileo, the operat-ing system must load the vector into the controller at startup, before any interrupts or exceptions occur. The point is:†In a traditional computer design, an interrupt controller consists of a separate chip; in an SoC design, thecontroller is physically located on the SoC, but remains external to the processor.Sec. 12.8        Interrupt Dispatching 221Most systems use external interrupt controller hardware. The designof the controller determines which steps of interrupt dispatching are handled by the hardware and which steps are handled by the operat-ing system.12.9 The Structure Of Interrupt SoftwareBecause interrupt dispatching involves saving and restoring hardware state,dispatch code must be written in assembly language. However, system designers preferto write device drivers, including interrupt handlers, in a high-level language, such as C. To accommodate the requirement for assembly language, we follow an approach used in most systems: interrupt code is divided into two parts: a low-level piece written in as-sembly language and a high-level piece written in C. We use the term dispatcher for the low-level piece and handler for the high-level piece. Figure 12.4 illustrates the con-cept.dispatcherhandlerhardware interruptFigure 12.4The conceptual division of interrupt code into a dispatcher writ-ten in assembly language and a handler written in C.As the sizes of items in the figure imply, a dispatcher is usually much smaller than a handler. In most systems, a dispatcher consists of a few lines of assembly language code. The dispatcher saves hardware state, usually by pushing copies of the general-purpose registers onto the stack, and calls the handler code. When the handler returns, the dispatcher restores the machine state (e.g., by popping registers off the stack), and then uses the special instruction that returns from the interrupt. Of course, the call to a handler must follow the standard C calling conventions. Therefore, on some architec-tures, the dispatcher includes a few extra instructions that set up the environment need-ed by a C function.12.9.1  Galileo (Intel)Recall that the Intel interrupt controller stores the interrupt and exception vectors,and invokes code associated with a specific exception or device. For example, whenthe Ethernet device interrupts, control passes to the Ethernet interrupt code, and whenthe serial console interrupts, control passes to the code that handles interrupts on theserial console.222 Interrupt Processing Chap. 12Interrupt controller hardware that invokes code for a specific device can save time because the operating system does not need to index interrupt vectors in memory. However, the design has a consequence for device driver software: a driver must in-clude low-level dispatch code. Our Galileo device drivers illustrate the organization: each driver has both a dispatch function (written in assembly language) and a handler function (written in C). Figure 12.5 illustrates the structure.H1H2Hn...Ethernet dispatcherEthernet handlerSerial dispatcherSerial handler
Other dispatcherhardware interrupts
Figure 12.5 The structure of interrupt code on the Galileo. Each devicedriver has both a low-level dispatcher and a high-level handler.12.9.2  BeagleBone Black (ARM)The interrupt controller hardware used with BeagleBone Black differs from the controller used with the Galileo. The controller on the BeagleBone Black does notstore interrupt vectors, nor does it invoke the code for a specific device. Instead, the hardware groups device interrupts into two exceptions: IRQ and FIQ. Because the de-vices of interest only use the IRQ mechanism, we will ignore FIQ, and assume all de-vices are grouped into the IRQ exception. When a device interrupts, an IRQ exception occurs, and the hardware invokes a single function in the operating system. A hardware register specifies the IRQ of the interrupting device.Recall that the exception vectors reside in memory, and the operating system must initialize the vectors at startup. The hardware maps the interrupt from any device into an IRQ exception, jumps to the interrupt vector, which has been initialized with codethat will jump to the IRQ dispatcher. The IRQ dispatcher determines which device in-terrupted, and then calls the appropriate handler. Figure 12.6 illustrates the structure.Sec. 12.9        The Structure Of Interrupt Software 223H1H2Hn...Ethernet handlerSerial handler......irq_dispatchhardware exceptionsdata exceptionIRQ exceptionother exceptioncode for data exceptioncode for IRQ exception (irq_except)code for other exception
Figure 12.6  The two-level interrupt code on the BeagleBone Black.  Deviceexceptions pass to an assembly language function, irq_except, which calls a dispatcher written in C, which calls a handler.Function irq_dispatch is found in file evec.c. Although the file contains otherfunctions (initintc to initialize the interrupt controller hardware and set_evec to assignan entry in the parallel exception vector array), we only need to consider irq_dispatch.The code appears on the next page.12.10 Disabling InterruptsInterrupts play a fundamental role in operating system design. The basic idea iseasy to understand. The hardware disables further interrupts once an interrupt occurs.As a result, interrupt code cannot be interrupted. That is, interrupts remain disabledwhen the dispatcher runs, when the handler is called, and when the handler returns. In-terrupts are only enabled when the processor executes a special instruction (or sequence of instructions) that return from the interrupt to the place at which processing was origi-nally interrupted. The point can be summarized:Interrupts are disabled when an interrupt occurs, and remain disabled until the code returns from an interrupt.224 Interrupt Processing Chap. 12//**SSnniippppeettooffccooddeeffrroommeevveecc..cc**////**--------------------------------------------------------------------------------------------------------------------------------------------------**iirrqq__ddiissppaattcchh--CCaalllltthheehhaannddlleerrffoorrssppeecciiffiicciinntteerrrruupptt**--------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddiirrqq__ddiissppaattcchh(()){{ssttrruuccttiinnttcc__ccssrreegg**ccssrrppttrr==((ssttrruuccttiinnttcc__ccssrreegg**))00xx4488220000000000;;uuiinntt3322xxnnuumm;;//**IInntteerrrruuppttnnuummbbeerrooffddeevviiccee**//iinntteerrrruupptt((**hhaannddlleerr))(());;//**PPooiinntteerrttoohhaannddlleerrffuunnccttiioonn**////**GGeetttthheeiinntteerrrruuppttnnuummbbeerrffrroommtthheeIInntteerrrruuppttccoonnttrroolllleerr**//xxnnuumm==ccssrrppttrr-->>ssiirr__iirrqq&&00xx77FF;;//**IIffaahhaannddlleerriisssseettffoorrtthheeiinntteerrrruupptt,,ccaalllliitt**//iiff((iinnttcc__vveeccttoorr[[xxnnuumm]])){{hhaannddlleerr==iinnttcc__vveeccttoorr[[xxnnuumm]];;hhaannddlleerr((xxnnuumm));;}} //**AAcckknnoowwlleeddggeetthheeiinntteerrrruupptt**//ccssrrppttrr-->>ccoonnttrrooll||==((IINNTTCC__CCOONNTTRROOLL__NNEEWWIIRRQQAAGGRR));;}}Although it may seem obvious, the interrupt policy stated above has subtle conse-quences. Device hardware places strict limits on the time a processor can run with in-terrupts disabled. If an operating system leaves interrupts disabled arbitrarily long, de-vices will fail to perform correctly. For example, a network device may drop incoming packets if the onboard packet buffer fills and interrupts remain disabled. As a conse-quence, interrupt routines must be written to complete processing as quickly as possible and resume executing the code that had interrupts enabled. More important, interrupts are global — if the handler for one device leaves interrupts disabled, all devices are af-fected. Thus, when creating interrupt code, a programmer must be aware of the con-straints on other devices in the system, and must accommodate the device with the smallest time constraint. The point can be summarized:The maximum time that an interrupt handler for device D can leave interrupts disabled cannot be computed by examining device D. In-stead, the time is computed by choosing the smallest constraint across all devices in the system.Sec. 12.10        Disabling Interrupts 225The rule may seem obvious and trivial. One must remember, however, that com-puters are designed to accommodate an arbitrary set of devices and to allow owners to connect new devices at any time. Therefore, when writing an interrupt handler for a specific device, a programmer cannot know the set of devices that will be connected to the computer. Users experience a consequence: a driver for an existing device, X, may not be compatible with hardware for a new device, Y.12.11 Constraints On Functions That Interrupt Code InvokesIn addition to ensuring that interrupt code accommodates the device with the tight-est time constraints, an operating system designer must build interrupt code to be exe-cuted by an arbitrary process. That is, interrupt code is executed by whichever process is running when the interrupt occurs.The process executing an interrupt seems irrelevant until one considers two facts:An interrupt handler can invoke operating system functions.Because the scheduler assumes at least one process will remainready to run, the null process must remain in either the current or ready state.The null process is designed to be an infinite loop that does not make function calls. However, an interrupt can be thought of as occurring “between” two successive instructions. Thus, if an interrupt occurs while the null process is executing, the null process will remain running while the handler executes. The most important conse-quence is:Interrupt routines can only call operating system functions that leave the executing process in the current or ready states.That is, interrupt routines may invoke functions such as send or signal, but may not in-voke functions such as wait that move the executing process to a non-eligible state.12.12 The Need To Reschedule During An InterruptConsider the question of rescheduling during an interrupt. To see why reschedul-ing is needed, observe the following:The scheduling invariant specifies that at any time, a highest priori-ty eligible process must be executing.When an I/O operation completes, a high-priority process may be-come eligible to execute.226 Interrupt Processing Chap. 12For example, suppose a high-priority process, P, chooses to read a packet from the network. Even though it has high priority, P must block to wait for a packet. While Pis blocked, some other process, Q, will be running. When a packet arrives and an inter-rupt occurs, process Q will be interrupted, and will execute the interrupt handler. If the interrupt handler merely moves P to the ready state and returns, process Q will continue to execute. If Q has lower-priority than P, the scheduling invariant will be violated.As an extreme case, consider what happens if a system only contains one applica-tion process, and the application blocks to wait for I/O. The null process will be run-ning when the interrupt occurs. If the interrupt handler does not reschedule, the inter-rupt will return to the null process and the application will never execute. The key ideais:To ensure that processes are notified promptly when an I/O operation completes and to maintain the scheduling invariant, an interrupt handler must reschedule whenever it makes a waiting process ready.12.13 Rescheduling During An InterruptThe interaction between the scheduling and interrupt policies creates a complex question: under what circumstances can we allow rescheduling? We said that interrupt routines must keep interrupts disabled while processing an interrupt. We also said that an interrupt handler must re-establish the scheduling invariant if a process that was waiting for I/O becomes eligible to execute. However, consider what can happen dur-ing rescheduling. Suppose the process that is selected to execute has been executing with interrupts enabled. Once it begins to execute, the process will return from the scheduler, and interrupts will be allowed. Thus, it might seem that an interrupt handler should not be allowed to reschedule because switching to a process that runs with inter-rupts enabled could start a cascade of further interrupts. We must convince ourselves that rescheduling during an interrupt is safe as long as global data structures are valid.To understand why rescheduling is safe, consider the series of events leading to acall of resched from an interrupt handler. Suppose a process U was running with inter-rupts enabled when the interrupt occurred. Interrupt dispatching uses U’s stack to savethe state, and leaves process U running with interrupts disabled while executing the in-terrupt handler. Suppose the handler calls resched, which switches to another process, T. After T returns from the context switch, T may be running with interrupts enabled, and another interrupt may occur. What prevents an infinite loop where unfinished inter-rupts pile up until a stack overflows with interrupt function calls? Recall that each process has its own stack. Process U had one interrupt on its stack when it was stopped by the context switch. The new interrupt occurs while the processor is executing proc-ess T, which means the processor is using T’s stack.Consider process U. Before another interrupt can pile up on U’s stack, U must re-gain control of the processor and interrupts must be enabled. At the last step before itgave up control, U called the scheduler, resched, which called the context switch. AtSec. 12.13        Rescheduling During An Interrupt 227that point, U was running with interrupts disabled. Therefore, when U regains control(i.e., when the scheduler selects U again and performs a context switch), U will begin executing with interrupts disabled. That is, U will start executing in the context switch. The context switch will return to the scheduler, the scheduler will return to the interrupt handler, and the handler will return to the dispatcher.During the sequence of returns, U will continue to execute with interrupts disabled until the dispatcher returns from the interrupt (i.e., until interrupt processing completes and the dispatcher returns to the location at which the original interrupt occurred). So, no additional interrupts can occur while process U is executing interrupt code (even though an interrupt can occur if U switches to another process and the other process runs with interrupts enabled). The important constraint is: only one interrupt can be in progress for a given process at any time. Because only a finite number of processes ex-ist in the system at a given time and each process can have at most one outstanding in-terrupt, the number of outstanding interrupts is bounded. To summarize:Rescheduling during interrupt processing is safe provided that (1) in-terrupt code leaves global data in a valid state before rescheduling, and (2) no function enables interrupts unless it disabled them.The rule explains why all operating systems functions use disable/restore rather than disable/enable. A function that disables interrupts upon entry always restores them before returning to its caller; no routine ever enables interrupts explicitly. The hardware that manages interrupts follows the same paradigm as the operating system. When an interrupt occurs, further interrupts are disabled, and they remain disabled until the pro-cessor returns from interrupt processing. The only exception to our rule about disabling and restoring interrupts is found in the system initialization function which enables in-terrupts explicitly at system startup.†12.14 PerspectiveThe relationship between interrupts and processes is among the most subtle and complex aspects of operating systems. Interrupts are low-level mechanisms — they are part of the underlying hardware and are defined in terms of sequential notions such as the fetch-execute cycle. Processes are high-level abstractions — they are imagined by operating system designers and defined by a set of system functions. Consequently, it is easiest to understand interrupts by thinking about the mechanism without thinking about concurrent processes, and easiest to understand concurrent processes by thinking about the abstraction without thinking about interrupts.Unfortunately, combining the abstract world of processes and the concrete world of interrupts is intellectually challenging. If the interactions between interrupts andprocesses does not seem incredibly complex, you have not thought about it deeply. If it seems too complex to grasp, console yourself that you are not alone. With careful thought, you will be able to master the basics.†At startup, a processor disables all interrupt processing until the operating system runs and enables them.228 Interrupt Processing Chap. 1212.15 SummaryTo process an interrupt, the hardware and operating system cooperate to save acopy of the processor state, determine which device requested the interrupt, and invokea handler for the device. Because a high-level language does not provide facilities to manipulate machine state, interrupt code is divided into a dispatcher that is written in assembly language and a handler that is written in a high-level language, such as C. On the Galileo, a separate dispatch function is needed for each device; on the BeagleBone Black, a single dispatch function handles all devices.Three basic rules control interrupt processing. First, interrupt code must not leave interrupts disabled arbitrarily long or devices will fail to operate correctly. The length of time an interrupt can be delayed depends on all devices attached to the system, notonly on the device being serviced. Second, because it can be executed by the null proc-ess, interrupt code must never call a function that will move the executing process out of the current or ready states. Third, an interrupt handler must use a special instruction to return from an interrupt; the code must never enable interrupts explicitly.Despite the prohibition on enabling interrupts, a handler can call resched whenever a waiting process becomes ready. Doing so re-establishes the scheduling invariant and also means that if a process is waiting for I/O to complete, the process will be informed promptly. Of course, the code must ensure that global data structures are in a valid state before rescheduling. Rescheduling does not cause a cascade of interrupts because each process can have at most one interrupt on its stack.EXERCISES12.1  Suppose an interrupt handler contains an error that explicitly enables interrupts.Describe how a system might fail.12.2      Modify interrupt handlers to enable interrupts, and see how long a system can run beforecrashing. Are you surprised? Determine exactly why the system crashes. (Note: for this exercise, disable the timer device that is described in the next chapter.)12.3      On the BeagleBone Black platform, how many functions are called each time a characterarrives over a serial line? Can the number of calls be reduced, or does the software ar-chitecture depend on the hardware? Explain.12.4 Imagine a processor where the hardware automatically switches context to a special “in-terrupt process” whenever an interrupt occurs. The only purpose of the interrupt processis to run interrupt code. Does such a design make an operating system easier or more difficult to design? Explain. Hint: will the interrupted process be permitted to reschedule?12.5 If you could redesign interrupt controller hardware, what changes would you make tominimize the work the operating system needs to do?12.6 Calculate how many microseconds can be spent per interrupt assuming eight serial de-vices each receive characters at 115 Kbaud (115 thousand bits per second, or approxi-mately 11,500 characters per second).Exercises22912.7 Download a copy of the Xinu source code, and examine the interrupt functions in intr.Sfor both the Galileo and BeagleBone Black (for the Galileo, also include the dispatch function from a device driver). Explain the purpose of each line of code.12.8  Read about IRQ mode in the ARM architecture. Which registers are banked? Why?12.9  Download a copy of source code for both the ARM and Galileo versions of Xinu. Com-pare function set_evec for the two architectures. What is the chief difference?Chapter Contents13.1 Introduction, 23313.2 Timed Events, 23413.3 Real-time Clocks And Timer Hardware, 23413.4 Handling Real-time Clock Interrupts, 23513.5 Delay And Preemption, 23613.6 Implementation Of Preemption, 23713.7 Efficient Management Of Delay With A Delta List, 23813.8 Delta List Implementation, 23913.9 Putting A Process To Sleep, 24113.10 Timed Message Reception, 24413.11 Awakening Sleeping Processes, 248 13.12 Clock Interrupt Processing, 24913.13 Clock Initialization, 251 13.14 Perspective, 25413.15 Summary, 25513Real-time Clock Management
We haven’t the time to take our time.— Eugene Ionesco13.1 IntroductionEarlier chapters describe two major pieces of an operating system: a processmanager that provides concurrent processing and a memory manager that allows blocksof memory to be allocated and released dynamically. The previous chapter introduces interrupt processing. The chapter states rules for interrupt processing, describes how the operating system captures control when an interrupt occurs, and explains how control passes through a dispatcher to a device-specific interrupt handler.This chapter continues the discussion of interrupts by describing timing hardwareand explaining how an operating system uses a real-time mechanism to provideprocesses with the ability to control timed events. The chapter introduces two funda-mental concepts: a delta list data structure and process preemption. It explains how an operating system uses a clock to provide round-robin service to a set of equal-priority processes. Later chapters extend the study of interrupts by exploring device drivers for other I/O devices.
233234 Real-time Clock Management Chap. 1313.2 Timed EventsMany applications use timed events. For example, an application might create a window to display a message, leave the window on the screen for five seconds, and then remove the window. An application that prompts for a password might choose to exit unless a password is entered within thirty seconds. Parts of an operating systemalso use timed events. For example, many network protocols require a sender to re-transmit a request if no response is received within a specified time. Similarly, an operating system might choose to inform a user if a peripheral, such as a printer, remains disconnected for more than a few seconds. On small embedded systems that do not have a separate hardware mechanism, an operating system uses timed events to maintain the current date and time of day.Because time is fundamental, most operating systems provide facilities that make it easy for an application to create and manage a set of timed events. Some systems use a general-purpose asynchronous event paradigm in which a programmer defines a set of event handlers and the operating system invokes the appropriate handler when an event occurs. Timed events fit into the asynchronous paradigm easily: a running process re-quests that a specific event occur T time units in the future. Other systems follow a synchronous event paradigm in which the operating system only provides delay and a programmer creates extra processes as needed to schedule events. Our example system uses the synchronous approach.13.3 Real-time Clocks And Timer HardwareFour types of hardware devices relate to time:Processor clockReal-time clockTime-of-day clockInterval timerProcessor clock. The term processor clock refers to a hardware device that emits pulses (i.e., square waves) at regular intervals with high precision. The processor clock controls the rate at which the processor executes instructions. To minimize hardware, low-end embedded systems often use the processor clock as a source of timing informa-tion. Unfortunately, a processor clock rate is often inconvenient (i.e., the clock pulses rapidly, and the rate may not divide evenly into one second).Real-time clock. A real-time clock operates independent of the processor, and pulses in fractions of a second (e.g., 1000 times per second), generating an interrupt for each pulse. Usually, real-time clock hardware does not count pulses — if an operating system needs to compute an elapsed time, the system must increment a counter when each clock interrupt occurs.Sec. 13.3        Real-time Clocks And Timer Hardware 235Time-of-day clock. Technically, a time-of-day clock is a chronometer that com-putes elapsed time. The hardware consists of an internal real-time clock connected to a counter that tallies the pulses. Like a normal clock, the time can be changed. Once set, however, the mechanism runs independent of the processor, and continues as long as the system receives power (some units include a small battery to keep the clock active even if the external power is removed temporarily). Unlike other clocks, a time-of-day clock does not interrupt — the processor must set or interrogate the clock.Interval timer. An interval timer, sometimes called a count-down timer or simply a timer, also consists of an internal real-time clock and a counter. To use an interval tim-er, the system initializes the counter to a positive value. The timer decrements thecount once for each real-time clock pulse, and generates an interrupt when the count reaches zero. A variant known as a count-up timer requires the operating system to ini-tialize the count to zero and set a limit. As the name implies, a count-up timer incre-ments the counter, and interrupts the operating system when the counter reaches the limit value.The chief advantage of a timer over a real-time clock lies in lower interrupt over-head. A real-time clock interrupts regularly, even if the next event is many time units in the future. A timer only interrupts when an event is scheduled. Furthermore, a timer is more flexible than a real-time clock because a timer can emulate a real-time clock. To emulate a real-time clock with a rate of R pulses per second, for example, a timer isset to interrupt in 1/R seconds. When an interrupt occurs, the timer is reset to the same value. To summarize:The hardware an operating system uses to manage timed events con-sists of real-time clocks and interval timers. A real-time clock inter-rupts regularly; an interval timer interrupts after a specified delay.In terms of the example platforms, the Galileo has a real-time clock, and the BeagleBone Black has an interval timer. At startup, the Galileo code configures thereal-time clock to interrupt once every millisecond. The BeagleBone Black code con-figures the interval timer to act like a real-time clock by specifying that the timer should interrupt after a millisecond and should automatically restart when an interrupt occurs. Thus, the following sections that describe how an operating system uses a real-time clock apply to both of the example platforms.13.4 Handling Real-time Clock InterruptsWe said that a real-time clock interrupts regularly without counting or accumulat-ing interrupts. Similarly, if a timer is used to emulate a real-time clock, the timer doesnot accumulate interrupts. In either case, if a processor fails to service a clock interrupt before the clock pulses again, the processor will not receive the second interrupt. More important, the hardware does not detect or report the error†:†Although hardware exists that can report overflow, many clock modules do not.236 Real-time Clock Management Chap. 13If a processor takes too long to service a real-time clock interrupt orif it operates with interrupts disabled for more than one clock cycle, a clock interrupt will be missed and no error will be reported.The operation of real-time clock hardware has two significant consequences for system designers. First, because it must be able to execute many instructions between real-time clock interrupts, a processor must operate significantly faster than the real-time clock. Second, real-time clock interrupts can be a source of hidden errors. That is, if an operating system runs too long with interrupts disabled, clock interrupts will be missed and timing will be affected. Such errors can easily go undetected.Obviously, systems must be designed to service clock interrupts quickly. Some hardware helps by giving highest priority to real-time clock interrupts. Thus, if an I/O device and a clock device each request an interrupt at the same time, the processor re-ceives the clock interrupt first, and only receives the I/O interrupt after the clock has been serviced.13.5 Delay And PreemptionWe will focus on two ways that an operating system uses timed events:Timed delayPreemptionTimed delay. An operating system allows any process to request a timed delay.When a process requests a timed delay, the operating system moves the process fromthe current state into a new state (which we call sleeping), and schedules a wakeupevent to restart the process at the specified time. When the wakeup event occurs, the process becomes eligible to use the processor, and executes according to the scheduling policy. Later sections explain how a process is put to sleep and how it is reawakened at the correct time.Preemption. The process manager in an operating system uses a preemption mech-anism to implement time slicing that guarantees equal-priority processes receive service round-robin, as specified by the scheduling policy in Chapter 5. The system defines a maximum time slice, T, that a process can execute without allowing other processes to execute. When it switches from one process to another, the scheduler schedules a preemption event T time units in the future. When a preemption event occurs, the event handler simply calls resched.To understand how preemption works, observe that a system may contain multiple processes with the same priority. Thus, while one process executes, other processes of equal priority may be enqueued on the ready list, eligible to run. In such cases, a call to resched places the current process at the end of the ready list, behind other processes with equal priority, and switches to the first process on the list. Therefore, if k equal-Sec. 13.5        Delay And Preemption 237priority processes are ready to use the processor, all k execute for at most one time slice before any process receives more service.How long should a time slice be? We say that the choice of a time slice controls the granularity of preemption. Using a short time slice makes the granularity small by rescheduling often. Small granularity tends to keep all equal priority processes proceed-ing at approximately the same pace because no process can run for more than T time units before another has an opportunity to run. However, a small granularity introduces higher overhead because the system switches context often. If the granularity is too small, the system will spend more time handling clock interrupts and context switching than executing application processes. A large granularity reduces the overhead of con-text switching, but allows a process to hold the processor longer before allowing other processes to execute.It turns out that in most systems, a process seldom uses the processor long enough for preemption to occur. Instead, a process usually performs I/O or executes a system function, such as wait, that causes rescheduling. In essence, a process voluntarily gives up control of the processor before its timeslice ends. More important, because input and output are slow compared to processing, processes spend most of their time waiting for I/O to complete. Despite the expected case, preemption provides important func-tionality:Without a preemptive capability, an operating system cannot regain control from a process that executes an infinite loop.13.6 Implementation Of PreemptionThe example code implements both preemption and timed delays; before examin-ing the code, we will discuss each. Preemption is the easiest to understand. Defined constant QUANTUM specifies the number of clock ticks in a single time slice. When-ever it switches from one process to another, resched sets global variable preempt to QUANTUM. Each time the clock ticks, the clock interrupt handler decrements preempt. When preempt reaches zero, the clock interrupt handler resets preempt to QUANTUM and calls resched. Following the call to resched, the handler returns from the interrupt.The call to resched has two possible outcomes. First, if the currently executingprocess remains the only process at the highest priority, resched will return immediate-ly, the interrupt handler will return, and the current process will return to the point ofthe interrupt and continue executing for another timeslice. Second, if another ready process has the same priority as the current process, the call to resched will switch to the new process. Eventually, resched will switch back to the interrupted process. The assignment of QUANTUM to preempt handles the case where the current process remains running. The assignment is needed because resched only resets the preemption counter when it switches to a new process.† Note that resetting the preemption counter prevents the counter from underflowing in cases where a single process executes inde-finitely.†The code for resched can be found on page 82.238 Real-time Clock Management Chap. 1313.7 Efficient Management Of Delay With A Delta ListTo implement delay, the operating system must maintain information about the set of processes that have requested a delay. Each process specifies a delay relative to the time at which it places a request, and additional processes can make a request at any time. When the delay for a process expires, the system makes the process ready and calls resched.How can an operating system maintain a set of processes that have each requested a specific delay? The system cannot afford to search through arbitrarily long lists of sleeping processes on each clock tick. Therefore, an efficient data structure is needed that only requires a clock interrupt handler to execute a few instructions on each clock tick while accommodating a set of processes that have each requested a specific delay.The solution lies in a data structure that we call a delta list. A delta list contains aset of processes, and the list is ordered by the time at which a process should awaken.The fundamental insight needed to make computation efficient lies in the use of relative rather than absolute times. That is, instead of storing a value that specifies the time a process should awaken, a key in the delta list stores the additional time a process must delay beyond the preceding process on the list:The key of the first process on a delta list specifies the number ofclock ticks a process must delay beyond the current time; the key of each other process on a delta list specifies the number of clock ticks the process must delay beyond the preceding process on the list.As an example, suppose processes A, B, C, and D request delays of 6, 12, 27, and 50 ticks, respectively. Further suppose the requests are made at approximately the same time (i.e., within one clock tick). Figure 13.1 illustrates the delta list that will result.
6A23 D6B15 Ckey process next
Figure 13.1Conceptual form of a delta list with four processes that have de-lays 6, 12, 27, and 50 ticks from the current time, respectively.Given a delta list, one can find the time at which each process will awaken by computing partial sums of keys. In the figure, the delay before process A awakens is 6, the delay before process B awakens is 6  +  6, the delay before process C awakens is6 + 6 + 15, and the delay beforeD  awakens is 6 + 6 + 15 + 23.Sec. 13.8        Delta List Implementation 23913.8 Delta List ImplementationAn overarching goal of operating systems designers arises from the desire to achieve maximal functionality with minimal mechanism. Designs that provide powerful functionality with minimal overhead are valued. To achieve such goals, designers look for ways to create underlying mechanisms that accommodate multiple functions. In the case of delta lists, we will see that it is possible to use the basic list data structure covered in Chapter 4. That is, the delta list of delayed processes will reside in the queuetab structure, just like other lists of processes.Conceptually, the processing required for a delta list is straightforward. Global variable sleepq contains the queue ID of the delta list for sleeping processes. On eachclock tick, the clock interrupt handler examines the queue of sleeping processes, and de-crements the key on the first item if the queue is nonempty. If the key reaches zero, the delay has expired and the process must be awakened. To awaken a process, the clock handler calls function wakeupFunctions to manipulate a delta list seem straightforward, but the implementation can be tricky. Therefore, a programmer must pay close attention to details. Function insertd takes three arguments: a process ID, pid, a queue ID, q, and a delay given by ar-gument key.  Insertd finds the location on the delta list where the new process should be inserted and links the process into the list. In the code, variable next scans the delta list searching for the place to insert the new process. File insertd.c contains the code.Observe that the initial value of argument key specifies a delay relative to thecurrent time. Thus, argument key can be compared to the key in the first item on thedelta list. However, successive keys in the delta list specify delays relative to their predecessor. Thus, the key in successive nodes on the list cannot be compared directly to the value of argument key. To keep the delays comparable, insertd subtracts the rela-tive delays from key as the search proceeds, maintaining the following invariant:At any time during the search, both key and queuetab[next].qkeyspecify a delay relative to the time at which the predecessor of “next”awakens.Although insertd checks for the tail of the list explicitly during the search, the test could be removed without affecting the execution. To understand why, recall that the key value in the tail of a list is assumed to be greater than any key being inserted. Aslong as the assertion holds, the loop will terminate once the tail has been reached. Be-cause insertd does not check its argument, keeping the test provides a safety check.After it has identified a location on the list where the relative delay of the item be-ing inserted is smaller than the relative delay of an item on the list, insertd links thenew item into the list.  Insertd must also subtract the extra delay that the new item in-troduces from the delay of the rest of the list. To do so, insertd decrements the key in the next item on the list by the key value being inserted. The subtraction is guaranteed240 Real-time Clock Management Chap. 13to produce a nonnegative value because the termination condition for the loop guaran-tees that the key inserted is less than the next key on the list.//**iinnsseerrttdd..cc--iinnsseerrttdd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**iinnsseerrttdd--IInnsseerrttaapprroocceessssiinnddeellttaalliissttuussiinnggddeellaayyaasstthheekkeeyy**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussiinnsseerrttdd((//**AAssssuummeessiinntteerrrruuppttssddiissaabblleedd**//ppiidd3322ppiidd,,//**IIDDooffpprroocceessssttooiinnsseerrtt**//qqiidd1166qq,,//**IIDDooffqquueeuueettoouussee**//iinntt3322kkeeyy//**DDeellaayyffrroomm""nnooww""((iinnmmss..))**//)){{iinntt3322nneexxtt;;//**RRuunnsstthhrroouugghhtthheeddeellttaalliisstt**//iinntt3322pprreevv;;//**FFoolllloowwssnneexxtttthhrroouugghhtthheelliisstt**//iiff((iissbbaaddqqiidd((qq))||||iissbbaaddppiidd((ppiidd)))){{rreettuurrnnSSYYSSEERRRR;;}} pprreevv==qquueeuueehheeaadd((qq));;nneexxtt==qquueeuueettaabb[[qquueeuueehheeaadd((qq))]]..qqnneexxtt;;wwhhiillee((((nneexxtt!!==qquueeuueettaaiill((qq))))&&&&((qquueeuueettaabb[[nneexxtt]]..qqkkeeyy<<==kkeeyy)))){{kkeeyy--==qquueeuueettaabb[[nneexxtt]]..qqkkeeyy;;pprreevv==nneexxtt;;nneexxtt==qquueeuueettaabb[[nneexxtt]]..qqnneexxtt;;}} //**IInnsseerrttnneewwnnooddeebbeettwweeeennpprreevvaannddnneexxttnnooddeess**//qquueeuueettaabb[[ppiidd]]..qqnneexxtt==nneexxtt;;qquueeuueettaabb[[ppiidd]]..qqpprreevv==pprreevv;;qquueeuueettaabb[[ppiidd]]..qqkkeeyy==kkeeyy;;qquueeuueettaabb[[pprreevv]]..qqnneexxtt==ppiidd;;qquueeuueettaabb[[nneexxtt]]..qqpprreevv==ppiidd;;iiff((nneexxtt!!==qquueeuueettaaiill((qq)))){{qquueeuueettaabb[[nneexxtt]]..qqkkeeyy--==kkeeyy;;}} rreettuurrnnOOKK;;}}Sec. 13.8        Delta List Implementation 24113.9 Putting A Process To SleepAn application does not call insertd, nor does the application access the sleep queue directly. Instead, an application invokes system call sleep or sleepms to request a delay. The only difference between the two functions is the granularity of their argu-ments. An argument to sleepms specifies a delay in milliseconds, the smallest granular-ity delay that is possible when a clock interrupts every millisecond. An argument to sleep specifies a delay in seconds, which is easier to use in some cases. For example, a delay visible to a human is often expressed in seconds rather than milliseconds.To avoid duplicating code, function sleep multiplies its argument by 1000 and in-vokes sleepms. The only interesting aspect of sleep is a check on its argument size: to avoid integer overflow, sleep limits the delay to a value that can be represented as a32-bit unsigned integer. If the caller specifies a larger value, sleep returns SYSERR.On a 32-bit processor, measuring delay in milliseconds provides an adequate range of delay for most applications. An unsigned 32-bit integer accommodates delays over 1100 hours (49 days). Delays longer than 49 days can be managed by having a process repeatedly sleep for many days, awaken, check the time, and sleep again. On embedded systems that use 16-bit integers, however, millisecond delays mean that a caller can only express a delay of thirty-two seconds. Such systems seldom have much memory or processing power, so using a process to manage longer delays may not be feasible. Therefore, an operating system designed for a slow, 16-bit processor may choose a larger granularity for clock interrupts (e.g., tenths of seconds instead of milliseconds). If the clock generates interrupts every tenth of a second, a sleep function must be changed to measure delays in tenths of seconds.The choice of delay granularity may also be limited by the speed of the processor. Handling clock interrupts can take a surprising amount of time because they never stop, even when no processes are sleeping. If a clock interrupts too fast, a processor will spend most of its time handling clock interrupts. Fortunately, processors have become extremely fast. As processor speeds increased, it became possible to increase the rate of clock interrupts, allowing the granularity of delays to decrease. Thus, the fastest pro-cessors allow microsecond delays.Consider the state of a sleeping process. We said that to delay a process, sleepms inserts the process into the delta list of sleeping processes. When it has been moved to the list of sleeping processes, the process is no longer ready or current. In what stateshould it be placed? Sleeping differs from suspension, waiting to receive a message, or waiting for a semaphore. Thus, because none of the existing states suffices, a new proc-ess state must be added to the design. We call the new state sleeping, and denote it with symbolic constant PR_SLEEP. Figure 13.2 illustrates state transitions that include the sleeping state.242 Real-time Clock Management Chap. 13
READYCURRENTreschedreschedSUSPENDEDsuspendresumesuspendcreateWAITINGwaitsignalRECEIVINGreceivesendSLEEPINGsleepwakeup
Figure 13.2  State transitions including the sleeping state.The implementation of sleepms, shown below in file sleep.c, includes a special case: if a process specified a delay of zero, sleepms does not delay the process, but calls resched immediately. Otherwise, sleepms uses insertd to insert the current process in the delta list of sleeping processes, changes the state to sleeping, and calls resched to al-low other processes to execute.//**sslleeeepp..cc--sslleeeeppsslleeeeppmmss**//##iinncclluuddee<<xxiinnuu..hh>>##ddeeffiinneeMMAAXXSSEECCOONNDDSS44229944996677//**MMaaxxsseeccoonnddssppeerr3322--bbiittmmsseecc**//Sec. 13.9        Putting A Process To Sleep 243//**------------------------------------------------------------------------------------------------------------------------------------------------**sslleeeepp--DDeellaayytthheeccaalllliinnggpprroocceessssnnsseeccoonnddss**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllsslleeeepp((uuiinntt3322ddeellaayy//**TTiimmeettooddeellaayyiinnsseeccoonnddss**//)){{iiff((ddeellaayy>>MMAAXXSSEECCOONNDDSS)){{rreettuurrnnSSYYSSEERRRR;;}} sslleeeeppmmss((11000000**ddeellaayy));;rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**sslleeeeppmmss--DDeellaayytthheeccaalllliinnggpprroocceessssnnmmiilllliisseeccoonnddss**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllsslleeeeppmmss((uuiinntt3322ddeellaayy//**TTiimmeettooddeellaayyiinnmmsseecc..**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//mmaasskk==ddiissaabbllee(());;iiff((ddeellaayy====00)){{yyiieelldd(());;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**DDeellaayyccaalllliinnggpprroocceessss**//iiff((iinnsseerrttdd((ccuurrrrppiidd,,sslleeeeppqq,,ddeellaayy))====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} pprrooccttaabb[[ccuurrrrppiidd]]..pprrssttaattee==PPRR__SSLLEEEEPP;;rreesscchheedd(());;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}244 Real-time Clock Management Chap. 1313.10 Timed Message ReceptionXinu includes a mechanism that is especially useful in computer networking: timed message reception. In essence, the mechanism allows a process to wait for a specified time or for a message to arrive, whichever occurs first. The mechanism enhances the send and receive functions. That is, the mechanism operates like the synchronous re-ceive function with an additional provision that places a bound on the maximum time the process will wait.The fundamental concept behind timed message reception is disjunctive wait:a process blocks until one of two events occurs. Many network protocols use disjunctive wait to implement timeout-and-retransmission, a technique senders employ to handle packet loss. When it sends a message, a sender also starts a timer, and then waits for a reply to arrive or the timer to expire, whichever occurs first. If a reply arrives, the net-work cancels the timer. If the message or the reply is lost, the timer expires, and the protocol software retransmits a copy of the request.In Xinu, when a process requests a timed receive, the process is placed on thequeue of sleeping processes, exactly like any other sleeping process. Instead of assign-ing the process state PR_SLEEP, however, the system places the process in statePR_RECTIM to indicate that it is engaged in a receive with timeout. If the sleep timer expires, the process is awakened like any other sleeping process. If a message arrives before the delay expires, the process must be removed from the sleeping process queue. In our implementation, send handles the task of removing a process. That is, when sending a message to a process that has performed a disjunctive wait, send calls unsleep to remove the process from the queue of sleeping processes, and then proceeds to deliver the message.How can a process know whether the timer expired before a message arrived? Inour implementation, the process tests the presence of a message. That is, once itresumes execution after a timed delay, the process checks its process table entry to seeif a message has arrived. If no message is present, the timer must have expired. An ex-ercise explores the consequences of the implementation.Figure 13.3 shows the state diagram with a new state, TIMED-RECV, for timedmessage reception.Sec. 13.10        Timed Message Reception 245
READYCURRENTreschedreschedSUSPENDEDsuspendresumesuspendcreateWAITINGwaitsignalRECEIVINGreceivesendSLEEPINGsleepwakeupTIMED-RECVrecvtimewakeup
Figure 13.3  State transitions including the timed receive state.As we have seen, the send† function in Chapter 8 handles the case where a process is in the timed receive state. Thus, we only need to examine the code for function recv-time and unsleep. Function recvtime is almost identical to function receive‡ except that before calling resched, recvtime calls insertd to insert the calling process on the queue of sleeping processes and assigns state PR_RECTIM instead of state PR_RECV. File recvtime.c contains the code.†Function send can be found in file send.c on page 147. ‡Function receive can be found in file receive.con page 148.246 Real-time Clock Management Chap. 13//**rreeccvvttiimmee..cc--rreeccvvttiimmee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rreeccvvttiimmee--WWaaiittssppeecciiffiieeddttiimmeettoorreecceeiivveeaammeessssaaggeeaannddrreettuurrnn**------------------------------------------------------------------------------------------------------------------------------------------------**//uummssgg3322rreeccvvttiimmee((iinntt3322mmaaxxwwaaiitt//**TTiicckkssttoowwaaiittbbeeffoorreettiimmeeoouutt**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**TTbblleennttrryyooffccuurrrreennttpprroocceessss**//uummssgg3322mmssgg;;//**MMeessssaaggeettoorreettuurrnn**//iiff((mmaaxxwwaaiitt<<00)){{rreettuurrnnSSYYSSEERRRR;;}} mmaasskk==ddiissaabbllee(());;//**SScchheedduulleewwaakkeeuuppaannddppllaacceepprroocceessssiinnttiimmeedd--rreecceeiivveessttaattee**//pprrppttrr==&&pprrooccttaabb[[ccuurrrrppiidd]];;iiff((pprrppttrr-->>pprrhhaassmmssgg====FFAALLSSEE)){{//**IIffmmeessssaaggeewwaaiittiinngg,,nnooddeellaayy**//iiff((iinnsseerrttdd((ccuurrrrppiidd,,sslleeeeppqq,,mmaaxxwwaaiitt))====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} pprrppttrr-->>pprrssttaattee==PPRR__RREECCTTIIMM;;rreesscchheedd(());;}} //**EEiitthheerrmmeessssaaggeeaarrrriivveeddoorrttiimmeerreexxppiirreedd**//iiff((pprrppttrr-->>pprrhhaassmmssgg)){{mmssgg==pprrppttrr-->>pprrmmssgg;;//**RReettrriieevveemmeessssaaggee**//pprrppttrr-->>pprrhhaassmmssgg==FFAALLSSEE;;//**RReesseettmmeessssaaggeeiinnddiiccaattoorr**//}}eellssee{{mmssgg==TTIIMMEEOOUUTT;;}} rreessttoorree((mmaasskk));;rreettuurrnnmmssgg;;}}Sec. 13.10        Timed Message Reception 247Function unsleep is an internal function that removes a process from the queue of sleeping processes.† To maintain the correct delays for processes that remain in thequeue, unsleep must keep all delays the same as before the deletion. To so do, unsleep examines the successor of the process being removed. If a successor exists, unsleep adds the delay of the process being removed to the delay of the successor. File unsleep.c contains the code.//**uunnsslleeeepp..cc--uunnsslleeeepp**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**uunnsslleeeepp--IInntteerrnnaallffuunnccttiioonnttoorreemmoovveeaapprroocceessssffrroommtthheesslleeeepp**qquueeuueepprreemmaattuurreellyy..TThheeccaalllleerrmmuussttaaddjjuusstttthheeddeellaayy**ooffssuucccceessssiivveepprroocceesssseess..**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussuunnsslleeeepp((ppiidd3322ppiidd//**IIDDooffpprroocceessssttoorreemmoovvee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//ppiidd3322ppiiddnneexxtt;;//**IIDDooffpprroocceessssoonnsslleeeeppqquueeuuee**////**tthhaattffoolllloowwsstthheepprroocceessss**////**wwhhiicchhiissbbeeiinnggrreemmoovveedd**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddppiidd((ppiidd)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyytthhaattccaannddiiddaatteepprroocceessssiissoonntthheesslleeeeppqquueeuuee**//pprrppttrr==&&pprrooccttaabb[[ppiidd]];;iiff((((pprrppttrr-->>pprrssttaattee!!==PPRR__SSLLEEEEPP))&&&&((pprrppttrr-->>pprrssttaattee!!==PPRR__RREECCTTIIMM)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**IInnccrreemmeennttddeellaayyooffnneexxttpprroocceessssiiffssuucchhaapprroocceesssseexxiissttss**//†The term internal emphasizes that unsleep is not a system call, and should not be called by a user proc-ess.248 Real-time Clock Management Chap. 13ppiiddnneexxtt==qquueeuueettaabb[[ppiidd]]..qqnneexxtt;;iiff((ppiiddnneexxtt<<NNPPRROOCC)){{qquueeuueettaabb[[ppiiddnneexxtt]]..qqkkeeyy++==qquueeuueettaabb[[ppiidd]]..qqkkeeyy;;}} ggeettiitteemm((ppiidd));;//**UUnnlliinnkkpprroocceessssffrroommqquueeuuee**//rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}13.11 Awakening Sleeping ProcessesWe said that on each tick of the clock, the clock interrupt handler decrements the count of the first key on sleepq, and calls wakeup to awaken the process when the delay reaches zero. In fact, wakeup does not merely awaken one process — it must handle the case where multiple processes are scheduled to awaken at the same time. Therefore, after deferring rescheduling, wakeup iterates through all processes that have a delay of zero, using sleepq to remove the process from the sleep queue and ready to make the process eligible for processor service. (Note that because it has been called from an in-terrupt dispatcher, which has interrupts disabled, wakeup can call ready without expli-citly disabling interrupts.) Once it finishes moving processes to the ready list, wakeup calls resched_cntl to allow rescheduling, which means that a context switch will occur if a higher-priority process became ready.//**wwaakkeeuupp..cc--wwaakkeeuupp**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**wwaakkeeuupp--CCaalllleeddbbyycclloocckkiinntteerrrruupptthhaannddlleerrttooaawwaakkeennpprroocceesssseess**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddwwaakkeeuupp((vvooiidd)){{//**AAwwaakkeennaallllpprroocceesssseesstthhaatthhaavveennoommoorreettiimmeettoosslleeeepp**//rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;wwhhiillee((nnoonneemmppttyy((sslleeeeppqq))&&&&((ffiirrssttkkeeyy((sslleeeeppqq))<<==00)))){{rreeaaddyy((ddeeqquueeuuee((sslleeeeppqq))));;}} rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;rreettuurrnn;;}}Sec. 13.11        Awakening Sleeping Processes 24913.12 Clock Interrupt ProcessingWe are now ready to examine the code that handles clock interrupts. The clock is configured to interrupt once each millisecond. Recall that interrupt processing is ar-ranged so the interrupt mechanism invokes a dispatch function written in assembly language that saves processor state and invokes a handler that is written in C. On the Galileo, each device has a separate dispatch function; the clock dispatch function is clkdisp. The file only contains a few lines of code that save registers, call the interrupt handler, clkhandler, restore registers, and return from the interrupt.//**ccllkkddiisspp..ss--ccllkkddiisspp((xx8866))**////**------------------------------------------------------------------------------------------------------------------------------------------------**ccllkkddiisspp--IInntteerrrruuppttddiissppaattcchheerrffoorrcclloocckkiinntteerrrruuppttss((xx8866vveerrssiioonn))**------------------------------------------------------------------------------------------------------------------------------------------------**//##iinncclluuddee<<iiccuu..ss>>..tteexxtt..gglloobbllccllkkddiisspp##CClloocckkiinntteerrrruuppttddiissppaattcchheerrccllkkddiisspp::ppuusshhaall##SSaavveerreeggiisstteerrssccllii##DDiissaabblleeffuurrtthheerriinntteerrrruuppttssmmoovvbb$$EEOOII,,%%aall##RReesseettiinntteerrrruuppttoouuttbb%%aall,,$$OOCCWW11__22ccaallllccllkkhhaannddlleerr##CCaallllhhiigghhlleevveellhhaannddlleerrssttii##RReessttoorreeiinntteerrrruuppttssttaattuussppooppaall##RReessttoorreerreeggiisstteerrssiirreett##RReettuurrnnffrroommiinntteerrrruuppttThe clock interrupt handler, clkhandler, which manages sleeping processes andpreemption, can be found in file clkhandler.c.250 Real-time Clock Management Chap. 13//**ccllkkhhaannddlleerr..cc--ccllkkhhaannddlleerr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ccllkkhhaannddlleerr--hhiigghhlleevveellcclloocckkiinntteerrrruupptthhaannddlleerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddccllkkhhaannddlleerr(()){{ssttaattiiccuuiinntt3322ccoouunntt11000000==11000000;;//**CCoouunnttttoo11000000mmss**////**DDeeccrreemmeenntttthheemmssccoouunntteerr,,aannddsseeeeiiffaasseeccoonnddhhaassppaasssseedd**//iiff((((----ccoouunntt11000000))<<==00)){{//**OOnneesseeccoonnddhhaassppaasssseedd,,ssooiinnccrreemmeennttsseeccoonnddssccoouunntt**//ccllkkttiimmee++++;;//**RReesseetttthheellooccaallmmssccoouunntteerrffoorrtthheenneexxttsseeccoonndd**//ccoouunntt11000000==11000000;;}} //**HHaannddlleesslleeeeppiinnggpprroocceesssseessiiffaannyyeexxiisstt**//iiff((!!iisseemmppttyy((sslleeeeppqq)))){{//**DDeeccrreemmeenntttthheeddeellaayyffoorrtthheeffiirrssttpprroocceessssoonntthhee**////**sslleeeeppqquueeuuee,,aannddaawwaakkeenniifftthheeccoouunnttrreeaacchheesszzeerroo**//iiff((((----qquueeuueettaabb[[ffiirrssttiidd((sslleeeeppqq))]]..qqkkeeyy))<<==00)){{wwaakkeeuupp(());;}}}} //**DDeeccrreemmeenntttthheepprreeeemmppttiioonnccoouunntteerr,,aannddrreesscchheedduulleewwhheenntthhee**////**rreemmaaiinniinnggttiimmeerreeaacchheesszzeerroo**//iiff((((----pprreeeemmpptt))<<==00)){{pprreeeemmpptt==QQUUAANNTTUUMM;;rreesscchheedd(());;}}}}Sec. 13.12        Clock Interrupt Processing 251Clkhandler begins by incrementing local variable count1000, which counts from1000 down to 0. When count1000 reaches zero, one second (i.e., 1000 ms.) haselapsed, so clkhandler increments global variable clktime, which stores the time inseconds since the system booted. Clktime is used to provide the date (e.g., it is used bythe Xinu shell command date).Once it has handled incrementing global counters, clkhandler performs two tasks related to processes: sleeping processes and time slicing. To manage sleepingprocesses, clkhandler decrements the time remaining on the first process in sleepq (pro-vided sleepq is nonempty). If the remaining delay reaches zero, clkdisp calls wakeup, which removes all processes from the sleep queue that have a zero delay. As we have seen, wakeup makes the processes ready. Finally, clkint decrements the preemption counter, calling resched if the preemption counter reaches zero.13.13 Clock InitializationClock initialization can be divided into two conceptual parts: initialization related to the operating system and initialization related to the underlying clock hardware. In terms of the operating system, the clock initialization code performs three steps. First, it allocates a queue to hold the delta list of sleeping processes, and stores the queue ID in global variable sleepq. Second, it initializes the preemption counter, preempt to QUANTUM. Third, the code initializes global variable clktime, which gives the seconds since the system booted, to zero.In terms of clock hardware initialization, the details vary widely among platforms. On the simplest systems, the clock hardware is completely preconfigured — both the in-terrupt vector and clock rate are hardwired. On most systems, the hardware is parameterized, which means the operating system can control the rate at which inter-rupts are generated. The operating system, may also be able to assign an interrupt vec-tor.Both the Galileo and BeagleBone Black platforms have configurable clock hardware. On the Galileo, the operating system must assign an interrupt vector, set the mode of the clock, and set the exact clock rate. Our code calls set_evec to configure clkdisp to be the function that receives interrupts. It then uses an outb call to configure the clock as a 16-bit timer. Finally, our code uses two calls of outb to configure the 16-bit rate register to 1193, which will cause the clock to interrupt once per millisecond. The clock initialization code for the Galileo can be found in file clkinit.c.252 Real-time Clock Management Chap. 13//**ccllkkiinniitt..cc--ccllkkiinniitt((xx8866))**//##iinncclluuddee<<xxiinnuu..hh>>uuiinntt3322ccllkkttiimmee;;//**SSeeccoonnddssssiinncceebboooott**//uuiinntt3322ccttrr11000000==00;;//**MMiilllliisseeccoonnddssssiinncceebboooott**//qqiidd1166sslleeeeppqq;;//**QQuueeuueeooffsslleeeeppiinnggpprroocceesssseess**//uuiinntt3322pprreeeemmpptt;;//**PPrreeeemmppttiioonnccoouunntteerr**////**------------------------------------------------------------------------------------------------------------------------------------------------**ccllkkiinniitt--IInniittiiaalliizzeetthheecclloocckkaannddsslleeeeppqquueeuueeaattssttaarrttuupp((xx8866))**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddccllkkiinniitt((vvooiidd)){{uuiinntt1166iinnttvv;;//**CClloocckkrraatteeiinnKKHHzz**////**AAllllooccaatteeaaqquueeuueettoohhoollddtthheeddeellttaalliissttooffsslleeeeppiinnggpprroocceesssseess**//sslleeeeppqq==nneewwqquueeuuee(());;//**IInniittiiaalliizzeetthheepprreeeemmppttiioonnccoouunntt**//pprreeeemmpptt==QQUUAANNTTUUMM;;//**IInniittiiaalliizzeetthheettiimmeessiinncceebboooottttoozzeerroo**//ccllkkttiimmee==00;;//**SSeettiinntteerrrruuppttvveeccttoorrffoorrtthheecclloocckkttooiinnvvookkeeccllkkddiisspp**//sseett__eevveecc((IIRRQQBBAASSEE,,((uuiinntt3322))ccllkkddiisspp));;//**SSeetttthheehhaarrddwwaarreecclloocckk::ttiimmeerr00,,1166--bbiittccoouunntteerr,,rraattee**////**ggeenneerraattoorrmmooddee,,aannddccoouunntteerrrruunnssiinnbbiinnaarryy**//oouuttbb((CCLLKKCCNNTTLL,,00xx3344));;//**SSeetttthheecclloocckkrraatteettoo11..119900MMhhzz;;tthhiissiiss11mmssiinntteerrrruuppttrraattee**//iinnttvv==11119933;;//**UUssiinngg11119933iinnsstteeaaddooff11119900ttooffiixxcclloocckksskkeeww**////**MMuussttwwrriitteeLLSSBBffiirrsstt,,tthheennMMSSBB**//oouuttbb((CCLLOOCCKK00,,((cchhaarr))((00xxffff&&iinnttvv))));;Sec. 13.13        Clock Initialization 253oouuttbb((CCLLOOCCKK00,,((cchhaarr))((00xxffff&&((iinnttvv>>>>88))))));;rreettuurrnn;;}}The clock initialization code for the BeagleBone Black is also in a file namedclkinit.c; the first line of the file indicates the platform.//**ccllkkiinniitt..cc--ccllkkiinniitt((BBeeaagglleeBBoonneeBBllaacckk))**//##iinncclluuddee<<xxiinnuu..hh>>uuiinntt3322ccllkkttiimmee;;//**SSeeccoonnddssssiinncceebboooott**//uuiinntt3322ccttrr11000000==00;;//**MMiilllliisseeccoonnddssssiinncceebboooott**//qqiidd1166sslleeeeppqq;;//**QQuueeuueeooffsslleeeeppiinnggpprroocceesssseess**//uuiinntt3322pprreeeemmpptt;;//**PPrreeeemmppttiioonnccoouunntteerr**////**------------------------------------------------------------------------------------------------------------------------------------------------**ccllkkiinniitt--IInniittiiaalliizzeetthheecclloocckkaannddsslleeeeppqquueeuueeaattssttaarrttuupp**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddccllkkiinniitt((vvooiidd)){{vvoollaattiilleessttrruuccttaamm333355xx__ttiimmeerr11mmss**ccssrrppttrr==((vvoollaattiilleessttrruuccttaamm333355xx__ttiimmeerr11mmss**))AAMM333355XX__TTIIMMEERR11MMSS__AADDDDRR;;//**PPooiinntteerrttoottiimmeerrCCSSRRiinnBBBBoonneeBBllaacckk**//vvoollaattiilleeuuiinntt3322**ccllkkccttrrll==((vvoollaattiilleeuuiinntt3322**))AAMM333355XX__TTIIMMEERR11MMSS__CCLLKKCCTTRRLL__AADDDDRR;;**ccllkkccttrrll==AAMM333355XX__TTIIMMEERR11MMSS__CCLLKKCCTTRRLL__EENN;;wwhhiillee((((**ccllkkccttrrll))!!==00xx22))//**DDoonnootthhiinngg**//;;//**RReesseetttthheettiimmeerrmmoodduullee**//ccssrrppttrr-->>ttiiooccpp__ccffgg||==AAMM333355XX__TTIIMMEERR11MMSS__TTIIOOCCPP__CCFFGG__SSOOFFTTRREESSEETT;;//**WWaaiittuunnttiilltthheerreesseettoossccoommpplleettee**//wwhhiillee((((ccssrrppttrr-->>ttiissttaatt&&AAMM333355XX__TTIIMMEERR11MMSS__TTIISSTTAATT__RREESSEETTDDOONNEE))====00))//**DDoonnootthhiinngg**//;;//**SSeettiinntteerrrruuppttvveeccttoorrffoorrcclloocckkttooiinnvvookkeeccllkkiinntt**//sseett__eevveecc((AAMM333355XX__TTIIMMEERR11MMSS__IIRRQQ,,((uuiinntt3322))ccllkkhhaannddlleerr));;254 Real-time Clock Management Chap. 13sslleeeeppqq==nneewwqquueeuuee(());;//**AAllllooccaatteeaaqquueeuueettoohhoollddtthheeddeellttaa**////**lliissttooffsslleeeeppiinnggpprroocceesssseess**//pprreeeemmpptt==QQUUAANNTTUUMM;;//**SSeetttthheepprreeeemmppttiioonnttiimmee**//ccllkkttiimmee==00;;//**SSttaarrttccoouunnttiinnggsseeccoonnddss**////**TThheeffoolllloowwiinnggvvaalluueessaarreeccaallccuullaatteeddffoorraa**////**ttiimmeerrtthhaattggeenneerraatteess11mmssttiicckkrraattee**//ccssrrppttrr-->>ttppiirr==11000000000000;;ccssrrppttrr-->>ttnniirr==00;;ccssrrppttrr-->>ttllddrr==00xxFFFFFFFFFFFFFFFF--2266000000;;//**SSeetttthheettiimmeerrttooaauuttoorreellooaadd**//ccssrrppttrr-->>ttccllrr==AAMM333355XX__TTIIMMEERR11MMSS__TTCCLLRR__AARR;;//**SSttaarrtttthheettiimmeerr**//ccssrrppttrr-->>ttccllrr||==AAMM333355XX__TTIIMMEERR11MMSS__TTCCLLRR__SSTT;;//**EEnnaabblleeoovveerrfflloowwiinntteerrrruuppttwwhhiicchhwwiillllggeenneerraattee**////**aanniinntteerrrruupptteevveerryy11mmss**//ccssrrppttrr-->>ttiieerr==AAMM333355XX__TTIIMMEERR11MMSS__TTIIEERR__OOVVFF__IITT__EENNAA;;//**KKiicckkssttaarrtttthheettiimmeerr**//ccssrrppttrr-->>ttttggrr==11;;rreettuurrnn;;}}13.14 PerspectiveClock and timer management are both technically and intellectually challenging. On the one hand, because clock or timer interrupts occur frequently and have high priority, the total time a processor spends executing clock interrupts is large and other interrupts are prevented. Thus, the code for an interrupt handler must be written care-fully to minimize the time taken to handle a given interrupt. On the other hand, an operating system that allows processes to request timed events can schedule many events to occur at exactly the same time, which means that the time taken for a givenSec. 13.14        Perspective255interrupt can be arbitrarily long. The conflict can become especially important in real-time embedded systems where the processor is relatively slow and other devices need prompt service.Most systems allow arbitrary events to be scheduled and defer processing when multiple events collide — a cell phone may not update the display exactly when an ap-plication starts, or a text message may take longer to deliver when multiple applications are running. The intellectual questions are: how can an operating system best provide the illusion of precise timing within hardware constraints and inform users when re-quests cannot be serviced? Should events be assigned priorities? If so, how should event priorities interact with scheduling priorities? There are no easy answers.13.15 SummaryA real-time clock interrupts the processor at regular intervals. An operating system uses the clock to handle preemption and process delay. A preemption event, scheduled every time the system switches context, forces a call to the scheduler after a process has used the processor for QUANTUM clock ticks. Preemption guarantees that no process uses the processor forever, and enforces the scheduling policy by ensuring round-robin service among equal-priority processes.A delta list provides an efficient way to manage sleeping processes. When a proc-ess requests a timed delay (i.e., sleeps), the process places itself on the delta list of sleeping processes. Later, when its delay expires, the clock interrupt handler awakens the sleeping process by moving the process back to the ready list and rescheduling.EXERCISES13.1 Modify the code to generate clock interrupts ten times faster, and arrange for the clockinterrupt handler to ignore nine interrupts before processing one. How much extra over-head do the additional interrupts generate?13.2 Trace the series of function calls that occur starting with a clock interrupt that awakenstwo sleeping processes, one of which has higher priority than the currently executing process.13.3  Explain what can fail if QUANTUM is set to 1. Hint: consider switching back to a proc-ess that was suspended by resched while processing an interrupt.13.4     Does sleepms(3) guarantee a minimum delay of 3 milliseconds, an exact delay of 3 mil-liseconds, or a maximum delay of 3 milliseconds?13.5 Explain what might happen if wakeup calls wait.13.6 An operating system that attempts to record the exact amount of processor time a proc-ess consumes faces the following problem: when an interrupt occurs, it is most con-venient to let the current process execute the interrupt routine even though the interrupt is unlikely to be related to the current process. Investigate how operating systems charge the cost of executing interrupt routines like wakeup to the processes that are affected.256 Real-time Clock Management Chap. 1313.7  To find out how much overhead is involved in using a high-level interrupt handler,rewrite the code to have clkint perform all clock interrupt handling. Devise a way to measure the extra overhead.13.8      Consider process scheduling and code in recvtime carefully. Show that it is possible forrecvtime to return a message, even if the message arrives long after the timer expires and the process is awakened.13.9  Design an experiment to see if preemption ever causes the system to reschedule. Becareful: the presence of a separate process testing a variable or performing I/O can inter-fere with the experiment by generating calls to resched.13.10 Suppose a system contains three processes: a low-priority process, L, that is sleeping,and two high-priority processes, H1 and H2, that are eligible to execute. Further supposethat immediately after the scheduler switches to process H1, a clock interrupt occurs, process L becomes ready, and the interrupt handler calls resched. Although L will not run, resched will switch from H1  to H2  without giving H1  its quantum. Propose a modifi-cation to resched that ensures a process will not lose control of the processor unless a higher-priority process becomes ready or its time slice expires.Chapter Contents14.1 Introduction, 25914.2 Conceptual Organization Of I/O And Device Drivers, 26014.3 Interface And Driver Abstractions, 26114.4 An Example I/O Interface, 26214.5 The Open-Read-Write-Close Paradigm, 26314.6 Bindings For I/O Operations And Device Names, 26414.7 Device Names In Xinu, 26514.8 The Concept Of A Device Switch Table, 26514.9 Multiple Copies Of A Device And Shared Drivers, 26614.10 The Implementation Of High–level I/O Operations, 269 14.11 Other High–level I/O Functions, 27114.12 Open, Close, And Reference Counting, 275 14.13 Null And Error Entries In Devtab, 27714.14 Initialization Of The I/O System, 278 14.15 Perspective, 28314.16 Summary, 28314Device–independent Input And Output
We have been left so much to our own devices — aftera while, one welcomes the uncertainty of being left to other people’s.— Tom Stoppard14.1 IntroductionEarlier chapters explain concurrent process support and memory management. Chapter 12 discusses the key concept of interrupts. The chapter describes interrupt processing, gives an architecture for interrupt code, and explains the relationship between interrupt handling and concurrent processes. Chapter 13 expands the discus-sion of interrupts by showing how real-time clock interrupts can be used to implement preemption and process delay.This chapter takes a broader look at how an operating system implements I/O. The chapter explains the conceptual basis for building I/O abstractions, and presents an architecture for a general-purpose I/O facility. The chapter shows how processes can transfer data to or from a device without understanding the underlying hardware. It de-fines a general model, and explains how the model incorporates device-independent I/O functions. Finally, the chapter examines an efficient implementation of an I/O subsys-tem.259260 Device–independent Input And Output Chap. 1414.2 Conceptual Organization Of I/O And Device DriversOperating systems control and manage input and output (I/O) devices for three reasons. First, because most device hardware uses a low-level interface, the software interface is complex. Second, because a device is a shared resource, an operating sys-tem provides access according to policies that make sharing fair and safe. Third, an operating system defines a high-level interface that hides details and allows a program-mer to use a consistent and uniform set of operations when interacting with devices.The I/O subsystem can be divided into three conceptual pieces: an abstract inter-face consisting of high-level I/O functions that processes use to perform I/O, a set of physical devices, and device driver software that connects the two. Figure 14.1 illus-trates the organization.I/O operations available to processesUser processes
device 1device driver upper-half (device 1)device driver lower-half (device 1)device 2device driver upper-half (device 2)device driver lower-half (device 2)device 3device driver upper-half (device 3)device driver lower-half (device 3)device ndevice driver upper-half (device n)device driverlower-half (device n)...device drivers
Figure 14.1The conceptual organization of the I/O subsystem with devicedriver software between processes and the underlying device hardware.As the figure indicates, device driver software bridges the gap between high-level, concurrent processes and low-level hardware. We will see that each driver is divided into two conceptual pieces: an upper half and a lower half. Functions in the upper half are invoked when a process requests I/O. Upper-half functions implement operations such as read and write by transferring data to or from a process. The lower half con-tains functions that are invoked by interrupts. When a device interrupts, the interrupt dispatcher invokes a lower-half handler function. The handler services the interrupt, in-teracts with the device to transfer data, and may start an additional I/O operation.Sec. 14.3        Interface And Driver Abstractions 26114.3 Interface And Driver AbstractionsThe ultimate goal of an operating system designer lies in creating convenient pro-gramming abstractions and finding efficient implementations. With respect to I/O,there are two aspects:Interface abstractionDriver abstractionsInterface abstraction.The question arises: what I/O interface should an operating system supply to processes? There are several possibilities, and the choice represents a tradeoff among goals of flexibility, simplicity, efficiency, and generality. To understand the scope of the problem, consider Figure 14.2, which lists a set of example devices and the types of operations appropriate for each.Device I/O paradigmhard drive move to a position and transfer a block of datakeyboard accept individual characters as enteredprinter transfer an entire document to be printedaudio output transfer a continuous stream of encoded audiowireless network send or receive a single network packetFigure 14.2  Example devices and the paradigm that each device uses.Early operating systems provided a separate set of I/O operations for each indivi-dual hardware device. Unfortunately, building device-specific information into software means the software must be changed when an I/O device is replaced by an equivalent device from another vendor. A slightly more general approach defines a set of opera-tions for each type of device, and requires the operating system to perform the appropri-ate low-level operations on a given device. For example, an operating system can offer abstract functions send_network_packet and receive_network_packet that can be used to transfer network packets over any type of network. A third approach originated in Mul-tics and was popularized by Unix: choose a small set of abstract I/O operations that are sufficient for all I/O.Driver abstractions.We think of the second category of abstraction as providing semantics. One of the most important semantic design questions focuses on synchrony: does a process block while waiting for an I/O operation to complete? A synchronous interface, similar to the one described earlier, provides blocking operations. For exam-ple, to request data from a keyboard in a synchronous system, a process invokes an262 Device–independent Input And Output Chap. 14upper-half routine that blocks the process until a user presses a key. Once a user makesa keystroke, the device interrupts and the dispatcher invokes a lower-half routine thatacts as a handler. The handler unblocks a waiting process and reschedules to allow the process to run. In contrast, an asynchronous I/O interface allows a process to continue executing after the process initiates an I/O operation. When the I/O completes, the driver must inform the requesting process (e.g., by invoking the event handler function associated with the process). We can summarize:When using a synchronous I/O interface, a process is blocked untilthe operation completes. When using an asynchronous I/O interface,a process continues to execute and is notified when the operation completes.Each approach has advantages. An asynchronous interface is useful in situations where a programmer needs to control the overlap of I/O and computation. A synchro-nous approach has the advantage of being easier to program.Another design issue arises from the format of data and the size of transfers. Two questions arise. First, will data be transferred in blocks or bytes? Second, how muchdata can be transferred in a single operation? Observe that some devices transfer indivi-dual data bytes, some transfer a variable-size chunk of data (such as a network packet or a line of text), and others, such as disks, transfer fixed-size blocks of data. Because a general-purpose operating system must handle a variety of I/O devices, an I/O interface may require both single-byte transfers as well as multi-byte transfers.A final design question arises from the parameters that a driver supplies and the way a driver interprets individual operations. For example, does a process specify a lo-cation on disk and then repeatedly request the next disk block, or does the process specify a block number in each request? The example device driver presented in the next chapter illustrates the use of parameters.The key idea is:In a modern operating system, the I/O interface and device driversare designed to hide device details and present a programmer with convenient, high-level abstractions.14.4 An Example I/O InterfaceExperience has shown that a small set of I/O functions is both sufficient and con-venient. Thus, our example system contains an I/O subsystem with nine abstract I/O operations that are used for all input and output. The operations have been derived from the I/O facilities in the Unix operating system. Figure 14.3 lists the operations and the purpose of each.Sec. 14.4        An Example I /O Interface 263Operation Purposeclose Terminate use of a devicecontrol Perform operations other than data transfergetc Input a single byte of datainit Initialize the device at system startupopen Prepare the device for useputc Output a single byte of dataread Input multiple bytes of dataseek Move to specific data (usually a disk)write Output multiple bytes of dataFigure 14.3  The set of abstract I/O interface operations used in Xinu.14.5 The Open-Read-Write-Close ParadigmLike the programming interface in many operating systems, the example I/O inter-face follows an open-read-write-close paradigm. That is, before it can perform I/O, a process must open a specific device. Once it has been opened, a device is ready for the process to call read to obtain input or write to send output. Finally, once it has finished using a device, the process calls close to terminate use.To summarize:The open-read-write-close paradigm requires a process to open a de-vice before use and close a device after use.Open and close allow the operating system to manage devices that require ex-clusive use, prepare a device for data transfer, and stop a device after transfer has end-ed. Closing a device may be useful, for example, if a device needs to be powered downor placed in a standby state when not in use.  Read and write handle the transfer of mul-tiple data bytes to or from a buffer in memory. Getc and putc form a counterpart for the transfer of a single byte (usually a character).  Control allows a program to control a device or a device driver (e.g., to check supplies in a printer or select the channel on a wireless radio). Seek is a special case of control that applies to randomly accessible storage devices, such as disks. Finally, init initializes the device and driver at system startup.264 Device–independent Input And Output Chap. 14Consider how the operations apply to a console window.  Getc reads the next char-acter from the keyboard, and putc displays one character in the console window. Writecan display multiple characters with one call, and read can read a specified number of characters (or all that have been entered, depending on its arguments). Finally, control allows the program to change parameters in the driver to control such things as whether the system stops echoing characters as a password is entered.14.6 Bindings For I/O Operations And Device NamesHow can an abstract operation such as read act on an underlying hardware device? The answer lies in a binding. When a process invokes a high-level operation, the operating system maps the call to a device driver function. For example, if a process calls read on a console device, the operating system passes the call to a function in the console device driver that implements read. In doing so, the operating system hides both the hardware and device driver details from application processes and presents an abstract version of devices. By using a single abstract device for a keyboard and a win-dow on the display, an operating system can hide the fact that the underlying hardware consists of two separate devices. Furthermore, an operating system can hide device de-tails by presenting the same high-level abstraction for the hardware from multiple ven-dors. The point is:An operating system creates a virtual I/O environment — a processcan only perceive peripheral devices through the abstractions that the interface and device drivers provide.In addition to mapping abstract I/O operations onto driver routines, an operating system must map device names onto devices. A variety of mappings have been used. Early systems required a programmer to embed device names in source code. Later systems arranged for programs to use small integers to identify devices, and allowed a command interpreter to link each integer with a specific device when the application was launched. Many modern systems embed devices in a file naming hierarchy, allow-ing an application to use a symbolic name for each device.Early and late binding each have advantages. An operating system that waits until runtime to bind the name of an abstract device to a real device and a set of abstract operations to device driver functions is flexible. However, such late binding systems incur more computational overhead, making them impractical in the smallest embedded systems. At the other extreme, early binding requires device information to be specified when an application is written. Thus, the essence of I/O design consists of synthesizing a binding mechanism that allows maximum flexibility within the required performance bounds.Our example system uses an approach that is typical of small embedded systems: information about devices is specified before the operating system is compiled. For each device, the operating system knows exactly which driver functions correspond toSec. 14.6        Bindings For I /O Operations And Device Names 265each of the abstract I/O operations. In addition, the operating system knows the under-lying hardware device to which each abstract device corresponds. Thus, the operating system must be recompiled whenever a new device is added or when an existing device is removed. Because application code does not contain information about specific de-vice hardware, application code can be ported from one system to another easily. For example, an application that only performs I/O operations on a CONSOLE serial port will work on any Xinu system that offers a CONSOLE device and the appropriate driver, independent of the physical device hardware and interrupt structure.14.7 Device Names In XinuIn Xinu, the system designer must specify a set of abstract devices when the sys-tem is configured. The configuration program assigns each device name a unique in-teger value known as a device descriptor. For example, if a designer specifies a device name CONSOLE, the configuration program might assign descriptor zero. The config-uration program produces a header file that contains #define statements for each name. Thus, once the header file has been included, a programmer can reference CONSOLE in the code. For example, if CONSOLE has been assigned descriptor zero, the call:read(CONSOLE, buf, 100);is equivalent to:read(0, buf, 100);To summarize:Xinu uses a static binding for device names. Each device name isbound to an integer descriptor at configuration time before the operating system is compiled.14.8 The Concept Of A Device Switch TableEach time a process invokes a high-level I/O operation such as read or write, the operating system must forward the call to the appropriate driver function. To make the implementation efficient, Xinu uses an array known as a device switch table. The in-teger descriptor assigned to a device is an index into the device switch table. To under-stand the arrangement, imagine a two-dimensional array. Conceptually, each row of the array corresponds to a device, and each column corresponds to an abstract operation. An entry in the array specifies the driver function to use to perform the operation.For example, suppose a system contains three devices defined as follows:CONSOLE, a serial device used to send and receive charactersETHER, an Ethernet interface deviceDISK, a hard drive266 Device–independent Input And Output Chap. 14Figure 14.4 illustrates part of a device switch table that has a row for each of the three devices and a column for each I/O operation. Items in the table represent thenames of driver functions that perform the operation given by the column on the device given by the row.open close read write getc......CONSOLEETHERDISKconopen conclose conread conwrite congetcethopen ethclose ethread ethwrite ethgetcdskopen dskclose dskread dskwrite dskgetcFigure 14.4Conceptual organization of the device switch table with one rowper device and one column per abstract I/O operation.As an example, suppose a process invokes the write operation on the CONSOLE device. The operating system goes to the row of the table that corresponds to the CON-SOLE device, finds the column that corresponds to the write operation, and calls the function named in the entry, conwrite.In essence, each row of the device switch table defines how the I/O operations ap-ply to a single device, which means I/O semantics can change dramatically among de-vices. For example, when it is applied to a DISK device, a read might transfer a block of 512 bytes of data. However, when it is applied to a CONSOLE device, read might transfer a line of characters that the user has entered.The most significant aspect of the device switch table arises from the ability to de-fine a uniform abstraction across multiple physical devices. For example, suppose a computer contains a disk that uses 1 Kbyte sectors and a disk that uses 4 Kbyte sectors. Drivers for the two disks can present an identical interface to applications, while hiding the differences in the underlying hardware. That is, a driver can always transfer 4 Kbytes to a user, and convert each transfer into four 1 Kbyte disk transfers.14.9 Multiple Copies Of A Device And Shared DriversSuppose a given computer has two devices that use identical hardware. Does the operating system need two separate copies of the device driver? No. The system con-tains one copy of each driver routine and uses a parameter to distinguish between the two devices. Parameters are kept in columns of the device switch table in addition to the functions that Figure 14.4 illustrates. For example, if a system contains two Ether-net interfaces, each will have its own row in the device switch table. Most entries inthe two rows will be identical. However, one column will specify a unique Control and Status Register (CSR) address for each device. When it invokes a driver function, theSec. 14.9        Multiple Copies Of A Device And Shared Drivers 267system passes an argument that contains a pointer to the row in the device switch tablefor the device. Thus, a driver function can apply the operation to the correct device.The point is:Instead of creating a device driver for each physical device, an operating system maintains a single copy of the driver for each type of device and supplies an argument that permits the driver to distinguish among multiple copies of the physical hardware.A look at the definition of the device switch table, devtab, will clarify the details. Structure dentry defines the format of entries in the table; the declaration can be foundin file conf.h†.//**ccoonnff..hh((GGEENNEERRAATTEEDDFFIILLEE;;DDOONNOOTTEEDDIITT))**////**DDeevviicceesswwiittcchhttaabblleeddeeccllaarraattiioonnss**////**DDeevviicceettaabblleeeennttrryy**//ssttrruuccttddeennttrryy{{iinntt3322ddvvnnuumm;;iinntt3322ddvvmmiinnoorr;;cchhaarr**ddvvnnaammee;;ddeevvccaallll((**ddvviinniitt))((ssttrruuccttddeennttrryy**));;ddeevvccaallll((**ddvvooppeenn))((ssttrruuccttddeennttrryy**,,cchhaarr**,,cchhaarr**));;ddeevvccaallll((**ddvvcclloossee))((ssttrruuccttddeennttrryy**));;ddeevvccaallll((**ddvvrreeaadd))((ssttrruuccttddeennttrryy**,,vvooiidd**,,uuiinntt3322));;ddeevvccaallll((**ddvvwwrriittee))((ssttrruuccttddeennttrryy**,,vvooiidd**,,uuiinntt3322));;ddeevvccaallll((**ddvvsseeeekk))((ssttrruuccttddeennttrryy**,,iinntt3322));;ddeevvccaallll((**ddvvggeettcc))((ssttrruuccttddeennttrryy**));;ddeevvccaallll((**ddvvppuuttcc))((ssttrruuccttddeennttrryy**,,cchhaarr));;ddeevvccaallll((**ddvvccnnttll))((ssttrruuccttddeennttrryy**,,iinntt3322,,iinntt3322,,iinntt3322));;vvooiidd**ddvvccssrr;;vvooiidd((**ddvviinnttrr))((vvooiidd));;bbyytteeddvviirrqq;;}};;eexxtteerrnnssttrruuccttddeennttrryyddeevvttaabb[[]];;//**oonneeeennttrryyppeerrddeevviiccee**////**DDeevviicceennaammeeddeeffiinniittiioonnss**//##ddeeffiinneeCCOONNSSOOLLEE00//**ttyyppeettttyy**//##ddeeffiinneeNNUULLLLDDEEVV11//**ttyyppeennuullll**//##ddeeffiinneeEETTHHEERR0022//**ttyyppeeeetthh**//†Chapter 25 explains Xinu configuration and gives more detail about conf.h.268 Device–independent Input And Output Chap. 14##ddeeffiinneeNNAAMMEESSPPAACCEE33//**ttyyppeennaamm**//##ddeeffiinneeRRDDIISSKK44//**ttyyppeerrddss**//##ddeeffiinneeRRAAMM0055//**ttyyppeerraamm**//##ddeeffiinneeRRFFIILLEESSYYSS66//**ttyyppeerrffss**//##ddeeffiinneeRRFFIILLEE0077//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE1188//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE2299//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE331100//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE441111//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE551122//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE661133//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE771144//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE881155//**ttyyppeerrffll**//##ddeeffiinneeRRFFIILLEE991166//**ttyyppeerrffll**//##ddeeffiinneeLLFFIILLEESSYYSS1177//**ttyyppeellffss**//##ddeeffiinneeLLFFIILLEE001188//**ttyyppeellffll**//##ddeeffiinneeLLFFIILLEE111199//**ttyyppeellffll**//##ddeeffiinneeLLFFIILLEE222200//**ttyyppeellffll**//##ddeeffiinneeLLFFIILLEE332211//**ttyyppeellffll**//##ddeeffiinneeLLFFIILLEE442222//**ttyyppeellffll**//##ddeeffiinneeLLFFIILLEE552233//**ttyyppeellffll**////**CCoonnttrroollbblloocckkssiizzeess**//##ddeeffiinneeNNnnuullll11##ddeeffiinneeNNttttyy11##ddeeffiinneeNNeetthh11##ddeeffiinneeNNrrddss11##ddeeffiinneeNNrraamm11##ddeeffiinneeNNrrffss11##ddeeffiinneeNNrrffll1100##ddeeffiinneeNNllffss11##ddeeffiinneeNNllffll66##ddeeffiinneeNNnnaamm11##ddeeffiinneeDDEEVVMMAAXXNNAAMMEE2244##ddeeffiinneeNNDDEEVVSS2244//**CCoonnffiigguurraattiioonnaannddSSiizzeeCCoonnssttaannttss**//##ddeeffiinneeNNPPRROOCC110000//**nnuummbbeerrooffuusseerrpprroocceesssseess**//##ddeeffiinneeNNSSEEMM110000//**nnuummbbeerrooffsseemmaapphhoorreess**//##ddeeffiinneeIIRRQQBBAASSEE3322//**bbaasseeiivveeccffoorrIIRRQQ00**//##ddeeffiinneeIIRRQQ__TTIIMMEERRIIRRQQ__HHWW55//**ttiimmeerrIIRRQQiisswwiirreeddttoohhaarrddwwaarree55**//##ddeeffiinneeIIRRQQ__AATTHH__MMIISSCCIIRRQQ__HHWW44//**MMiisscc..IIRRQQiisswwiirreeddttoohhaarrddwwaarree44**//##ddeeffiinneeCCLLKKFFRREEQQ220000000000000000//**220000MMHHzzcclloocckk**//Sec. 14.9        Multiple Copies Of A Device And Shared Drivers 269##ddeeffiinneeLLFF__DDIISSKK__DDEEVVRRAAMM00Each entry in devtab corresponds to a single device. The entry specifies the ad-dress of functions that constitute the driver for the device, the device CSR address, and other information used by the driver. Fields dvinit, dvopen, dvclose, dvread, dvwrite, dvseek, dvgetc, dvputc, and dvcntl hold the addresses of driver routines that correspond to high-level operations. Field dvminor contains an integer index into the control block array for the device. A minor device number accommodates multiple identical hardware devices by allowing a driver to maintain a separate control block entry for each physical device. Field dvcsr contains the hardware CSR address for the device. The control block for a device holds additional information for the particular instance of the device and the driver; the contents depend on the device, but may include such things as input or output buffers, device status information (e.g., whether a wireless net-working device is currently in contact with another wireless device), and accounting in-formation (e.g., the total amount of data sent or received since the system booted).14.10 The Implementation Of High–level I/O OperationsBecause it isolates high-level I/O operations from underlying details, the device switch table allows high-level functions to be created before any device drivers have been written. One of the chief benefits of such a strategy arises because a programmercan build pieces of the I/O system without requiring specific hardware devices to be present.The example system contains a function for each high-level I/O operation. Thus,the system contains functions open, close, read, write, getc, putc, and so on. However,a function such as read does not perform I/O. Instead, each high-level I/O function operates indirectly: the function uses the device switch table to find and invoke the ap-propriate low-level device driver routine to perform the requested function. The point is:Instead of performing I/O, high-level functions such as read and writeuse a level of indirection to invoke a low-level driver function for the specified device.An examination of the code will clarify the concept. Consider the read functionfound in file read.c:270 Device–independent Input And Output Chap. 14//**rreeaadd..cc--rreeaadd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rreeaadd--RReeaaddoonneeoorrmmoorreebbyytteessffrroommaaddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllrreeaadd((ddiidd3322ddeessccrrpp,,//**DDeessccrriippttoorrffoorrddeevviiccee**//cchhaarr**bbuuffffeerr,,//**AAddddrreessssooffbbuuffffeerr**//uuiinntt3322ccoouunntt//**LLeennggtthhooffbbuuffffeerr**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvrreeaadd))((ddeevvppttrr,,bbuuffffeerr,,ccoouunntt));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}The arguments to read consist of a device descriptor, the address of a buffer, and an integer that gives the maximum number of bytes to read.  Read uses the device descriptor, descrp, as an index into devtab, and assigns pointer devptr the address of the device switch table entry. The return statement contains code that performs the task of invoking the underlying device driver function and returning the result to the function that called read. The code:(*devptr->dvread) (devptr, buffer, count)performs the indirect function call. That is, the code invokes the driver function givenby field dvread in the device switch table entry, passing the function three arguments:the address of the devtab entry, devptr, the buffer address, buffer, and a count of charac-ters to read, count.Sec. 14.11        Other High–level I  /O Functions 27114.11 Other High–level I/O FunctionsThe remaining high-level transfer and control functions operate exactly as read: they use the device switch table to select the appropriate low-level driver function, in-voke the function, and return the result to the caller. Code for each function is shown below.//**ccoonnttrrooll..cc--ccoonnttrrooll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ccoonnttrrooll--CCoonnttrroollaaddeevviicceeoorraaddrriivveerr((ee..gg..,,sseetttthheeddrriivveerrmmooddee))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllccoonnttrrooll((ddiidd3322ddeessccrrpp,,//**DDeessccrriippttoorrffoorrddeevviiccee**//iinntt3322ffuunncc,,//**SSppeecciiffiiccccoonnttrroollffuunnccttiioonn**//iinntt3322aarrgg11,,//**SSppeecciiffiiccaarrgguummeennttffoorrffuunncc**//iinntt3322aarrgg22//**SSppeecciiffiiccaarrgguummeennttffoorrffuunncc**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvccnnttll))((ddeevvppttrr,,ffuunncc,,aarrgg11,,aarrgg22));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}272 Device–independent Input And Output Chap. 14//**ggeettcc..cc--ggeettcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettcc--OObbttaaiinnoonneebbyytteeffrroommaaddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllggeettcc((ddiidd3322ddeessccrrpp//**DDeessccrriippttoorrffoorrddeevviiccee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvggeettcc))((ddeevvppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}} //**ppuuttcc..cc--ppuuttcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppuuttcc--SSeennddoonneecchhaarraacctteerrooffddaattaa((bbyyttee))ttooaaddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllppuuttcc((ddiidd3322ddeessccrrpp,,//**DDeessccrriippttoorrffoorrddeevviiccee**//cchhaarrcchh//**CChhaarraacctteerrttoosseenndd**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//Sec. 14.11        Other High–level I  /O Functions 273mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvppuuttcc))((ddeevvppttrr,,cchh));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}} //**sseeeekk..cc--sseeeekk**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**sseeeekk--PPoossiittiioonnaarraannddoommaacccceessssddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllsseeeekk((ddiidd3322ddeessccrrpp,,//**DDeessccrriippttoorrffoorrddeevviiccee**//uuiinntt3322ppooss//**PPoossiittiioonn**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvsseeeekk))((ddeevvppttrr,,ppooss));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}274 Device–independent Input And Output Chap. 14//**wwrriittee..cc--wwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**wwrriittee--WWrriitteeoonneeoorrmmoorreebbyytteessttooaaddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllwwrriittee((ddiidd3322ddeessccrrpp,,//**DDeessccrriippttoorrffoorrddeevviiccee**//cchhaarr**bbuuffffeerr,,//**AAddddrreessssooffbbuuffffeerr**//uuiinntt3322ccoouunntt//**LLeennggtthhooffbbuuffffeerr**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvwwrriittee))((ddeevvppttrr,,bbuuffffeerr,,ccoouunntt));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}The functions listed above are designed to allow user processes to access I/O de-vices. In addition, the system provides one high-level I/O function that is intended only for the operating system to use: init. We will see that when it boots, the operating sys-tem calls init for each device. Like the other I/O functions, init uses the device switch table to invoke the appropriate low-level driver function. Thus, the initialization func-tion in each driver can initialize the hardware device, if necessary, and can also initial-ize the data structures used by the driver (e.g., buffers and semaphores). We will see examples of driver initialization later. For now, it is sufficient to understand that init follows the same approach as other I/O functions:Sec. 14.11        Other High–level I  /O Functions 275//**iinniitt..cc--iinniitt**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**iinniitt--IInniittiiaalliizzeeaaddeevviicceeaannddiittssddrriivveerr**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaalllliinniitt((ddiidd3322ddeessccrrpp//**DDeessccrriippttoorrffoorrddeevviiccee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvviinniitt))((ddeevvppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}14.12 Open, Close, And Reference CountingFunctions open and close operate similar to other I/O functions by using the de-vice switch table to call the appropriate driver function. One motivation for using open and close arises from their ability to establish ownership of a device or prepare a device for use. For example, if a device requires exclusive access, open can block a subse-quent user until the device becomes free. As another example, consider a system that saves power by keeping a disk device idle when the device is not in use. Although a designer could arrange to use the control function to start or stop a disk, open and close are more convenient. Thus, a disk can be powered on when a process calls open, and powered off when a process calls close.Although a small embedded system might choose to power down a disk whenever a process calls close on the device, larger systems need a more sophisticated mechanism because multiple processes can use a device simultaneously. Thus, most drivers employ a technique known as reference counting. That is, a driver maintains an integer variable276 Device–independent Input And Output Chap. 14that counts the number of processes using the device. During initialization, the refer-ence count is set to zero. Whenever a process calls open, the driver increments the reference count, and whenever a process calls close, the driver decrements the reference count. When the reference count reaches zero, the driver powers down the device.The code for open and close follows the same approach as the code for otherhigh-level I/O functions://**ooppeenn..cc--ooppeenn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ooppeenn--OOppeennaaddeevviiccee((ssoommeeddeevviicceessiiggnnoorreennaammeeaannddmmooddeeppaarraammeetteerrss))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllooppeenn((ddiidd3322ddeessccrrpp,,//**DDeessccrriippttoorrffoorrddeevviiccee**//cchhaarr**nnaammee,,//**NNaammeettoouussee,,iiffaannyy**//cchhaarr**mmooddee//**MMooddeeffoorrddeevviiccee,,iiffaannyy**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvooppeenn))((ddeevvppttrr,,nnaammee,,mmooddee));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}} //**cclloossee..cc--cclloossee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**cclloossee--CClloosseeaaddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//Sec. 14.12        Open, Close, And Reference Counting 277ssyyssccaallllcclloossee((ddiidd3322ddeessccrrpp//**DDeessccrriippttoorrffoorrddeevviiccee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322rreettvvaall;;//**VVaalluueettoorreettuurrnnttooccaalllleerr**//mmaasskk==ddiissaabbllee(());;iiff((iissbbaaddddeevv((ddeessccrrpp)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[ddeessccrrpp]];;rreettvvaall==((**ddeevvppttrr-->>ddvvcclloossee))((ddeevvppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}14.13 Null And Error Entries In DevtabAn interesting dilemma arises from the way I/O functions operate. On the onehand, high-level functions, such as read and write, use entries in devtab without check-ing whether the entries are valid. Thus, a function must be supplied for every I/O operation for each device. On the other hand, an operation may not be meaningful on all devices. For example, seek is not an operation that can be performed on a serial de-vice, and getc is not meaningful on a network device that delivers packets. Further-more, a designer may choose to ignore an operation on a particular device (e.g., a designer may choose to leave the CONSOLE device open at all times, which means the close operation has no effect).What value can be used in devtab for operations that are not meaningful? Theanswer lies in two special routines that can be used to fill in entries of devtab that haveno driver functions:ionull — return OK without performing any actionioerr — return SYSERR without performing any actionBy convention, entries filled with ioerr should never be called; they signify an ille-gal operation. Entries for unnecessary, but otherwise innocuous operations (e.g., openfor a terminal device), point to function ionull. The code for each of the two functionsis trivial.278 Device–independent Input And Output Chap. 14//**iioonnuullll..cc--iioonnuullll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**iioonnuullll--DDoonnootthhiinngg((uusseeddffoorr""ddoonn’’ttccaarree""eennttrriieessiinnddeevvttaabb))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaalllliioonnuullll((vvooiidd)){{rreettuurrnnOOKK;;}} //**iiooeerrrr..cc--iiooeerrrr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**iiooeerrrr--RReettuurrnnaanneerrrroorrssttaattuuss((uusseeddffoorr""eerrrroorr""eennttrriieessiinnddeevvttaabb))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaalllliiooeerrrr((vvooiidd)){{rreettuurrnnSSYYSSEERRRR;;}}14.14 Initialization Of The I/O SystemHow is a device switch table initialized? How are driver functions installed? In a large, complex operating system, device drivers can be managed dynamically. Thus, when it finds new device hardware, the operating system can identify the hardware,search for an appropriate driver, and install the driver without rebooting.A small embedded system does not have a collection of drivers available on secon-dary storage, and may not have sufficient computational resources to install drivers at runtime. Thus, most embedded systems use a static device configuration in which the set of devices and the set of device drivers are specified when the system is compiled. Our example follows the static approach by requiring the system designer to specify a set of devices and the set of low-level driver functions that constitute each driver. In-stead of forcing a programmer to enter explicit declarations for the entire device switch table, however, a separate application program is used that reads a configuration file and generates a C file that contains a declaration of devtab with an initial value for each field. The point is:Sec. 14.14        Initialization Of The I /O System 279Small embedded systems use a static device specification in which a designer specifies the set of devices plus the device driver functions for each; a configuration program can generate code that assigns a value to each field of the device switch table.File conf.c contains an example of the C code generated by the configuration pro-gram. Chapter 25 explains how conf.c is generated; for now, it is sufficient to examineone of the entries in devtab and observe how each field is initialized.//**ccoonnff..cc((GGEENNEERRAATTEEDDFFIILLEE;;DDOONNOOTTEEDDIITT))**//##iinncclluuddee<<xxiinnuu..hh>>eexxtteerrnnddeevvccaalllliiooeerrrr((vvooiidd));;eexxtteerrnnddeevvccaalllliioonnuullll((vvooiidd));;//**DDeevviicceeiinnddeeppeennddeennttII//OOsswwiittcchh**//ssttrruuccttddeennttrryyddeevvttaabb[[NNDDEEVVSS]]=={{ //******FFoorrmmaattooffeennttrriieessiiss::**ddeevv--nnuummbbeerr,,mmiinnoorr--nnuummbbeerr,,ddeevv--nnaammee,,**iinniitt,,ooppeenn,,cclloossee,,**rreeaadd,,wwrriittee,,sseeeekk,,**ggeettcc,,ppuuttcc,,ccoonnttrrooll,,**ddeevv--ccssrr--aaddddrreessss,,iinnttrr--hhaannddlleerr,,iirrqq**////**CCOONNSSOOLLEEiissttttyy**//{{00,,00,,""CCOONNSSOOLLEE"",,((vvooiidd**))ttttyyiinniitt,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iioonnuullll,,((vvooiidd**))ttttyyrreeaadd,,((vvooiidd**))ttttyywwrriittee,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))ttttyyggeettcc,,((vvooiidd**))ttttyyppuuttcc,,((vvooiidd**))ttttyyccoonnttrrooll,,((vvooiidd**))00xx33ff88,,((vvooiidd**))ttttyyddiissppaattcchh,,4422}},,//**NNUULLLLDDEEVViissnnuullll**//{{11,,00,,""NNUULLLLDDEEVV"",,((vvooiidd**))iioonnuullll,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iioonnuullll,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iiooeerrrr,,00}},,280 Device–independent Input And Output Chap. 14//**EETTHHEERR00iisseetthh**//{{22,,00,,""EETTHHEERR00"",,((vvooiidd**))eetthhiinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))eetthhrreeaadd,,((vvooiidd**))eetthhwwrriittee,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))eetthhccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))eetthhddiissppaattcchh,,4433}},,//**NNAAMMEESSPPAACCEEiissnnaamm**//{{33,,00,,""NNAAMMEESSPPAACCEE"",,((vvooiidd**))nnaammiinniitt,,((vvooiidd**))nnaammooppeenn,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iiooeerrrr,,00}},,//**RRDDIISSKKiissrrddss**//{{44,,00,,""RRDDIISSKK"",,((vvooiidd**))rrddssiinniitt,,((vvooiidd**))rrddssooppeenn,,((vvooiidd**))rrddsscclloossee,,((vvooiidd**))rrddssrreeaadd,,((vvooiidd**))rrddsswwrriittee,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrddssccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRAAMM00iissrraamm**//{{55,,00,,""RRAAMM00"",,((vvooiidd**))rraammiinniitt,,((vvooiidd**))rraammooppeenn,,((vvooiidd**))rraammcclloossee,,((vvooiidd**))rraammrreeaadd,,((vvooiidd**))rraammwwrriittee,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEESSYYSSiissrrffss**//{{66,,00,,""RRFFIILLEESSYYSS"",,((vvooiidd**))rrffssiinniitt,,((vvooiidd**))rrffssooppeenn,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffssccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE00iissrrffll**//{{77,,00,,""RRFFIILLEE00"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE11iissrrffll**//{{88,,11,,""RRFFIILLEE11"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,Sec. 14.14        Initialization Of The I /O System 281((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE22iissrrffll**//{{99,,22,,""RRFFIILLEE22"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE33iissrrffll**//{{1100,,33,,""RRFFIILLEE33"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE44iissrrffll**//{{1111,,44,,""RRFFIILLEE44"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE55iissrrffll**//{{1122,,55,,""RRFFIILLEE55"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE66iissrrffll**//{{1133,,66,,""RRFFIILLEE66"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE77iissrrffll**//{{1144,,77,,""RRFFIILLEE77"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,282 Device–independent Input And Output Chap. 14//**RRFFIILLEE88iissrrffll**//{{1155,,88,,""RRFFIILLEE88"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**RRFFIILLEE99iissrrffll**//{{1166,,99,,""RRFFIILLEE99"",,((vvooiidd**))rrfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))rrffllcclloossee,,((vvooiidd**))rrffllrreeaadd,,((vvooiidd**))rrffllwwrriittee,,((vvooiidd**))rrffllsseeeekk,,((vvooiidd**))rrffllggeettcc,,((vvooiidd**))rrffllppuuttcc,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEESSYYSSiissllffss**//{{1177,,00,,""LLFFIILLEESSYYSS"",,((vvooiidd**))llffssiinniitt,,((vvooiidd**))llffssooppeenn,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEE00iissllffll**//{{1188,,00,,""LLFFIILLEE00"",,((vvooiidd**))llfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))llffllcclloossee,,((vvooiidd**))llffllrreeaadd,,((vvooiidd**))llffllwwrriittee,,((vvooiidd**))llffllsseeeekk,,((vvooiidd**))llffllggeettcc,,((vvooiidd**))llffllppuuttcc,,((vvooiidd**))llffllccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEE11iissllffll**//{{1199,,11,,""LLFFIILLEE11"",,((vvooiidd**))llfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))llffllcclloossee,,((vvooiidd**))llffllrreeaadd,,((vvooiidd**))llffllwwrriittee,,((vvooiidd**))llffllsseeeekk,,((vvooiidd**))llffllggeettcc,,((vvooiidd**))llffllppuuttcc,,((vvooiidd**))llffllccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEE22iissllffll**//{{2200,,22,,""LLFFIILLEE22"",,((vvooiidd**))llfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))llffllcclloossee,,((vvooiidd**))llffllrreeaadd,,((vvooiidd**))llffllwwrriittee,,((vvooiidd**))llffllsseeeekk,,((vvooiidd**))llffllggeettcc,,((vvooiidd**))llffllppuuttcc,,((vvooiidd**))llffllccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEE33iissllffll**//{{2211,,33,,""LLFFIILLEE33"",,Sec. 14.14        Initialization Of The I /O System 283((vvooiidd**))llfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))llffllcclloossee,,((vvooiidd**))llffllrreeaadd,,((vvooiidd**))llffllwwrriittee,,((vvooiidd**))llffllsseeeekk,,((vvooiidd**))llffllggeettcc,,((vvooiidd**))llffllppuuttcc,,((vvooiidd**))llffllccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEE44iissllffll**//{{2222,,44,,""LLFFIILLEE44"",,((vvooiidd**))llfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))llffllcclloossee,,((vvooiidd**))llffllrreeaadd,,((vvooiidd**))llffllwwrriittee,,((vvooiidd**))llffllsseeeekk,,((vvooiidd**))llffllggeettcc,,((vvooiidd**))llffllppuuttcc,,((vvooiidd**))llffllccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}},,//**LLFFIILLEE55iissllffll**//{{2233,,55,,""LLFFIILLEE55"",,((vvooiidd**))llfflliinniitt,,((vvooiidd**))iiooeerrrr,,((vvooiidd**))llffllcclloossee,,((vvooiidd**))llffllrreeaadd,,((vvooiidd**))llffllwwrriittee,,((vvooiidd**))llffllsseeeekk,,((vvooiidd**))llffllggeettcc,,((vvooiidd**))llffllppuuttcc,,((vvooiidd**))llffllccoonnttrrooll,,((vvooiidd**))00xx00,,((vvooiidd**))iioonnuullll,,00}}}};;14.15 PerspectiveDevice-independent I/O is now an integral part of mainstream computing, and the advantages seem obvious. However, it took decades for the computing community to reach consensus on device-independent I/O and to devise a set of primitives. Some of the contention arose because programming languages each define a set of I/O abstrac-tions. For example, FORTRAN used device numbers and required a mechanism that could bind each number to an I/O device or file. Operating system designers wanted to accommodate all languages because a large volume of code has been written in each. So, questions arise. Have we chosen the best set of device-independent I/O functions, or have we merely become so accustomed to using them that we fail to look for alterna-tives? Are the functions we are using ideal for systems that focus on graphical devices?14.16 SummaryAn operating system hides the details of peripheral devices, and provides a set of abstract, device-independent functions that can be used to perform I/O. The example system uses nine abstract functions: open, close, control, getc, putc, read, write, seek, and an initialization function, init. In our design, each of the I/O primitives operates synchronously, delaying a calling process until the request has been satisfied (e.g., func-tion read delays the calling process until data has arrived).The example system defines an abstract device name (such as CONSOLE) for each device, and assigns the device a unique integer device descriptor. The system uses a device switch table to bind a descriptor to a specific device at runtime. Conceptually, the device switch table contains one row for each device and one column for each284 Device–independent Input And Output Chap. 14abstract I/O operation; additional columns point to a control block for the device, and a minor device number is used to distinguish among multiple copies of a physical device. A high-level I/O operation, such as read or write, uses the device switch table to invoke the device driver function that performs the requested operation on the specified device. Individual drivers interpret the calls in a way meaningful to a particular device; if an operation makes no sense when applied to a particular device, the device switch table is configured to invoke function ioerr, which returns an error code.EXERCISES14.1 Identify the set of abstract I/O operations available in Linux.14.2 Find a system that uses asynchronous I/O, and identify the mechanism by which a run-ning program is notified when the operation completes. Which approach, synchronousor asynchronous, makes it easier to program? Explain.14.3  The chapter discusses two separate bindings: the binding from a device name (e.g.,CONSOLE) to a descriptor (e.g., 0) and the binding from a device descriptor to a specif-ic hardware device. Explain how Linux performs the two bindings.14.4  Consider the implementation of device names in the example code. Is it possible towrite a program that allows a user to enter a device name (e.g., CONSOLE), and thenopen the device? Why or why not?14.5      Assume that in the course of debugging you begin to suspect that a process is making in-correct calls to high-level I/O functions (e.g., calling seek on a device for which the operation makes no sense). How can you make a quick change to the code to intercept such errors and display the process ID of the offending process? (Make the change without recompiling the source code.)14.6      Are the abstract I/O operations presented in the chapter sufficient for all I/O operations?Explain. Hint: consider socket functions found in Unix.14.7 Xinu defines the device subsystem as the fundamental I/O abstraction and merges filesinto the device system. Unix systems define the file system as the fundamental abstrac-tion and merge devices into the file system. Compare the two approaches and list the advantages of each.Chapter Contents15.1 Introduction, 28715.2 Serial Communication Using UART Hardware, 28715.3 The Tty Abstraction, 28815.4 Organization Of A Tty Device Driver, 28915.5 Request Queues And Buffers, 29015.6 Synchronization Of Upper Half And Lower Half, 29115.7 UART Hardware FIFOs And Driver Design, 29215.8 The Concept Of A Control Block, 29315.9 Tty Control Block And Data Declarations, 29315.10 Minor Device Numbers, 29615.11 Upper–half Tty Character Input (ttygetc), 297 15.12 Upper–half Tty Read Function (ttyread), 298 15.13 Upper–half Tty Character Output (ttyputc), 300 15.14 Starting Output (ttykickout), 30115.15 Upper–half Tty Multiple Character Output (ttywrite), 302 15.16 Lower–half Tty Driver Function (ttyhandler), 30315.17 Output Interrupt Processing (ttyhandle_out), 306 15.18 Tty Input Processing (ttyhandle_in), 30815.19 Tty Control Block Initialization (ttyinit), 315 15.20 Device Driver Control (ttycontrol), 31715.21 Perspective, 319 15.22 Summary, 32015An Example Device Driver
It’s hard to find a good driver these days, one with character and style.— Unknown15.1 IntroductionChapters in this section of the text explore the general structure of an I/O system, including interrupt processing and real-time clock management. The previous chapter presents the organization of the I/O subsystem, a set of abstract I/O operations, and an efficient implementation using a device switch table.This chapter continues the exploration of I/O. The chapter explains how a driver can define an I/O service at a high level of abstraction that is independent of the under-lying hardware. The chapter also elaborates on the conceptual division of a device driver into upper and lower halves by explaining how the two halves share data struc-tures, such as buffers, and how they communicate. Finally, the chapter shows the de-tails of a particular example: a driver for an asynchronous character-oriented serial de-vice.15.2 Serial Communication Using UART HardwareThe console line on most embedded systems uses a Universal Asynchronous Transmitter and Receiver (UART) chip that implements serial communication according to the RS-232 standard. UART hardware is primitive — it only provides the ability to send and receive individual bytes. It does not interpret the meaning of bytes or provide functions such as the use of backspace to erase previous input.287288 An Example Device Driver Chap. 1515.3 The Tty AbstractionXinu uses the name tty to refer to the abstraction of an interface used with a character-oriented text window that displays characters the user enters on a serial inter-face, such as a keyboard.† In broad terms, a tty device supports two-way communica-tion: a process can send characters to the output side and/or receive characters from the input side. Although the underlying serial hardware mechanism operates the input and output independently, the tty abstraction allows the two to be treated as a single mecha-nism in which the input and output appear to be connected. For example, our tty driver supports character echo, which means that the input side of the driver can output a copy of each incoming character. Echo is especially important when a user is typing on a keyboard and expects to see characters displayed on a screen.The tty abstraction illustrates an important feature of many device drivers: multiple modes. At any time, the driver operates in one mode, and the mode can be changed at runtime. Figure 15.1 summarizes the three modes our driver supports.Mode MeaningThe driver delivers each incoming character as it arrivesraw without echoing the character, buffering a line of text,performing translation, or controlling the output flowThe driver buffers input, echoes characters in a readablecooked form, honors backspace and line kill, allows type-ahead,handles flow control, and delivers an entire line of textThe driver handles character translation, echoing, andcbreak flow control, but instead of buffering an entire line of text,the driver delivers each incoming character as it arrivesFigure 15.1  Three modes supported by the tty abstraction.Raw mode is intended to give applications access to input characters with no pre-processing. In raw mode, the tty driver merely delivers input without interpreting or changing characters. The driver does not echo characters nor does it handle flow con-trol. Raw mode is useful when handling non-interactive communication, such as down-loading a binary file over a serial line or using a serial device to control a sensor.Cooked mode handles interactive keyboard input. Each time it receives a charac-ter, the driver echoes the character (i.e., transmits a copy of the character to the output), which allows a user to see characters as they are typed. The driver has a parameter to control character echoing, which means an application can turn echo off and back on (e.g., to prompt for a password). Cooked mode supports line buffering, which means that the driver collects all characters of a line before delivering them to a reading proc-†The name tty is taken from early Unix systems that used an ASCII Teletype device that consisted of akeyboard and an associated printer mechanism.Sec. 15.3        The Tty Abstraction 289ess. Because the tty driver performs character echo and other functions at interrupttime, a user can type ahead, even if no application is reading characters (e.g., a user can type the next command while the current command is running). A chief advantage of cooked mode arises from the ability to edit a line, either by backspacing or by typing a special character to erase the entire line.Cooked mode also provides flow control and input mapping. When enabled, flow control allows a user to type control-s to stop output temporarily, and later to type control-q to restart output. Input mapping handles hardware (or applications) that usethe two-character sequence of carriage return (cr) and linefeed (lf) to terminate a line of text instead of a single lf. Cooked mode contains a crlf† parameter that controls how the driver handles line termination. When a user presses the key labeled ENTER or RE-TURN, the driver consults the parameter to decide whether to pass a linefeed (also called a NEWLINE) character to the application or to map the linefeed into a pair of characters, carriage return followed by linefeed.Cbreak mode provides a compromise between cooked and raw modes. In cbreak mode, each character is delivered to the application instantly, without waiting to accu-mulate a line of text. Thus, the driver does not buffer input, nor does the driver support backspace or line kill functions. However, the driver does handle both character echo and flow control.15.4 Organization Of A Tty Device DriverLike most device drivers, the example tty driver is partitioned into an upper half that contains functions called by application processes (indirectly through the device switch table), and a lower half that contains functions invoked when the device inter-rupts. The two halves share a data structure that contains information about the device, the current mode of the driver, and buffers for incoming and outgoing data. In general, upper-half functions move data to or from the shared structure and have minimal in-teraction with the device hardware. For example, an upper-half function places outgo-ing data in the shared structure where a lower-half function can access and send the data to the device. Similarly, the lower half places incoming data in the shared structure where an upper-half function can extract it.The motivation for driver partitioning can be difficult to appreciate at first. We will see, however, that dividing a driver into two halves is fundamental because the division allows a system designer to decouple normal processing from hardware inter-rupt processing and understand exactly how each function is invoked. The point is:When creating a device driver, a programmer must be careful to preserve the division between upper-half and lower-half functions be-cause upper-half functions are called by application processes and lower-half functions are invoked by interrupts.†Pronounced curl-if.290 An Example Device Driver Chap. 1515.5 Request Queues And BuffersIn most drivers, the shared data structure contains two key items:Request queueBuffered I/ORequest queue. In principle, the most important item found in the data structure shared by upper-half and lower-half functions is a queue into which the upper halfplaces requests. Conceptually, the request queue connects high-level operations that ap-plications specify and low-level actions that must be performed on the device. Each driver has its own set of requests, and the contents of elements on a request queue depend on the underlying device as well as the operations to be performed. For exam-ple, requests issued to a disk device specify the direction of transfer (read or write), a location on the disk, and a buffer for the data to be transferred. Requests issued to a network device might specify a set of packet buffers, and specify whether to transmit a packet from the buffer or receive an incoming packet. Our example driver has two queues: one contains a set of outgoing characters and the other holds incoming charac-ters. In essence, a character in an outgoing queue is a request to transmit, and space in the input queue serves as a request to receive.Buffered I/O. Most drivers buffer incoming and outgoing data. Output buffering allows an application to deposit an outgoing item in a buffer, and then continue process-ing. The item remains in the buffer until the hardware is ready to accept the item. In-put buffering allows a driver to accept data from a device before an application is ready to receive it. An incoming item remains in the buffer from the time the device deposits the item until a process requests it.Buffers are important for several reasons. First, a driver can accept incoming data before a user process consumes the data. Input buffering is especially important for asynchronous devices like a network interface that can receive packets at any time or a keyboard on which a user can press a key at any time. Second, buffering permits an ap-plication to read or write arbitrary amounts of data, even if the underlying hardware transfers entire blocks. By placing a block in a buffer, an operating system can satisfy subsequent requests from the buffer without an I/O transfer. Third, output buffering permits the driver to perform I/O concurrently with processing because a process can write data into a buffer, and then continue executing while the driver writes the data to the device.Our tty driver uses circular input and output buffers, with an extra circular buffer for echoed characters (echoed characters are kept in a buffer separate from normal out-put because echoed characters have higher priority). We think of each buffer as a con-ceptual queue, with characters being inserted at the tail and removed from the head. Figure 15.2 illustrates the concept of a circular output buffer, and shows the implemen-tation with an array of bytes in memory.Sec. 15.5        Request Queues And Buffers 291––QWERTYU–––––QWERTYU–––next item to send (head)next slot to fill (tail)next item to send (head)next slot to fill (tail(a) (b)Figure 15.2(a) A circular output buffer acting as a queue, and (b) the imple-mentation with an array of bytes.Output functions deposit characters to be sent in the output buffer and return to their caller. When it places characters in the output buffer, an upper-half function must also start output interrupts on the device. Whenever the device generates an output in-terrupt, the lower half extracts up to sixteen characters from the output buffer, and depo-sits the characters in the device’s output FIFO.† Once all characters in the output FIFO have been transmitted, the device will interrupt again. Thus, output continues until the output buffer becomes empty at which time the driver stops output and the device be-comes idle.Input works the other way around. Whenever it receives characters, the device in-terrupts and the interrupt dispatcher calls a lower-half function (i.e., ttyhandler). The interrupt handler extracts the characters from the device’s input FIFO and deposits them in the circular input buffer. When a process calls an upper-half function to read input, the upper-half function extracts characters from the input buffer.Conceptually, the two halves of a driver only communicate through shared buffers. Upper-half functions place outgoing data in a buffer and extract incoming data from a buffer. The lower half extracts outgoing data from the buffer and sends it to the device, and places incoming data in the buffer. To summarize:Upper-half functions transfer data between processes and buffers; the lower half transfers data between buffers and the device hardware.15.6 Synchronization Of Upper Half And Lower HalfIn practice, the two halves of the driver usually need to do more than manipulate a shared data structure. For example, an upper-half function may need to start an output transfer if a device is idle. More important, the two halves need to coordinate opera-tions on the request queue and the buffers. For example, if all slots in the output buffer are full when a process tries to write data, the process must be blocked. Later, when characters have been sent to the device and buffer space becomes available, the blocked †To improve efficiency, most UART hardware has a small on-board character buffer that can hold up to16 outgoing characters at a time.292 An Example Device Driver Chap. 15process must be allowed to proceed. Similarly, if the input buffer is empty when aprocess attempts to read from a device, the process must be blocked. Later, when input has been received and placed in the buffer, the process that is waiting for input must be allowed to proceed.At first glance, synchronization between the upper half and lower half of a driver appears to consist of two instances of producer–consumer coordination that can be solved easily with semaphores. On output, the upper-half functions produce data thatthe lower-half functions consume, and on input, the lower half produces input data that the upper-half functions consume. Input poses no problem for the producer–consumer paradigm; a semaphore can be created that handles coordination. When a process calls an upper-half input function, the process waits on the input semaphore until the lower half produces an input data item and signals the semaphore.Output poses an added twist. To understand the problem, recall our restriction on interrupt processing: because it can be executed by the null process, an interrupt func-tion cannot call a function that moves the executing process to any state other than ready or current. In particular, lower-half routines cannot call wait. Consequently, a driver cannot be designed in which a semaphore allows upper-half functions to produce data and lower-half functions to consume data.How can upper-half and lower-half functions coordinate to control output? Surprisingly, a semaphore solves the problem easily. The trick is to turn around the call to wait by changing the purpose of the output semaphore. Instead of having a lower-half routine wait for the upper half to produce data, we arrange for the upper half to wait for space in the buffer. Thus, we do not view the lower half as a consumer. In-stead, a lower-half output function acts as a producer to generate space (i.e., slots) in the buffer, and signals the output semaphore for each slot. To summarize:Semaphores can be used to coordinate the upper half and lower halfof a device driver. To avoid having lower-half functions block, outputis handled by arranging for upper-half functions to wait for buffer space.15.7 UART Hardware FIFOs And Driver DesignThe design of the hardware can complicate driver design. For example, consider the UART hardware in the example platforms. The UART device contains two onboard buffers, known as FIFOs. One FIFO handles incoming characters, and the other han-dles outgoing characters. Each FIFO holds up to sixteen characters. The device does not interrupt each time a character arrives. Instead, the hardware generates an interrupt when the first character arrives, but continues to add characters to the input FIFO if they arrive before the interrupt has been serviced. Thus, when it receives an input inter-rupt, the driver must repeatedly extract characters from the FIFO until the hardware FIFO is empty.Sec. 15.7        UART Hardware FIFOs And Driver Design 293How do multiple input characters affect the driver design? Consider the case where a process is blocked on an input semaphore, waiting for a character to arrive. In theory, once it extracts a character from the device and places the character in the input buffer, the driver should signal the semaphore to reschedule to indicate that a character is available. However, doing so may cause an immediate context switch, leaving addi-tional characters in the FIFO unprocessed. To avoid the problem, our driver uses resched_cntl to defer rescheduling temporarily.† After all characters have been extract-ed from the input FIFO and processed, the driver again calls resched_cntl to permit oth-er processes to run.15.8 The Concept Of A Control BlockWe use the term control block to refer to the shared data structure associated with a device. More specifically, the control block is associated with a driver for the device, and holds data that the driver uses as well as data needed by the hardware. For exam-ple, if a driver uses semaphores to coordinate the upper-half and lower-half functions, the semaphore IDs will be placed in the control block.Recall that if a system contains multiple copies of a given hardware device, the operating system uses one copy of the device driver code to service all devices. How-ever, each copy of the device must have a separate data structure. That is, the system must have a separate control block for each physical copy of the device. Like most sys-tems, Xinu uses an array to hold N copies of the data structure if the system contains N copies of a given hardware device. We will see that each copy of the device is assigned a unique index number 0, 1, 2, and so on. The value serves as an index into the array of control blocks. Thus, the copy of a device assigned value i uses the ith  entry in the control block array.When it runs, a device driver function receives an argument that identifies the con-trol block to use. Thus, if a particular system has three serial devices that use the tty abstraction, the operating system contains only one copy of the functions that read and write to a tty device, but contains three separate copies of a tty control block.15.9 Tty Control Block And Data DeclarationsA control block stores information about a specific device, the driver, and the re-quest queues. The control block either contains buffers or contains pointers to buffers in memory.‡ The tty control block also stores IDs of the two semaphores that coordi-nate input and output. The code in file tty.h contains the declaration of the tty control block structure, which is named ttycblk. The key components of the ttycblk structureconsist of the input buffer, tyibuff, an output buffer, tyobuff, and a separate echo buffer, tyebuff. Each buffer used in the tty driver is implemented as an array of characters.†The code for resched_cntl can be found in file resched.c on page 82.‡On some systems, I/O buffers must be placed in a special region of memory to permit devices to accessthe buffers directly.294 An Example Device Driver Chap. 15//**ttttyy..hh**//##ddeeffiinneeTTYY__OOBBMMIINNSSPP2200//**MMiinnssppaacceeiinnbbuuffffeerrbbeeffoorree**////**pprroocceesssseessaawwaakkeenneeddttoowwrriittee**//##ddeeffiinneeTTYY__EEBBUUFFLLEENN2200//**SSiizzeeooffeecchhooqquueeuuee**////**SSiizzeeccoonnssttaannttss**//##iiffnnddeeffNNttttyy##ddeeffiinneeNNttttyy11//**NNuummbbeerrooffsseerriiaallttttyylliinneess**//##eennddiiff##iiffnnddeeffTTYY__IIBBUUFFLLEENN##ddeeffiinneeTTYY__IIBBUUFFLLEENN112288//**NNuumm..cchhaarrssiinniinnppuuttqquueeuuee**//##eennddiiff##iiffnnddeeffTTYY__OOBBUUFFLLEENN##ddeeffiinneeTTYY__OOBBUUFFLLEENN6644//**NNuumm..cchhaarrssiinnoouuttppuuttqquueeuuee**//##eennddiiff//**MMooddeeccoonnssttaannttssffoorriinnppuuttaannddoouuttppuuttmmooddeess**//##ddeeffiinneeTTYY__IIMMRRAAWW’’RR’’//**RRaawwiinnppuuttmmooddee==>>nnooeeddiittss**//##ddeeffiinneeTTYY__IIMMCCOOOOKKEEDD’’CC’’//**CCooookkeeddmmooddee==>>lliinneeeeddiittiinngg**//##ddeeffiinneeTTYY__IIMMCCBBRREEAAKK’’KK’’//**HHoonnoorreecchhoo,,eettcc,,nnoolliinneeeeddiitt**//##ddeeffiinneeTTYY__OOMMRRAAWW’’RR’’//**RRaawwoouuttppuuttmmooddee==>>nnooeeddiittss**//ssttrruuccttttttyyccbbllkk{{//**TTttyylliinneeccoonnttrroollbblloocckk**//cchhaarr**ttyyiihheeaadd;;//**NNeexxttiinnppuuttcchhaarrttoorreeaadd**//cchhaarr**ttyyiittaaiill;;//**NNeexxttsslloottffoorraarrrriivviinnggcchhaarr**//cchhaarrttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]];;//**IInnppuuttbbuuffffeerr((hhoollddssoonneelliinnee))**//ssiidd3322ttyyiisseemm;;//**IInnppuuttsseemmaapphhoorree**//cchhaarr**ttyyoohheeaadd;;//**NNeexxttoouuttppuuttcchhaarrttooxxmmiitt**//cchhaarr**ttyyoottaaiill;;//**NNeexxttsslloottffoorroouuttggooiinnggcchhaarr**//cchhaarrttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]];;//**OOuuttppuuttbbuuffffeerr**//ssiidd3322ttyyoosseemm;;//**OOuuttppuuttsseemmaapphhoorree**//cchhaarr**ttyyeehheeaadd;;//**NNeexxtteecchhoocchhaarrttooxxmmiitt**//cchhaarr**ttyyeettaaiill;;//**NNeexxttsslloottttooddeeppoossiitteecchhoocchh**//cchhaarrttyyeebbuuffff[[TTYY__EEBBUUFFLLEENN]];;//**EEcchhoobbuuffffeerr**//cchhaarrttyyiimmooddee;;//**IInnppuuttmmooddeerraaww//ccbbrreeaakk//ccooookkeedd**//bbooooll88ttyyiieecchhoo;;//**IIssiinnppuutteecchhooeedd??**//bbooooll88ttyyiieebbaacckk;;//**DDooeerraassiinnggbbaacckkssppaacceeoonneecchhoo??**//bbooooll88ttyyeevviiss;;//**EEcchhooccoonnttrroollcchhaarrssaass^^XX??**//bbooooll88ttyyeeccrrllff;;//**EEcchhooCCRR--LLFFffoorrnneewwlliinnee??**//bbooooll88ttyyiiccrrllff;;//**MMaapp’’\\rr’’ttoo’’\\nn’’oonniinnppuutt??**//bbooooll88ttyyiieerraassee;;//**HHoonnoorreerraasseecchhaarraacctteerr??**//cchhaarrttyyiieerraasseecc;;//**PPrriimmaarryyeerraasseecchhaarraacctteerr**//Sec. 15.9        Tty Control Block And Data Declarations 295cchhaarrttyyiieerraasseecc22;;//**AAlltteerrnnaatteeeerraasseecchhaarraacctteerr**//bbooooll88ttyyeeooff;;//**HHoonnoorrEEOOFFcchhaarraacctteerr??**//cchhaarrttyyeeooffcchh;;//**EEOOFFcchhaarraacctteerr((uussuuaallllyy^^DD))**//bbooooll88ttyyiikkiillll;;//**HHoonnoorrlliinneekkiillllcchhaarraacctteerr??**//cchhaarrttyyiikkiillllcc;;//**LLiinneekkiillllcchhaarraacctteerr**//iinntt3322ttyyiiccuurrssoorr;;//**CCuurrrreennttccuurrssoorrppoossiittiioonn**//bbooooll88ttyyooffllooww;;//**HHoonnoorroossttoopp//oossttaarrtt??**//bbooooll88ttyyoohheelldd;;//**OOuuttppuuttccuurrrreennttllyybbeeiinngghheelldd??**//cchhaarrttyyoossttoopp;;//**CChhaarraacctteerrtthhaattssttooppssoouuttppuutt**//cchhaarrttyyoossttaarrtt;;//**CChhaarraacctteerrtthhaattssttaarrttssoouuttppuutt**//bbooooll88ttyyooccrrllff;;//**OOuuttppuuttCCRR//LLFFffoorrLLFF??**//cchhaarrttyyiiffuullllcc;;//**CChhaarrttoosseennddwwhheenniinnppuuttffuullll**//}};;eexxtteerrnnssttrruuccttttttyyccbbllkkttttyyttaabb[[]];;//**CChhaarraacctteerrsswwiitthhmmeeaanniinnggttootthheettttyyddrriivveerr**//##ddeeffiinneeTTYY__BBAACCKKSSPP’’\\bb’’//**BBaacckkssppaacceecchhaarraacctteerr**//##ddeeffiinneeTTYY__BBAACCKKSSPP22’’\\117777’’//**AAlltteerrnnaatteebbaacckkssppaacceecchhaarr..**//##ddeeffiinneeTTYY__BBEELLLL’’\\0077’’//**CChhaarraacctteerrffoorraauuddiibblleebbeeeepp**//##ddeeffiinneeTTYY__EEOOFFCCHH’’\\0044’’//**CCoonnttrrooll--DDiissEEOOFFoonniinnppuutt**//##ddeeffiinneeTTYY__BBLLAANNKK’’’’//**BBllaannkk**//##ddeeffiinneeTTYY__NNEEWWLLIINNEE’’\\nn’’//**NNeewwlliinnee====lliinneeffeeeedd**//##ddeeffiinneeTTYY__RREETTUURRNN’’\\rr’’//**CCaarrrriiaaggeerreettuurrnncchhaarraacctteerr**//##ddeeffiinneeTTYY__SSTTOOPPCCHH’’\\002233’’//**CCoonnttrrooll--SSssttooppssoouuttppuutt**//##ddeeffiinneeTTYY__SSTTRRTTCCHH’’\\002211’’//**CCoonnttrrooll--QQrreessttaarrttssoouuttppuutt**//##ddeeffiinneeTTYY__KKIILLLLCCHH’’\\002255’’//**CCoonnttrrooll--UUiisslliinneekkiillll**//##ddeeffiinneeTTYY__UUPPAARRRROOWW’’^^’’//**UUsseeddffoorrccoonnttrroollcchhaarrss((^^XX))**//##ddeeffiinneeTTYY__FFUULLLLCCHHTTYY__BBEELLLL//**CChhaarrttooeecchhoowwhheennbbuuffffeerrffuullll**////**TTttyyccoonnttrroollffuunnccttiioonnccooddeess**//##ddeeffiinneeTTCC__NNEEXXTTCC33//**LLooookkaahheeaadd11cchhaarraacctteerr**//##ddeeffiinneeTTCC__MMOODDEERR44//**SSeettiinnppuuttmmooddeettoorraaww**//##ddeeffiinneeTTCC__MMOODDEECC55//**SSeettiinnppuuttmmooddeettooccooookkeedd**//##ddeeffiinneeTTCC__MMOODDEEKK66//**SSeettiinnppuuttmmooddeettooccbbrreeaakk**//##ddeeffiinneeTTCC__IICCHHAARRSS88//**RReettuurrnnnnuummbbeerrooffiinnppuuttcchhaarrss**//##ddeeffiinneeTTCC__EECCHHOO99//**TTuurrnnoonneecchhoo**//##ddeeffiinneeTTCC__NNOOEECCHHOO1100//**TTuurrnnooffffeecchhoo**//The driver treats each buffer as a circular list, with location zero in an array treated as if it follows the last location. Head and tail pointers give the address of the next lo-cation in the array to fill and the next location in the array to empty, respectively. Thus, a programmer can remember an easy rule:296 An Example Device Driver Chap. 15A character is always inserted at the tail and taken from the head, in-dependent of whether a buffer is used for input or output.Initially, the head and tail each point to location zero, but there is never any confu-sion about whether an input or output buffer is completely empty or completely full be-cause each buffer has a semaphore that gives the count of characters in the buffer. Semaphore tyisem controls the input buffer, and a nonnegative count nmeans the buffer contains n characters. Semaphore tyosem controls the output buffer, and a nonnegative count n means the buffer contains n unfilled slots. The echo buffer is an exception. Our design assumes echo is used for a human typing, which means that only a few characters will ever occupy the echo queue. Therefore, we assume that no overflow will occur, which means that no semaphore is needed to control the queue.15.10 Minor Device NumbersWe said that the configuration program assigns each device in the system a unique device ID. If the system contains multiple physical copies of a device that all use a given abstraction, the IDs assigned to the devices may not be contiguous values. Thus,if a system has three tty devices, the configuration program may assign them device IDs 2, 7, and 8.We also said that the operating system must allocate one control block per device.For example, if a system contains three tty devices, the system must allocate threecopies of the tty control block. Xinu, like many systems, employs a technique that per-mits efficient access of a control block for a given device. The system assigns a minor device number to each copy of the device, and chooses minor device numbers to be contiguous integers starting at zero. Thus, if a system contains three tty devices, they will be assigned minor device numbers 0, 1, and 2. Unlike device IDs, the assignment of minor device numbers is guaranteed to be contiguous.How does a sequential assignment of minor device numbers make access efficient? We can now understand how device drivers are parameterized, and how they use minor device numbers. A minor device number serves as an index into the array of control blocks for the device. For example, consider how tty control blocks are allocated. As file tty.h illustrates, the control blocks are placed in array ttytab. The system config-uration program defines constant Ntty to be the number of tty devices, which is used to declare the size of array ttytab. The configuration program assigns each tty device a minor device number starting at 0 and ending at Ntty–1. The minor device number is placed in the device switch table entry. Both interrupt-driven routines in the lower half and driver routines in the upper half can access the minor device number. Each func-tion in the upper half has an argument that specifies one of the device table entries. Similarly, when an interrupt occurs, the operating system associates the interrupt with a specific device in the device table. Consequently, each driver function can extract the minor device number, and use the value as an index into array ttytab.Sec. 15.11        Upper–half Tty Character Input (ttygetc) 29715.11 Upper–half Tty Character Input (ttygetc)Four functions form the foundation for the upper half of the tty driver: ttygetc,ttyputc, ttyread, and ttywrite. The functions correspond to the high-level operationsgetc, putc, read, and write described in Chapter 14. The simplest driver routine isttygetc; the code can be found in file ttygetc.c.//**ttttyyggeettcc..cc--ttttyyggeettcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyggeettcc--RReeaaddoonneecchhaarraacctteerrffrroommaattttyyddeevviiccee((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllttttyyggeettcc((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{cchhaarrcchh;;//**CChhaarraacctteerrttoorreettuurrnn**//ssttrruuccttttttyyccbbllkk**ttyyppttrr;;//**PPooiinntteerrttoottttyyttaabbeennttrryy**//ttyyppttrr==&&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**WWaaiittffoorraacchhaarraacctteerriinntthheebbuuffffeerraannddeexxttrraaccttoonneecchhaarraacctteerr**//wwaaiitt((ttyyppttrr-->>ttyyiisseemm));;cchh==**ttyyppttrr-->>ttyyiihheeaadd++++;;//**WWrraappaarroouunnddttoobbeeggiinnnniinnggooffbbuuffffeerr,,iiffnneeeeddeedd**//iiff((ttyyppttrr-->>ttyyiihheeaadd>>==&&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyiihheeaadd==ttyyppttrr-->>ttyyiibbuuffff;;}} //**IInnccooookkeeddmmooddee,,cchheecckkffoorrtthheeEEOOFFcchhaarraacctteerr**//iiff((((ttyyppttrr-->>ttyyiimmooddee====TTYY__IIMMCCOOOOKKEEDD))&&&&((ttyyppttrr-->>ttyyeeooff))&&&&((cchh====ttyyppttrr-->>ttyyeeooffcchh)))){{rreettuurrnn((ddeevvccaallll))EEOOFF;;}} rreettuurrnn((ddeevvccaallll))cchh;;}}298 An Example Device Driver Chap. 15When called, ttygetc retrieves the minor device number from the device switch table, and then uses the number as an index into array ttytab to locate the correct control block. It then executes wait on the input semaphore, tyisem, blocking until the lower half has deposited a character in the buffer. When wait returns, ttygetc extracts the next character from the input buffer and updates the head pointer to make it ready for subse-quent extractions. Normally, ttygetc returns the character to its caller. However, one special case arises: if the driver is honoring end-of-file and the character matches the end-of-file character (field tyeofch in the control block), ttygetc returns constant EOF.15.12 Upper–half Tty Read Function (ttyread)The read operation can be used to obtain multiple characters in a single operation. The driver function that implements the read operation, ttyread, is shown below in file ttyread.c.  Ttyread is conceptually straightforward: it calls ttygetc repeatedly to obtain characters. When the driver is operating in cooked mode, ttyread returns a single line of input, stopping after a NEWLINE or RETURN character; when operating in other modes, ttyread reads characters without testing for an end-of-line.//**ttttyyrreeaadd..cc--ttttyyrreeaadd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyrreeaadd--RReeaaddcchhaarraacctteerr((ss))ffrroommaattttyyddeevviiccee((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllttttyyrreeaadd((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrooffcchhaarraacctteerrss**//iinntt3322ccoouunntt//**CCoouunnttooffcchhaarraacctteerrttoorreeaadd**//)){{ssttrruuccttttttyyccbbllkk**ttyyppttrr;;//**PPooiinntteerrttoottttyyccoonnttrroollbblloocckk**//iinntt3322aavvaaiill;;//**CChhaarraacctteerrssaavvaaiillaabblleeiinnbbuuffff..**//iinntt3322nnrreeaadd;;//**NNuummbbeerrooffcchhaarraacctteerrssrreeaadd**//iinntt3322ffiirrssttcchh;;//**FFiirrssttiinnppuuttcchhaarraacctteerroonnlliinnee**//cchhaarrcchh;;//**NNeexxttiinnppuuttcchhaarraacctteerr**//iiff((ccoouunntt<<00)){{rreettuurrnnSSYYSSEERRRR;;}} ttyyppttrr==&&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;Sec. 15.12        Upper–half Tty Read Function (ttyread) 299iiff((ttyyppttrr-->>ttyyiimmooddee!!==TTYY__IIMMCCOOOOKKEEDD)){{//**FFoorrccoouunnttooffzzeerroo,,rreettuurrnnaallllaavvaaiillaabblleecchhaarraacctteerrss**//iiff((ccoouunntt====00)){{aavvaaiill==sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm));;iiff((aavvaaiill====00)){{rreettuurrnn00;;}}eellssee{{ccoouunntt==aavvaaiill;;}}}} ffoorr((nnrreeaadd==00;;nnrreeaadd<<ccoouunntt;;nnrreeaadd++++)){{**bbuuffff++++==((cchhaarr))ttttyyggeettcc((ddeevvppttrr));;}} rreettuurrnnnnrreeaadd;;}} //**BBlloocckkuunnttiilliinnppuuttaarrrriivveess**//ffiirrssttcchh==ttttyyggeettcc((ddeevvppttrr));;//**CChheecckkffoorrEEnndd--OOff--FFiillee**//iiff((ffiirrssttcchh====EEOOFF)){{rreettuurrnnEEOOFF;;}} //**RReeaadduuppttooaalliinnee**//cchh==((cchhaarr))ffiirrssttcchh;;**bbuuffff++++==cchh;;nnrreeaadd==11;;wwhhiillee((((nnrreeaadd<<ccoouunntt))&&&&((cchh!!==TTYY__NNEEWWLLIINNEE))&&&&((cchh!!==TTYY__RREETTUURRNN)))){{cchh==ttttyyggeettcc((ddeevvppttrr));;**bbuuffff++++==cchh;;nnrreeaadd++++;;}} rreettuurrnnnnrreeaadd;;}}The semantics of how read operates on terminals illustrates how the I/O primitivescan be adapted to a variety of devices and modes. For example, an application that uses300 An Example Device Driver Chap. 15raw mode may need to read all the characters available from the input buffer without blocking. Ttyread cannot simply call ttygetc repeatedly because ttygetc will block once the buffer is empty. To accommodate non-blocking requests, our driver allows what might otherwise be considered an illegal operation: it interprets a request to read zero characters as a request to “read all characters that are waiting.”The code in ttyread shows how the zero length requests are handled in raw mode:the driver uses semcount to obtain the current count of the input semaphore, tyisem. Itthen knows exactly how many calls can be made to ttygetc without blocking.For cooked mode, the driver blocks until at least one character arrives. It handlesthe special case of an end-of-file character, and then calls ttygetc repeatedly to read therest of the line.15.13 Upper–half Tty Character Output (ttyputc)The upper-half output routines are almost as easy to understand as the upper-half input routines. Ttyputc waits for space in the output buffer, deposits the specific charac-ter in the output queue, tyobuff, and increments the tail pointer, tyotail. In addition, ttyputc starts output on the device. File ttyputc.c contains the code.//**ttttyyppuuttcc..cc--ttttyyppuuttcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyppuuttcc--WWrriitteeoonneecchhaarraacctteerrttooaattttyyddeevviiccee((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllttttyyppuuttcc((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarrcchh//**CChhaarraacctteerrttoowwrriittee**//)){{ssttrruuccttttttyyccbbllkk**ttyyppttrr;;//**PPooiinntteerrttoottttyyccoonnttrroollbblloocckk**//ttyyppttrr==&&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**HHaannddlleeoouuttppuuttCCRRLLFFbbyysseennddiinnggCCRRffiirrsstt**//iiff((cchh====TTYY__NNEEWWLLIINNEE&&&&ttyyppttrr-->>ttyyooccrrllff)){{ttttyyppuuttcc((ddeevvppttrr,,TTYY__RREETTUURRNN));;}} wwaaiitt((ttyyppttrr-->>ttyyoosseemm));;//**WWaaiittffoorrssppaacceeiinnqquueeuuee**//**ttyyppttrr-->>ttyyoottaaiill++++==cchh;;Sec. 15.13        Upper–half Tty Character Output (ttyputc) 301//**WWrraappaarroouunnddttoobbeeggiinnnniinnggooffbbuuffffeerr,,iiffnneeeeddeedd**//iiff((ttyyppttrr-->>ttyyoottaaiill>>==&&ttyyppttrr-->>ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyoottaaiill==ttyyppttrr-->>ttyyoobbuuffff;;}} //**SSttaarrttoouuttppuuttiinnccaasseeddeevviicceeiissiiddllee**//ttttyykkiicckkoouutt((((ssttrruuccttuuaarrtt__ccssrreegg**))ddeevvppttrr-->>ddvvccssrr));;rreettuurrnnOOKK;;}}In addition to the processing mentioned above, ttyputc honors one of the tty param-eters, tyocrlf. When tyocrlf is TRUE, each NEWLINE should map to the combination RETURN plus NEWLINE. To write the RETURN character, ttyputc calls itself recur-sively.15.14 Starting Output (ttykickout)Just before it returns, ttyputc calls ttykickout to start output. In fact, ttykickout does not perform any output to the device because all output is handled by the lower-half function when an output interrupt occurs. To understand how ttykickout works, it is necessary to know how an operating system interacts with the device hardware. It may seem that when a character becomes ready for output, ttyputc would take the following steps:Interact with the device to determine whether the device is busy; if (the device is not busy) {send the character to the device;} else {instruct the device to interrupt when output finishes;}Unfortunately, a device operates in parallel with the processor. Therefore, a race condition can occur — between the time the processor obtains the status and the time it instructs the device to interrupt, the device can finish output. If the device is already idle before the processor sends the command, the device will never interrupt.To avoid the race condition, device hardware is designed to allow an operating sys-tem to request an interrupt without testing the device. Making a request is trivial: the driver merely needs to set a bit in one of the device control registers. No race condition occurs because setting the bit causes an interrupt whether the device is currently sending302 An Example Device Driver Chap. 15characters or idle. If the device is busy, the hardware waits until output finishes and the on-board buffer is empty before generating an interrupt; if the device is currently idle when the bit is set, the device interrupts immediately.Setting the interrupt bit in the device only requires a single assignment statement;the code can be found in file ttykickout.c://**ttttyykkiicckkoouutt..cc--ttttyykkiicckkoouutt**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyykkiicckkoouutt--""KKiicckk""tthheehhaarrddwwaarreeffoorraattttyyddeevviiccee,,ccaauussiinnggiittttoo**ggeenneerraatteeaannoouuttppuuttiinntteerrrruupptt((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddttttyykkiicckkoouutt((ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr//**AAddddrreessssooffUUAARRTT’’ssCCSSRRss**//)){{//**FFoorrcceetthheeUUAARRTThhaarrddwwaarreeggeenneerraatteeaannoouuttppuuttiinntteerrrruupptt**//ccssrrppttrr-->>iieerr==UUAARRTT__IIEERR__EERRBBFFII||UUAARRTT__IIEERR__EETTBBEEII;;rreettuurrnn;;}}15.15 Upper–half Tty Multiple Character Output (ttywrite)The tty driver also supports multiple-byte output transfers (i.e., writes). Driver function ttywrite, found in file ttywrite.c, handles the output of one or more bytes. Ttywrite begins by checking the argument count, which specifies the number of bytes to write. A negative count is invalid, and a count of zero is allowed, but means no charac-ters are written.Once it has finished checking argument count, ttywrite enters a loop. On each iteration through the loop, ttywrite extracts the next character from the user’s buffer and calls ttyputc to place the character in the output buffer. As we have seen, ttyputc will proceed until the output buffer is full, at which time the call to ttyputc will block until space becomes available.Sec. 15.15        Upper–half Tty Multiple Character Output (ttywrite) 303//**ttttyywwrriittee..cc--ttttyywwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyywwrriittee--WWrriitteecchhaarraacctteerr((ss))ttooaattttyyddeevviiccee((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllttttyywwrriittee((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrooffcchhaarraacctteerrss**//iinntt3322ccoouunntt//**CCoouunnttooffcchhaarraacctteerrttoowwrriittee**//)){{//**HHaannddlleenneeggaattiivveeaannddzzeerrooccoouunnttss**//iiff((ccoouunntt<<00)){{rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((ccoouunntt====00)){{rreettuurrnnOOKK;;}} //**WWrriitteeccoouunnttcchhaarraacctteerrssoonneeaattaattiimmee**//ffoorr((;;ccoouunntt>>00;;ccoouunntt----)){{ttttyyppuuttcc((ddeevvppttrr,,**bbuuffff++++));;}} rreettuurrnnOOKK;;}}15.16 Lower–half Tty Driver Function (ttyhandler)The lower half of the tty driver is invoked when an interrupt occurs. The lower half consists of a handler, ttyhandler. Recall that a handler is invoked indirectly — an interrupt dispatcher function calls the handler whenever the device interrupts. The dispatch code is trivial, and identical to the dispatch code used with other devices, ex-cept for the handler that is invoked.  Therefore, we will only examine the handler code.It is important to understand that the UART hardware uses one interrupt vector for both input and output. That is, the handler will be invoked whenever the device has re-ceived one or more incoming characters, or when the device has sent all the characters in its output FIFO and is ready for more. The handler must check a control register in the device to determine whether an input or output interrupt has occurred. File ttyhandler.c contains the code.304 An Example Device Driver Chap. 15//**ttttyyhhaannddlleerr..cc--ttttyyhhaannddlleerr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyhhaannddlleerr--HHaannddlleeaanniinntteerrrruuppttffoorraattttyy((sseerriiaall))ddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddttttyyhhaannddlleerr((vvooiidd)){{ssttrruuccttddeennttrryy**ddeevvppttrr;;//**AAddddrreessssooffddeevviicceeccoonnttrroollbbllkk**//ssttrruuccttttttyyccbbllkk**ttyyppttrr;;//**PPooiinntteerrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr;;//**AAddddrreessssooffUUAARRTT’’ssCCSSRR**//bbyytteeiiiirr==00;;//**IInntteerrrruuppttiiddeennttiiffiiccaattiioonn**//bbyytteellssrr==00;;//**LLiinneessttaattuuss**////**GGeettCCSSRRaaddddrreessssoofftthheeddeevviiccee((aassssuummeeccoonnssoolleeffoorrnnooww))**//ddeevvppttrr==((ssttrruuccttddeennttrryy**))&&ddeevvttaabb[[CCOONNSSOOLLEE]];;ccssrrppttrr==((ssttrruuccttuuaarrtt__ccssrreegg**))ddeevvppttrr-->>ddvvccssrr;;//**OObbttaaiinnaappooiinntteerrttootthheettttyyccoonnttrroollbblloocckk**//ttyyppttrr==&&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**DDeeccooddeehhaarrddwwaarreeiinntteerrrruuppttrreeqquueessttffrroommUUAARRTTddeevviiccee**////**CChheecckkiinntteerrrruuppttiiddeennttiiffiiccaattiioonnrreeggiisstteerr**//iiiirr==ccssrrppttrr-->>iiiirr;;iiff((iiiirr&&UUAARRTT__IIIIRR__IIRRQQ)){{rreettuurrnn;;}} //**DDeeccooddeetthheeiinntteerrrruuppttccaauusseebbaasseedduuppoonntthheevvaalluueeeexxttrraacctteedd**////**ffrroommtthheeUUAARRTTiinntteerrrruuppttiiddeennttiiffiiccaattiioonnrreeggiisstteerr..CClleeaarr**////**tthheeiinntteerrrruuppttssoouurrcceeaannddppeerrffoorrmmtthheeaapppprroopprriiaatteehhaannddlliinngg**////**ttooccoooorrddiinnaatteewwiitthhtthheeuuppppeerrhhaallffoofftthheeddrriivveerr**////**DDeeccooddeetthheeiinntteerrrruuppttccaauussee**//iiiirr&&==UUAARRTT__IIIIRR__IIDDMMAASSKK;;//**MMaasskkoofffftthheeiinntteerrrruuppttIIDD**//sswwiittcchh((iiiirr)){{//**RReecceeiivveerrlliinneessttaattuussiinntteerrrruupptt((eerrrroorr))**//Sec. 15.16        Lower–half Tty Driver Function (ttyhandler) 305ccaasseeUUAARRTT__IIIIRR__RRLLSSII::rreettuurrnn;;//**RReecceeiivveerrddaattaaaavvaaiillaabblleeoorrttiimmeeddoouutt**//ccaasseeUUAARRTT__IIIIRR__RRDDAA::ccaasseeUUAARRTT__IIIIRR__RRTTOO::rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;//**WWhhiilleecchhaarrssaavvaaiill..iinnUUAARRTTbbuuffffeerr,,ccaallllttttyyiinntteerr__iinn**//wwhhiillee((((ccssrrppttrr-->>llssrr&&UUAARRTT__LLSSRR__DDRR))!!==00)){{ttttyyhhaannddllee__iinn((ttyyppttrr,,ccssrrppttrr));;}} rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;rreettuurrnn;;//**TTrraannssmmiitttteerroouuttppuuttFFIIFFOOiisseemmppttyy((ii..ee..,,rreeaaddyyffoorrmmoorree))**//ccaasseeUUAARRTT__IIIIRR__TTHHRREE::ttttyyhhaannddllee__oouutt((ttyyppttrr,,ccssrrppttrr));;rreettuurrnn;;//**MMooddeemmssttaattuusscchhaannggee((ssiimmppllyyiiggnnoorree))**//ccaasseeUUAARRTT__IIIIRR__MMSSCC::rreettuurrnn;;}}}}After obtaining the device’s CSR address from the device switch table, ttyhandler loads the UART’s CSR address into csrptr, and then uses csrptr to access the UART device. The key step consists of reading the interrupt identification register and using the value to determine the exact reason for the interrupt. The two reasons of interest are an input interrupt (data has arrived) or an output interrupt (i.e., the transmitter FIFO is empty and the driver can send additional characters).In the code, a switch statement chooses among a line status interrupt, an input in-terrupt, and an output interrupt. In our system, a line status interrupt should not occur,and is considered an error. Therefore, if a line status interrupt does occur, the handler merely returns (i.e., ignores the interrupt).306 An Example Device Driver Chap. 1515.17 Output Interrupt Processing (ttyhandle_out)Output interrupt processing is the easiest to understand. When an output interrupt occurs, the device has transmitted all characters from the onboard FIFO and is ready for more. Ttyhandler clears the interrupt and calls ttyhandle_out to restart output. The code for ttyhandle_out can be found in file ttyhandle_out.c//**ttttyyhhaannddllee__oouutt..cc--ttttyyhhaannddllee__oouutt**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyhhaannddllee__oouutt--HHaannddlleeaannoouuttppuuttoonnaattttyyddeevviicceebbyysseennddiinnggmmoorree**cchhaarraacctteerrssttootthheeddeevviicceeFFIIFFOO((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddttttyyhhaannddllee__oouutt((ssttrruuccttttttyyccbbllkk**ttyyppttrr,,//**PPttrrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr//**AAddddrreessssooffUUAARRTT’’ssCCSSRRss**//)){{iinntt3322oocchhaarrss;;//**NNuummbbeerrooffoouuttppuuttcchhaarrsssseenntt**////**ttootthheeUUAARRTT**//iinntt3322aavvaaiill;;//**AAvvaaiillaabblleecchhaarrssiinnoouuttppuuttbbuuff**//iinntt3322uussppaaccee;;//**SSppaacceelleeffttiinnoonnbbooaarrddUUAARRTT**////**oouuttppuuttFFIIFFOO**//bbyytteeiieerr==00;;//**IIffoouuttppuuttiissccuurrrreennttllyyhheelldd,,ssiimmppllyyiiggnnoorreetthheeccaallll**//iiff((ttyyppttrr-->>ttyyoohheelldd)){{rreettuurrnn;;}} //**IIffeecchhooaannddoouuttppuuttqquueeuueesseemmppttyy,,ttuurrnnooffffiinntteerrrruuppttss**//iiff((((ttyyppttrr-->>ttyyeehheeaadd====ttyyppttrr-->>ttyyeettaaiill))&&&&((sseemmccoouunntt((ttyyppttrr-->>ttyyoosseemm))>>==TTYY__OOBBUUFFLLEENN)))){{iieerr==ccssrrppttrr-->>iieerr;;ccssrrppttrr-->>iieerr==iieerr&&~~UUAARRTT__IIEERR__EETTBBEEII;;rreettuurrnn;;}} //**IInniittiiaalliizzeeuussppaacceettootthheessiizzeeoofftthheettrraannssmmiittFFIIFFOO**//Sec. 15.17        Output Interrupt Processing (ttyhandle_out) 307uussppaaccee==UUAARRTT__FFIIFFOO__SSIIZZEE;;//**WWhhiilleeoonnbbooaarrddFFIIFFOOiissnnoottffuullllaannddtthheeeecchhooqquueeuueeiiss**////**nnoonneemmppttyy,,xxmmiittcchhaarrssffrroommtthheeeecchhooqquueeuuee**//wwhhiillee((((uussppaaccee>>00))&&&&ttyyppttrr-->>ttyyeehheeaadd!!==ttyyppttrr-->>ttyyeettaaiill)){{ccssrrppttrr-->>bbuuffffeerr==**ttyyppttrr-->>ttyyeehheeaadd++++;;iiff((ttyyppttrr-->>ttyyeehheeaadd>>==&&ttyyppttrr-->>ttyyeebbuuffff[[TTYY__EEBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyeehheeaadd==ttyyppttrr-->>ttyyeebbuuffff;;}} uussppaaccee----;;}} //**WWhhiilleeoonnbbooaarrddFFIIFFOOiissnnoottffuullllaannddtthheeoouuttppuuttqquueeuueeiiss**////**nnoonneemmppttyy,,ttrraannssmmiittcchhaarrssffrroommtthheeoouuttppuuttqquueeuuee**//oocchhaarrss==00;;aavvaaiill==TTYY__OOBBUUFFLLEENN--sseemmccoouunntt((ttyyppttrr-->>ttyyoosseemm));;wwhhiillee((((uussppaaccee>>00))&&&&((aavvaaiill>>00)))){{ccssrrppttrr-->>bbuuffffeerr==**ttyyppttrr-->>ttyyoohheeaadd++++;;iiff((ttyyppttrr-->>ttyyoohheeaadd>>==&&ttyyppttrr-->>ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyoohheeaadd==ttyyppttrr-->>ttyyoobbuuffff;;}} aavvaaiill----;;uussppaaccee----;;oocchhaarrss++++;;}} iiff((oocchhaarrss>>00)){{ssiiggnnaallnn((ttyyppttrr-->>ttyyoosseemm,,oocchhaarrss));;}} rreettuurrnn;;}}Ttyhandle_out makes a series of tests before starting output. For example, output should not be started if a user has entered control-S. Similarly, there is no need to start output if both the echo and output queues are empty. To understand how ttyhandle_out starts output, recall that the underlying hardware has an onboard FIFO that can hold multiple outgoing characters. Once it has determined that output should proceed, ttyhandle_out can send up to UART_FIFO_SIZE (16) characters to the device. Charac-ters are sent until the FIFO is full or the buffers are empty, whichever occurs first. The echo queue has highest priority. Therefore, ttyhandle_out first sends characters from the echo queue. If slots remain in the FIFO, ttyhandle_out sends characters from the output queue.Each time it removes a character from the output queue, ttyhandle_out should sig-nal the output semaphore to indicate that another space is available in the buffer. Be-cause a call to signal can reschedule, however, ttyhandle_out does not call signal im-308 An Example Device Driver Chap. 15mediately. Instead, it increments variable ochars to count the number of slots being created. Once it has filled the FIFO (or has emptied the output queue), ttyhandle_out calls signaln to indicate that space is available in the buffer.15.18 Tty Input Processing (ttyhandle_in)Input interrupt processing is more complex than output processing because the on-board input FIFO can contain more than one character. Thus, to handle an input inter-rupt, ttyhandler† enters a loop: while the onboard FIFO is not empty, ttyhandler calls ttyhandle_in, which extracts and processes one character from the UART’s input FIFO. To prevent rescheduling until the loop completes and all characters have been extracted from the device, ttyhandler uses resched_cntl. Thus, although ttyhandle_in calls signal to make each character available, no rescheduling occurs until all available characters have been extracted from the device.Processing individual input characters is the most complex part of the tty device driver because it includes code for details such as character echo and line editing. Function ttyhandle_in handles the processing for raw, cbreak, and cooked modes. File ttyhandle_in.c contains the code.//**ttttyyhhaannddllee__iinn..cc--ttttyyhhaannddllee__iinn,,eerraassee11,,eeppuuttcc,,eecchhoocchh**//##iinncclluuddee<<xxiinnuu..hh>>llooccaallvvooiiddeerraassee11((ssttrruuccttttttyyccbbllkk**,,ssttrruuccttuuaarrtt__ccssrreegg**));;llooccaallvvooiiddeecchhoocchh((cchhaarr,,ssttrruuccttttttyyccbbllkk**,,ssttrruuccttuuaarrtt__ccssrreegg**));;llooccaallvvooiiddeeppuuttcc((cchhaarr,,ssttrruuccttttttyyccbbllkk**,,ssttrruuccttuuaarrtt__ccssrreegg**));;//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyhhaannddllee__iinn--HHaannddlleeoonneeaarrrriivviinnggcchhaarr((iinntteerrrruuppttssddiissaabblleedd))**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddttttyyhhaannddllee__iinn((ssttrruuccttttttyyccbbllkk**ttyyppttrr,,//**PPooiinntteerrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr//**AAddddrreessssooffUUAARRTT’’ssCCSSRR**//)){{cchhaarrcchh;;//**NNeexxttcchhaarrffrroommddeevviiccee**//iinntt3322aavvaaiill;;//**CChhaarrssaavvaaiillaabblleeiinnbbuuffffeerr**//cchh==ccssrrppttrr-->>bbuuffffeerr;;//**CCoommppuutteecchhaarrssaavvaaiillaabbllee**//†The code for ttyhandler can be found on page 304.Sec. 15.18        Tty Input Processing (ttyhandle_in) 309aavvaaiill==sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm));;iiff((aavvaaiill<<00)){{//**OOnneeoorrmmoorreepprroocceesssseesswwaaiittiinngg**//aavvaaiill==00;;}} //**HHaannddlleerraawwmmooddee**//iiff((ttyyppttrr-->>ttyyiimmooddee====TTYY__IIMMRRAAWW)){{iiff((aavvaaiill>>==TTYY__IIBBUUFFLLEENN)){{//**NNoossppaaccee==>>iiggnnoorreeiinnppuutt**//rreettuurrnn;;}} //**PPllaacceecchhaarriinnbbuuffffeerrwwiitthhnnooeeddiittiinngg**//**ttyyppttrr-->>ttyyiittaaiill++++==cchh;;//**WWrraappbbuuffffeerrppooiinntteerr**//iiff((ttyyppttrr-->>ttyyoottaaiill>>==&&ttyyppttrr-->>ttyyoobbuuffff[[TTYY__OOBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyoottaaiill==ttyyppttrr-->>ttyyoobbuuffff;;}} //**SSiiggnnaalliinnppuuttsseemmaapphhoorreeaannddrreettuurrnn**//ssiiggnnaall((ttyyppttrr-->>ttyyiisseemm));;rreettuurrnn;;}} //**HHaannddlleeccooookkeeddaannddccbbrreeaakkmmooddeess((ccoommmmoonnppaarrtt))**//iiff((((cchh====TTYY__RREETTUURRNN))&&&&ttyyppttrr-->>ttyyiiccrrllff)){{cchh==TTYY__NNEEWWLLIINNEE;;}} //**IIfffflloowwccoonnttrroolliissiinneeffffeecctt,,hhaannddllee^^SSaanndd^^QQ**//iiff((ttyyppttrr-->>ttyyooffllooww)){{iiff((cchh====ttyyppttrr-->>ttyyoossttaarrtt)){{//**^^QQssttaarrttssoouuttppuutt**//ttyyppttrr-->>ttyyoohheelldd==FFAALLSSEE;;ttttyykkiicckkoouutt((ccssrrppttrr));;rreettuurrnn;;}}eellsseeiiff((cchh====ttyyppttrr-->>ttyyoossttoopp)){{//**^^SSssttooppssoouuttppuutt**//ttyyppttrr-->>ttyyoohheelldd==TTRRUUEE;;rreettuurrnn;;}}}}310 An Example Device Driver Chap. 15ttyyppttrr-->>ttyyoohheelldd==FFAALLSSEE;;//**AAnnyyootthheerrcchhaarrssttaarrttssoouuttppuutt**//iiff((ttyyppttrr-->>ttyyiimmooddee====TTYY__IIMMCCBBRREEAAKK)){{//**JJuussttccbbrreeaakkmmooddee**////**IIffiinnppuuttbbuuffffeerriissffuullll,,sseennddbbeellllttoouusseerr**//iiff((aavvaaiill>>==TTYY__IIBBUUFFLLEENN)){{eeppuuttcc((ttyyppttrr-->>ttyyiiffuullllcc,,ttyyppttrr,,ccssrrppttrr));;}}eellssee{{//**IInnppuuttbbuuffffeerrhhaassssppaacceeffoorrtthhiisscchhaarr**//**ttyyppttrr-->>ttyyiittaaiill++++==cchh;;//**WWrraappaarroouunnddbbuuffffeerr**//iiff((ttyyppttrr-->>ttyyiittaaiill>>==&&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyiittaaiill==ttyyppttrr-->>ttyyiibbuuffff;;}} iiff((ttyyppttrr-->>ttyyiieecchhoo)){{//**AArreewweeeecchhooiinnggcchhaarrss??**//eecchhoocchh((cchh,,ttyyppttrr,,ccssrrppttrr));;}}}} rreettuurrnn;;}}eellssee{{//**JJuussttccooookkeeddmmooddee((sseeeeccoommmmoonnccooddeeaabboovvee))**////**LLiinneekkiillllcchhaarraacctteerraarrrriivveess--kkiilllleennttiirreelliinnee**//iiff((cchh====ttyyppttrr-->>ttyyiikkiillllcc&&&&ttyyppttrr-->>ttyyiikkiillll)){{ttyyppttrr-->>ttyyiittaaiill--==ttyyppttrr-->>ttyyiiccuurrssoorr;;iiff((ttyyppttrr-->>ttyyiittaaiill<<ttyyppttrr-->>ttyyiibbuuffff)){{ttyyppttrr-->>ttyyiihheeaadd++==TTYY__IIBBUUFFLLEENN;;}} ttyyppttrr-->>ttyyiiccuurrssoorr==00;;eeppuuttcc((TTYY__RREETTUURRNN,,ttyyppttrr,,ccssrrppttrr));;eeppuuttcc((TTYY__NNEEWWLLIINNEE,,ttyyppttrr,,ccssrrppttrr));;rreettuurrnn;;}} //**EErraassee((bbaacckkssppaaccee))cchhaarraacctteerr**//iiff((((((cchh====ttyyppttrr-->>ttyyiieerraasseecc))||||((cchh====ttyyppttrr-->>ttyyiieerraasseecc22))))&&&&ttyyppttrr-->>ttyyiieerraassee)){{iiff((ttyyppttrr-->>ttyyiiccuurrssoorr>>00)){{ttyyppttrr-->>ttyyiiccuurrssoorr----;;eerraassee11((ttyyppttrr,,ccssrrppttrr));;}} rreettuurrnn;;}}Sec. 15.18        Tty Input Processing (ttyhandle_in) 311//**EEnnddoofflliinnee**//iiff((((cchh====TTYY__NNEEWWLLIINNEE))||||((cchh====TTYY__RREETTUURRNN)))){{iiff((ttyyppttrr-->>ttyyiieecchhoo)){{eecchhoocchh((cchh,,ttyyppttrr,,ccssrrppttrr));;}} **ttyyppttrr-->>ttyyiittaaiill++++==cchh;;iiff((ttyyppttrr-->>ttyyiittaaiill>>==&&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyiittaaiill==ttyyppttrr-->>ttyyiibbuuffff;;}} //**MMaakkeeeennttiirreelliinnee((pplluuss\\nnoorr\\rr))aavvaaiillaabbllee**//ssiiggnnaallnn((ttyyppttrr-->>ttyyiisseemm,,ttyyppttrr-->>ttyyiiccuurrssoorr++11));;ttyyppttrr-->>ttyyiiccuurrssoorr==00;;//**RReesseettffoorrnneexxttlliinnee**//rreettuurrnn;;}} //**CChhaarraacctteerrttoobbeeppllaacceeddiinnbbuuffffeerr--sseennddbbeelllliiff**////**bbuuffffeerrhhaassoovveerrfflloowweedd**//aavvaaiill==sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm));;iiff((aavvaaiill<<00)){{aavvaaiill==00;;}} iiff((((aavvaaiill++ttyyppttrr-->>ttyyiiccuurrssoorr))>>==TTYY__IIBBUUFFLLEENN--11)){{eeppuuttcc((ttyyppttrr-->>ttyyiiffuullllcc,,ttyyppttrr,,ccssrrppttrr));;rreettuurrnn;;}} //**EEOOFFcchhaarraacctteerr::rreeccooggnniizzeeaattbbeeggiinnnniinnggoofflliinnee,,bbuutt**////**pprriinnttaannddiiggnnoorreeootthheerrwwiissee..**//iiff((cchh====ttyyppttrr-->>ttyyeeooffcchh&&&&ttyyppttrr-->>ttyyeeooff)){{iiff((ttyyppttrr-->>ttyyiieecchhoo)){{eecchhoocchh((cchh,,ttyyppttrr,,ccssrrppttrr));;}} iiff((ttyyppttrr-->>ttyyiiccuurrssoorr!!==00)){{rreettuurrnn;;}} **ttyyppttrr-->>ttyyiittaaiill++++==cchh;;ssiiggnnaall((ttyyppttrr-->>ttyyiisseemm));;rreettuurrnn;;}} //**EEcchhootthheecchhaarraacctteerr**//312 An Example Device Driver Chap. 15iiff((ttyyppttrr-->>ttyyiieecchhoo)){{eecchhoocchh((cchh,,ttyyppttrr,,ccssrrppttrr));;}} //**IInnsseerrttiinntthheeiinnppuuttbbuuffffeerr**//ttyyppttrr-->>ttyyiiccuurrssoorr++++;;**ttyyppttrr-->>ttyyiittaaiill++++==cchh;;//**WWrraappaarroouunnddiiffnneeeeddeedd**//iiff((ttyyppttrr-->>ttyyiittaaiill>>==&&ttyyppttrr-->>ttyyiibbuuffff[[TTYY__IIBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyiittaaiill==ttyyppttrr-->>ttyyiibbuuffff;;}} rreettuurrnn;;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eerraassee11--EErraasseeoonneecchhaarraacctteerrhhoonnoorriinnggeerraassiinnggbbaacckkssppaaccee**------------------------------------------------------------------------------------------------------------------------------------------------**//llooccaallvvooiiddeerraassee11((ssttrruuccttttttyyccbbllkk**ttyyppttrr,,//**PPttrrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr//**AAddddrreessssooffUUAARRTT’’ssCCSSRRss**//)){{cchhaarrcchh;;//**CChhaarraacctteerrttooeerraassee**//iiff((((----ttyyppttrr-->>ttyyiittaaiill))<<ttyyppttrr-->>ttyyiibbuuffff)){{ttyyppttrr-->>ttyyiittaaiill++==TTYY__IIBBUUFFLLEENN;;}} //**PPiicckkuuppcchhaarrttooeerraassee**//cchh==**ttyyppttrr-->>ttyyiittaaiill;;iiff((ttyyppttrr-->>ttyyiieecchhoo)){{//**AArreewweeeecchhooiinngg??**//iiff((cchh<<TTYY__BBLLAANNKK||||cchh====00117777)){{//**NNoonnpprriinnttaabbllee**//iiff((ttyyppttrr-->>ttyyeevviiss)){{//**VViissuuaallccnnttllcchhaarrss**//eeppuuttcc((TTYY__BBAACCKKSSPP,,ttyyppttrr,,ccssrrppttrr));;iiff((ttyyppttrr-->>ttyyiieebbaacckk)){{//**EErraasseecchhaarr**//eeppuuttcc((TTYY__BBLLAANNKK,,ttyyppttrr,,ccssrrppttrr));;eeppuuttcc((TTYY__BBAACCKKSSPP,,ttyyppttrr,,ccssrrppttrr));;}}}}Sec. 15.18        Tty Input Processing (ttyhandle_in) 313eeppuuttcc((TTYY__BBAACCKKSSPP,,ttyyppttrr,,ccssrrppttrr));;//**BByyppaassssuuppaarrrr**//iiff((ttyyppttrr-->>ttyyiieebbaacckk)){{eeppuuttcc((TTYY__BBLLAANNKK,,ttyyppttrr,,ccssrrppttrr));;eeppuuttcc((TTYY__BBAACCKKSSPP,,ttyyppttrr,,ccssrrppttrr));;}}}}eellssee{{//**AAnnoorrmmaallcchhaarraacctteerrtthhaattiisspprriinnttaabbllee**//eeppuuttcc((TTYY__BBAACCKKSSPP,,ttyyppttrr,,ccssrrppttrr));;iiff((ttyyppttrr-->>ttyyiieebbaacckk)){{//**eerraasseetthheecchhaarraacctteerr**//eeppuuttcc((TTYY__BBLLAANNKK,,ttyyppttrr,,ccssrrppttrr));;eeppuuttcc((TTYY__BBAACCKKSSPP,,ttyyppttrr,,ccssrrppttrr));;}}}}}} rreettuurrnn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eecchhoocchh--EEcchhooaacchhaarraacctteerrwwiitthhvviissuuaallaannddoouuttppuuttccrrllffooppttiioonnss**------------------------------------------------------------------------------------------------------------------------------------------------**//llooccaallvvooiiddeecchhoocchh((cchhaarrcchh,,//**CChhaarraacctteerrttooeecchhoo**//ssttrruuccttttttyyccbbllkk**ttyyppttrr,,//**PPttrrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr//**AAddddrreessssooffUUAARRTT’’ssCCSSRRss**//)){{iiff((((cchh====TTYY__NNEEWWLLIINNEE||||cchh====TTYY__RREETTUURRNN))&&&&ttyyppttrr-->>ttyyeeccrrllff)){{eeppuuttcc((TTYY__RREETTUURRNN,,ttyyppttrr,,ccssrrppttrr));;eeppuuttcc((TTYY__NNEEWWLLIINNEE,,ttyyppttrr,,ccssrrppttrr));;}}eellsseeiiff((((cchh<<TTYY__BBLLAANNKK||||cchh====00117777))&&&&ttyyppttrr-->>ttyyeevviiss)){{eeppuuttcc((TTYY__UUPPAARRRROOWW,,ttyyppttrr,,ccssrrppttrr));;//**pprriinntt^^xx**//eeppuuttcc((cchh++00110000,,ttyyppttrr,,ccssrrppttrr));;//**MMaakkeeiittpprriinnttaabbllee**//}}eellssee{{eeppuuttcc((cchh,,ttyyppttrr,,ccssrrppttrr));;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eeppuuttcc--PPuuttoonneecchhaarraacctteerriinntthheeeecchhooqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//llooccaallvvooiiddeeppuuttcc((cchhaarrcchh,,//**CChhaarraacctteerrttooeecchhoo**//ssttrruuccttttttyyccbbllkk**ttyyppttrr,,//**PPttrrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**ccssrrppttrr//**AAddddrreessssooffUUAARRTT’’ssCCSSRRss**//))314 An Example Device Driver Chap. 15{{**ttyyppttrr-->>ttyyeettaaiill++++==cchh;;//**WWrraappaarroouunnddbbuuffffeerr,,iiffnneeeeddeedd**//iiff((ttyyppttrr-->>ttyyeettaaiill>>==&&ttyyppttrr-->>ttyyeebbuuffff[[TTYY__EEBBUUFFLLEENN]])){{ttyyppttrr-->>ttyyeettaaiill==ttyyppttrr-->>ttyyeebbuuffff;;}} ttttyykkiicckkoouutt((ccssrrppttrr));;rreettuurrnn;;}}15.18.1  Raw Mode ProcessingRaw mode is the easiest to understand, and accounts for only a few lines of code.In raw mode, ttyhandle_in checks the input buffer to verify that space remains. To doso, it compares the count of the input semaphore (i.e., the number of characters that are currently in the buffer) to the buffer size. If no space remains in the buffer, ttyhandle_in merely returns to the handler (i.e., it discards the character). If space remains, ttyhandle_in deposits the character at the tail of the input buffer, moves to the next buffer position, signals the input semaphore, and returns.15.18.2  Cbreak Mode ProcessingCooked and cbreak mode share code that maps RETURN to NEWLINE and handles output flow control. Field tyoflow of the tty control block determines whether thedriver currently honors flow control. If it does, the driver suspends output by setting tyoheld to TRUE when it receives character tyostop, and restarts output when it receives character tyostart. Characters tyostart and tyostop are considered “control” characters, so the driver does not place them in the buffer.Cbreak mode checks the input buffer, and sends character tyifullc if the buffer isfull. Normally, tyifullc is a “bell” that causes the terminal to sound an audible alarm;the idea is that a human who is typing characters will hear the alarm and stop typinguntil characters have been read and more buffer space becomes available. If the bufferis not full, the code places the character in the buffer, and wraps around the pointer, if necessary. Finally, cbreak mode calls echoch to perform character echo.15.18.3  Cooked Mode ProcessingCooked mode operates like cbreak mode except that it also performs line editing. The driver accumulates lines in the input buffer, using variable tyicursor to keep a count of the characters on the “current” line. When the erase character, tyierasec, arrives, ttyhandle_in decrements tyicursor by one, backing up over the previous character, andSec. 15.18        Tty Input Processing (ttyhandle_in) 315calling function erase1 to erase the character from the display. When the line kill char-acter, tyikillc, arrives, ttyhandle_in eliminates the current line by setting tyicursor to zero and moving the tail pointer back to the beginning of the line. Finally, when a NEWLINE or RETURN character arrives, ttyhandle_in calls signaln to make the entire input line available. It resets tyicursor to zero for the next line. Note that the test for buffer full always leaves one extra space in the buffer for the end-of-line character (i.e., a NEWLINE).15.19 Tty Control Block Initialization (ttyinit)Function ttyinit, shown below in file ttyinit.c, is called once for each tty device. The parameter, devptr, is a pointer to the device switch table entry for a tty device. Ttyinit extracts the minor device number from the device switch table, uses the number as an index into the ttytab array, and sets typtr to the tty control block for the device. Ttyinit then initializes each field in the control block, setting the device to cooked mode, creating the input and output semaphores, and assigning head and tail pointers to indi-cate that buffers are empty. After driver parameters and buffers have been initialized, ttyinit sets variable csrptr to the CSR address of the UART hardware. It then sets the baud rate, sets the bits per character, turns off hardware parity checking, and sets the number of RS-232 stop bits to 1. Finally, ttyinit disables transmitter interrupts tem-porarily.Once the basic hardware initialization has been completed, ttyinit calls set_evec toset the interrupt vector to the interrupt function given in the device switch table. Afterthe interrupt vector has been set, ttyinit finishes the last steps of hardware initialization:it resets the hardware to permit both transmit and receive interrupts, and calls ttykickoutto start output.Ttyinit assumes a tty will be associated with a keyboard and display that a human will use. Consequently, ttyinit initializes a tty to cooked mode, and sets parameters as-suming a video device that can backspace over characters on the display and erase them. In particular, the parameter tyieback causes ttyhandle_in to echo three characters, backspace-space-backspace, when it receives the erase character, tyierasec. On a  display screen, sending the three-character sequence gives the effect of erasing charac-ters as the user backs over them. If you look again at ttyhandle_in,† you will see that it carefully backs up the correct number of spaces, even if the user erases a control char-acter that has been displayed as two printable characters.
†The code for ttyhandle_in can be found on page 308.316 An Example Device Driver Chap. 15//**ttttyyiinniitt..cc--ttttyyiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttttttyyccbbllkkttttyyttaabb[[NNttttyy]];;//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyiinniitt--IInniittiiaalliizzeebbuuffffeerrssaannddmmooddeessffoorraattttyylliinnee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllttttyyiinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttttttyyccbbllkk**ttyyppttrr;;//**PPooiinntteerrttoottttyyttaabbeennttrryy**//ssttrruuccttuuaarrtt__ccssrreegg**uuppttrr;;//**AAddddrreessssooffUUAARRTT’’ssCCSSRRss**//ttyyppttrr==&&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**IInniittiiaalliizzeevvaalluueessiinntthheettttyyccoonnttrroollbblloocckk**//ttyyppttrr-->>ttyyiihheeaadd==ttyyppttrr-->>ttyyiittaaiill==//**SSeettuuppiinnppuuttqquueeuuee**//&&ttyyppttrr-->>ttyyiibbuuffff[[00]];;//**aasseemmppttyy**//ttyyppttrr-->>ttyyiisseemm==sseemmccrreeaattee((00));;//**IInnppuuttsseemmaapphhoorree**//ttyyppttrr-->>ttyyoohheeaadd==ttyyppttrr-->>ttyyoottaaiill==//**SSeettuuppoouuttppuuttqquueeuuee**//&&ttyyppttrr-->>ttyyoobbuuffff[[00]];;//**aasseemmppttyy**//ttyyppttrr-->>ttyyoosseemm==sseemmccrreeaattee((TTYY__OOBBUUFFLLEENN));;//**OOuuttppuuttsseemmaapphhoorree**//ttyyppttrr-->>ttyyeehheeaadd==ttyyppttrr-->>ttyyeettaaiill==//**SSeettuuppeecchhooqquueeuuee**//&&ttyyppttrr-->>ttyyeebbuuffff[[00]];;//**aasseemmppttyy**//ttyyppttrr-->>ttyyiimmooddee==TTYY__IIMMCCOOOOKKEEDD;;//**SSttaarrttiinnccooookkeeddmmooddee**//ttyyppttrr-->>ttyyiieecchhoo==TTRRUUEE;;//**EEcchhooccoonnssoolleeiinnppuutt**//ttyyppttrr-->>ttyyiieebbaacckk==TTRRUUEE;;//**HHoonnoorreerraassiinnggbbkksspp**//ttyyppttrr-->>ttyyeevviiss==TTRRUUEE;;//**VViissuuaallccoonnttrroollcchhaarrss**//ttyyppttrr-->>ttyyeeccrrllff==TTRRUUEE;;//**EEcchhooCCRRLLFFffoorrNNEEWWLLIINNEE**//ttyyppttrr-->>ttyyiiccrrllff==TTRRUUEE;;//**MMaappCCRRttooNNEEWWLLIINNEE**//ttyyppttrr-->>ttyyiieerraassee==TTRRUUEE;;//**DDooeerraassiinnggbbaacckkssppaaccee**//ttyyppttrr-->>ttyyiieerraasseecc==TTYY__BBAACCKKSSPP;;//**PPrriimmaarryyeerraasseecchhaarr**//ttyyppttrr-->>ttyyiieerraasseecc22==TTYY__BBAACCKKSSPP22;;//**AAlltteerrnnaatteeeerraasseecchhaarr**//ttyyppttrr-->>ttyyeeooff==TTRRUUEE;;//**HHoonnoorreeooffoonniinnppuutt**//ttyyppttrr-->>ttyyeeooffcchh==TTYY__EEOOFFCCHH;;//**EEnndd--ooff--ffiilleecchhaarraacctteerr**//ttyyppttrr-->>ttyyiikkiillll==TTRRUUEE;;//**AAlllloowwlliinneekkiillll**//ttyyppttrr-->>ttyyiikkiillllcc==TTYY__KKIILLLLCCHH;;//**SSeettlliinneekkiillllttoo^^UU**//ttyyppttrr-->>ttyyiiccuurrssoorr==00;;//**SSttaarrttooffiinnppuuttlliinnee**//ttyyppttrr-->>ttyyooffllooww==TTRRUUEE;;//**HHaannddlleefflloowwccoonnttrrooll**//ttyyppttrr-->>ttyyoohheelldd==FFAALLSSEE;;//**OOuuttppuuttnnootthheelldd**//Sec. 15.19        Tty Control Block Initialization (ttyinit) 317ttyyppttrr-->>ttyyoossttoopp==TTYY__SSTTOOPPCCHH;;//**SSttooppcchhaarriiss^^SS**//ttyyppttrr-->>ttyyoossttaarrtt==TTYY__SSTTRRTTCCHH;;//**SSttaarrttcchhaarriiss^^QQ**//ttyyppttrr-->>ttyyooccrrllff==TTRRUUEE;;//**SSeennddCCRRLLFFffoorrNNEEWWLLIINNEE**//ttyyppttrr-->>ttyyiiffuullllcc==TTYY__FFUULLLLCCHH;;//**SSeenndd^^GGwwhheennbbuuffffeerr**////**iissffuullll**////**IInniittiiaalliizzeetthheeUUAARRTT**//uuppttrr==((ssttrruuccttuuaarrtt__ccssrreegg**))ddeevvppttrr-->>ddvvccssrr;;//**SSeettbbaauuddrraattee**//uuppttrr-->>llccrr==UUAARRTT__LLCCRR__DDLLAABB;;uuppttrr-->>ddllmm==00xx0000;;uuppttrr-->>ddllll==00xx1188;;uuppttrr-->>llccrr==UUAARRTT__LLCCRR__88NN11;;//**88bbiittcchhaarr,,NNooPPaarriittyy,,11SSttoopp**//uuppttrr-->>ffccrr==00xx0000;;//**DDiissaabblleeFFIIFFOOffoorrnnooww**////**RReeggiisstteerrtthheeiinntteerrrruuppttddiissppaattcchheerrffoorrtthheettttyyddeevviiccee**//sseett__eevveecc((ddeevvppttrr-->>ddvviirrqq,,((uuiinntt3322))ddeevvppttrr-->>ddvviinnttrr));;//**EEnnaabblleeiinntteerrrruuppttssoonntthheeddeevviiccee::rreesseetttthheettrraannssmmiittaanndd**////**rreecceeiivveeFFIIFFOOSS,,aannddsseetttthheeiinntteerrrruuppttttrriiggggeerrlleevveell**//uuppttrr-->>ffccrr==UUAARRTT__FFCCRR__EEFFIIFFOO||UUAARRTT__FFCCRR__RRRREESSEETT||UUAARRTT__FFCCRR__TTRREESSEETT||UUAARRTT__FFCCRR__TTRRIIGG22;;//**SSttaarrtttthheeddeevviiccee**//ttttyykkiicckkoouutt((uuppttrr));;rreettuurrnnOOKK;;}}15.20 Device Driver Control (ttycontrol)So far we have discussed driver functions that handle upper-half data transfer operations (e.g., read and write), functions that handle lower-half input and output inter-rupts, and an initialization function that sets parameters at system startup. The I/O in-terface defined in Chapter 14 provides another type of non-transfer function: control. Basically, control allows an application to control the device driver or the underlying device. In our example driver, function ttycontrol, found in file ttycontrol.c, provides basic control functions:318 An Example Device Driver Chap. 15//**ttttyyccoonnttrrooll..cc--ttttyyccoonnttrrooll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ttttyyccoonnttrrooll--CCoonnttrroollaattttyyddeevviicceebbyysseettttiinnggmmooddeess**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllttttyyccoonnttrrooll((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322ffuunncc,,//**FFuunnccttiioonnttooppeerrffoorrmm**//iinntt3322aarrgg11,,//**AArrgguummeenntt11ffoorrrreeqquueesstt**//iinntt3322aarrgg22//**AArrgguummeenntt22ffoorrrreeqquueesstt**//)){{ssttrruuccttttttyyccbbllkk**ttyyppttrr;;//**PPooiinntteerrttoottttyyccoonnttrroollbblloocckk**//cchhaarrcchh;;//**CChhaarraacctteerrffoorrllooookkaahheeaadd**//ttyyppttrr==&&ttttyyttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**PPrroocceesssstthheerreeqquueesstt**//sswwiittcchh((ffuunncc)){{ccaasseeTTCC__NNEEXXTTCC::wwaaiitt((ttyyppttrr-->>ttyyiisseemm));;cchh==**ttyyppttrr-->>ttyyiittaaiill;;ssiiggnnaall((ttyyppttrr-->>ttyyiisseemm));;rreettuurrnn((ddeevvccaallll))cchh;;ccaasseeTTCC__MMOODDEERR::ttyyppttrr-->>ttyyiimmooddee==TTYY__IIMMRRAAWW;;rreettuurrnn((ddeevvccaallll))OOKK;;ccaasseeTTCC__MMOODDEECC::ttyyppttrr-->>ttyyiimmooddee==TTYY__IIMMCCOOOOKKEEDD;;rreettuurrnn((ddeevvccaallll))OOKK;;ccaasseeTTCC__MMOODDEEKK::ttyyppttrr-->>ttyyiimmooddee==TTYY__IIMMCCBBRREEAAKK;;rreettuurrnn((ddeevvccaallll))OOKK;;ccaasseeTTCC__IICCHHAARRSS::rreettuurrnn((sseemmccoouunntt((ttyyppttrr-->>ttyyiisseemm))));;Sec. 15.20        Device Driver Control (ttycontrol) 319ccaasseeTTCC__EECCHHOO::ttyyppttrr-->>ttyyiieecchhoo==TTRRUUEE;;rreettuurrnn((ddeevvccaallll))OOKK;;ccaasseeTTCC__NNOOEECCHHOO::ttyyppttrr-->>ttyyiieecchhoo==FFAALLSSEE;;rreettuurrnn((ddeevvccaallll))OOKK;;ddeeffaauulltt::rreettuurrnn((ddeevvccaallll))SSYYSSEERRRR;;}}}}The control interface for a tty device provides seven control functions (i.e., possi-ble operations a process can perform on a tty device). Function TC_NEXTC allows an application to “lookahead” (i.e., obtain a copy of the next character waiting to be read without actually reading the character). Three of the control functions (TC_MODER, TC_MODEC, and TC_MODEK) allow a user to set the mode of a tty device to one of the three modes. Functions TC_ECHO and TC_NOECHO control character echo, al-lowing a caller to turn off echo, accept input, and then turn echo back on. Finally, function TC_ICHARS allows a user to query the driver to determine how many charac-ters are waiting in the input queue.Observant readers may have noticed that neither parameter arg1 nor arg2 is usedin function ttycontrol. They have been declared, however, because the device-independent I/O routine control always provides four arguments when calling a control function, such as ttycontrol. Although the compiler cannot perform type-checking on indirect function calls, omitting the argument declarations makes the code less portable and more difficult to understand.15.21 PerspectiveThe length of the code in the chapter reveals an important point about device drivers. To understand the point, compare the amount of code used for a trivial serial device to the code used for message passing and process synchronization primitives (i.e., semaphores). Although message passing and semaphores each provide a powerful abstraction, the code is relatively small.Why does a trivial device driver contain so much code? After all, the driver only makes it possible to read and write characters. The answer lies in the difference between the abstraction the hardware supplies and the abstraction the driver provides.The underlying hardware merely transfers characters, and the output side is independent of the input side. Thus, the hardware does not handle flow control or character echo. Furthermore, the hardware knows nothing about end-of-line translation (i.e., the crlf mapping). Consequently, a driver must contain code that handles many details.320 An Example Device Driver Chap. 15Although it may seem complex, the example driver in this chapter is trivial. A production device driver may comprise more than ten thousand lines of source code,and may contain hundreds of functions. Drivers for devices that can be plugged in at runtime (e.g., a USB device) are even more complex than drivers for static devices. Thus, one should appreciate that taken as a whole, code for device drivers is both huge and extremely complex.15.22 SummaryA device driver consists of a set of functions that control a peripheral hardware de-vice. The driver routines are partitioned into two halves: an upper half that contains the functions called from applications, and a lower half that contains functions that the sys-tem calls when a device interrupts. The two halves communicate through a shared data structure called a device control block.The example device driver examined in the chapter implements a tty abstraction. It manages input and output over serial line hardware, such as the connection to a key-board. Upper-half functions in the example driver implement read, write, getc, putc, and control operations. Each upper-half function is called indirectly through the device-switch table. Lower-half functions in the example driver handle interrupts. Dur-ing an output interrupt, the lower half fills the onboard FIFO from the echo or output queues. During an input interrupt, the lower half extracts and processes characters from the input FIFO.EXERCISES15.1 Predict what would happen if two processes executed ttyread concurrently when both re-quested a large number of characters. Experiment and see what happens.15.2 Find a flaw in ttyputc that prevents it from working correctly in raw mode, and repair theflaw. Hint: raw mode means all incoming characters are received without change.15.3 Kprintf uses polled I/O: it disables interrupts, waits until the device is idle, displays itsmessage, and then restores interrupts. What happens if the tty output buffer is full,kprintf is called repeatedly, and each call displays a single NEWLINE character? Ex-plain.15.4 The code in ttyhandle_out counts characters as they are removed from the buffer, andthen calls signaln to update the semaphore. Modify the code to use deferred reschedul-ing. Which version is easier to understand? Which is more efficient? Explain.15.5 Some systems partition asynchronous device drivers into three levels: interrupt level todo nothing but transfer characters to and from the device, upper level to transfer charac-ters to and from the user, and a middle level to implement a line discipline that handles details like character echo, flow control, special processing, and out of band signals. Convert the Xinu tty driver to a three-level scheme, and arrange for a process to execute code in the middle layer.Exercises32115.6 Suppose two processes both attempt to use write() on the CONSOLE device concurrent-ly. What will the output be? Why?15.7 Implement a control function that allows a process to obtain exclusive use of a tty device(e.g., the CONSOLE) and another control function that the process can use to release its exclusive use.15.8      Ttycontrol handles changes of mode poorly because it does not reset the cursor or bufferpointers. Rewrite the code to improve it.15.9 When connecting two computers, it is useful to have flow control in both directions.Modify the tty driver to include a “tandem” mode that sends Control-S when the input buffer is nearly full, and then sends Control-Q when the buffer is half empty.15.10 When a user changes the mode of a tty device, what should happen to characters alreadyin the input queue (which were accepted before the mode changed)? One possibility isthat the queue is discarded. Modify the code to implement discard during a modechange.Chapter Contents16.1 Introduction, 32516.2 Direct Memory Access And Buffers, 32516.3 Multiple Buffers And Rings, 32616.4 An Example Ethernet Driver Using DMA, 32716.5 Device Hardware Definitions And Constants, 32816.6 Rings And Buffers In Memory, 33116.7 Definitions Of An Ethernet Control Block, 33316.8 Device And Driver Initialization, 33616.9 Reading From An Ethernet Device, 34316.10 Writing To An Ethernet Device, 34716.11 Handling Interrupts From An Ethernet Device, 349 16.12 Ethernet Control Functions, 35216.13 Perspective, 353 16.14 Summary, 35416DMA Devices And Drivers (Ethernet)
Modern hardware is stunningly difficult to deal with.— James Buchanan16.1 IntroductionPrevious chapters on I/O present a general paradigm that uses a device switchtable, and explain how a device driver is organized. Chapter 15 shows an exampledriver for a tty device, and uses the example to illustrate how the upper half and lower half interact.This chapter extends our discussion of I/O by considering the design of device drivers for hardware devices that can transfer data from or to memory directly. The chapter presents an Ethernet device to show one example of how buffers are organized for such devices and how a device can access the buffers to perform both input and out-put.16.2 Direct Memory Access And BuffersAlthough a bus can only transfer a word of data at one time, a block-oriented de-vice, such as a disk or a network interface, needs to transfer multiple words of data tofill a given request. The motivation for Direct Memory Access (DMA) is parallelism: adding intelligence to an I/O device allows the device to perform multiple bus transfers without interrupting the processor. Thus, when they use DMA, a disk device can325326 DMA Devices And Drivers (Ethernet) Chap. 16transfer an entire disk block between memory and the device before interrupting the processor and a network interface can transfer an entire packet before interrupting the processor.DMA output is the easiest to understand. As an example, consider DMA output to a disk. To write a disk block, the operating system places the data in a buffer, creates a write request in memory, and passes a pointer to the request to the device. Once a re-quest has been passed to the device, the processor is free to continue executing other processes. While the processor executes, the disk DMA hardware uses the bus to access the write request, obtain the buffer address, and transfer successive words of data from the buffer to the disk. Once the device has read an entire block of data from memory and written the block to disk, the disk interrupts the processor. If an additional disk block is ready for output, another DMA operation can be started.DMA input works the other way around. To read a disk block, the operating sys-tem allocates a buffer to hold the incoming data, creates a read request in memory, and passes the address of the request to the disk device. After initiating the request, the pro-cessor is free, and the operating system executes a process that is ready. Simultaneous with processor execution, the DMA hardware uses the bus to access the request, and transfer the block from the disk to the buffer in memory. Once the entire block has been copied into the memory buffer, the disk interrupts the processor. Thus, with DMA, only one interrupt occurs per block transferred.16.3 Multiple Buffers And RingsDMA devices are more complex than described above. Instead of passing the de-vice the address of a single request, the hardware requires the operating system to allo-cate multiple request blocks (each with its own buffer), link them together on a linked list, and pass the address of the list. The device hardware is designed to follow the linked list and perform successive requests without waiting for the processor to restart each operation.† For example, consider a network interface that uses DMA hardware for input. To receive packets from the network, the operating system allocates a linked list of requests, each of which has a buffer that can hold a network packet. The operat-ing system passes the address of the list to the network interface device. When a packet arrives, the network device uses the request to find the address of the buffer, uses DMA to copy the packet into the buffer, generates an interrupt, and automatically moves to the next request without waiting for the processor. As long as requests remain on the list, the device continues to accept incoming packets and place each packet in the buffer associated with the request.What happens when a DMA device reaches the end of a buffer list? Interestingly, most DMA devices never reach the end of the linked list because the hardware uses a circular linked list, called a request ring (or informally, a buffer ring). That is, the last node on the list points back to the first. Each node in the list contains two values: a pointer to a buffer and a status bit that tells whether the buffer is ready for use. On in-put, the operating system initializes each node on the list to point to a buffer and sets †Some hardware places request blocks in an array and uses an index rather than a pointer, but the conceptis the same.Sec. 16.3        Multiple Buffers And Rings 327the status to indicate EMPTY. When it fills a buffer, the DMA hardware changes thestatus to FULL and generates an interrupt. The device driver function that handles in-terrupts extracts the data from all buffers that are full, and clears the status bits to indi-cate that each buffer is EMPTY. On the one hand, if the operating system is fast enough, it will be able to extract each incoming packet and mark the buffer EMPTY be-fore another packet arrives. Thus, on a fast processor, the DMA hardware will keep moving around the ring without ever encountering a buffer that is marked FULL. On  the other hand, if the operating system cannot process packets as fast as they arrive, the device will eventually fill all the buffers and will encounter a buffer marked FULL. If  it travels completely around the ring and encounters a full buffer, the DMA hardware sets an error indicator (typically an overflow bit) and generates an interrupt to inform the operating system.Most DMA hardware also uses a circular linked list for output. The operating sys-tem creates the ring with each buffer marked EMPTY. When it has a packet to send,the operating system places the packet in the next available output buffer, marks the buffer FULL, and starts the device if the device is not currently running. The device moves to the next buffer, uses DMA to obtain a copy of the packet from the buffer, and transmits the packet over the network. Once started, the DMA output hardware contin-ues to move around the ring until it reaches an empty buffer. Thus, if applications gen-erate data fast enough, the DMA hardware will transmit packets continuously without ever encountering an empty buffer.16.4 An Example Ethernet Driver Using DMAAn example will clarify the discussion above. Our example driver is written for the Ethernet device on the Quark SoC in the Galileo. Although many of the details are specific to the Ethernet on the Galileo board, the interaction between the processor and device is typical of most DMA devices. For example, the code for the Ethernet device in the BeagleBone Black is similar.The Quark Ethernet handles both input and output, and has a separate DMA engine for each. That is, a driver must create two rings — one ring has buffers used to receive packets, and the other has buffers used to send packets. The device has separate regis-ters that a driver uses to pass pointers to the input and output rings, and the hardware allows input and output to proceed simultaneously. Despite operating independently, both input and output interrupts use a single interrupt vector. Therefore, the driver acts like the tty driver in Chapter 15: when an interrupt occurs, the handler interacts with the device to determine whether the interrupt corresponds to an input or output operation, and proceeds accordingly.328 DMA Devices And Drivers (Ethernet) Chap. 1616.5 Device Hardware Definitions And ConstantsFile quark_eth.h defines constants and structures for the Ethernet hardware. Thefile contains many details and may seem confusing. For now, it is sufficient to knowthat the definitions are taken directly from the vendor’s manual for the device. For ex-ample, struct eth_q_csreg specifies the format of control and status registers as specified by the hardware vendor.We will see that the transmit and receive rings each consist of a circular linked list of descriptors, where a descriptor contains status information, a pointer to a buffer in memory, and a pointer to the next descriptor in the ring. For now, it is sufficient to know that structures eth_q_tx_desc and eth_q_rx_desc define the descriptors that the DMA expects to find in the transmit and receive rings, respectively.//**qquuaarrkk__eetthh..hh**////**DDeeffiinniittiioonnssffoorrIInntteellQQuuaarrkkEEtthheerrnneett**//##ddeeffiinneeIINNTTEELL__EETTHH__QQUUAARRKK__PPCCII__DDIIDD00xx00993377//**MMAACCPPCCIIDDeevviicceeIIDD**//##ddeeffiinneeIINNTTEELL__EETTHH__QQUUAARRKK__PPCCII__VVIIDD00xx88008866//**MMAACCPPCCIIVVeennddoorrIIDD**//ssttrruucctteetthh__qq__ccssrreegg{{uuiinntt3322mmaaccccrr;;//**MMAACCCCoonnffiigguurraattiioonnRReeggiisstteerr**//uuiinntt3322mmaaccffff;;//**MMAACCFFrraammeeFFiilltteerrRReeggiisstteerr**//uuiinntt3322hhtthhrr;;//**HHaasshhTTaabblleeHHiigghhRReeggiisstteerr**//uuiinntt3322hhttllrr;;//**HHaasshhTTaabblleeLLoowwRReeggiisstteerr**//uuiinntt3322ggmmiiiiaarr;;//**GGMMIIIIAAddddrreessssRReeggiisstteerr**//uuiinntt3322ggmmiiiiddrr;;//**GGMMIIIIDDaattaaRReeggiisstteerr**//uuiinntt3322ffccrr;;//**FFlloowwCCoonnttrroollRReeggiisstteerr**//uuiinntt3322vvllaannttaagg;;//**VVLLAAVVTTaaggRReeggiisstteerr**//uuiinntt3322vveerrssiioonn;;//**VVeerrssiioonnRReeggiisstteerr**//uuiinntt3322ddeebbuugg;;//**DDeebbuuggRReeggiisstteerr**//uuiinntt3322rreess11[[44]];;//**SSkkiippppeeddAAddddrreesssseess**//uuiinntt3322iirr;;//**IInntteerrrruuppttRReeggiisstteerr**//uuiinntt3322iimmrr;;//**IInntteerrrruuppttMMaasskkRReeggiisstteerr**//uuiinntt3322mmaaccaaddddrr00hh;;//**MMAACCAAddddrreessss00HHiigghhRReeggiisstteerr**//uuiinntt3322mmaaccaaddddrr00ll;;//**MMAACCAAddddrreessss00LLoowwRReeggiisstteerr**//uuiinntt3322rreess22[[4466]];;uuiinntt3322mmmmccccrr;;//**MMAACCMMaannaaggeemmeennttCCoouunntteerrCCnnttllRReeggiisstteerr**//uuiinntt3322mmmmccrrvvcciirr;;//**MMMMCCRReecceeiivveeIInntteerrrruuppttRReeggiisstteerr**//uuiinntt3322mmmmccttxxiirr;;//**MMMMCCTTrraannssmmiittIInntteerrrruuppttRReeggiisstteerr**//uuiinntt3322rreess33[[995577]];;//**SSkkiippppeeddAAddddrreesssseess**//uuiinntt3322bbmmrr;;//**BBuussMMooddeeRReeggiisstteerr**//uuiinntt3322ttppddrr;;//**TTrraannssmmiittPPoollllDDeemmaannddRReeggiisstteerr**//uuiinntt3322rrppddrr;;//**RReecceeiivveePPoollllDDeemmaannddRReeggiisstteerr**//Sec. 16.5        Device Hardware Definitions And Constants 329uuiinntt3322rrddllaa;;//**RReecceeiivveeDDeessccrriippttoorrLLiissttAAddddrr**//uuiinntt3322ttddllaa;;//**TTrraannssmmiittDDeessccrriippttoorrLLiissttAAddddrr**//uuiinntt3322ssrr;;//**SSttaattuussRReeggiisstteerr**//uuiinntt3322oommrr;;//**OOppeerraattiioonnMMooddeeRReeggiisstteerr**//uuiinntt3322iieerr;;//**IInntteerrrruuppttEEnnaabblleeRReeggiisstteerr**//}};;//**IInnddiivviidduuaallBBiittssiinnCCoonnttrroollaannddSSttaattuussRReeggiisstteerrss**////**MMAACCCCoonnffiigguurraattiioonnRReeggiisstteerr**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__PPEE22KK00xx0088000000000000//**EEnnaabbllee22KKPPaacckkeettss**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__WWDD00xx0000880000000000//**WWaattcchhddooggDDiissaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__JJDD00xx0000440000000000//**JJaabbbbeerrDDiissaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__JJEE00xx0000110000000000//**JJuummbbooFFrraammeeEEnnaabbllee**////**IInntteerr--ffrraammeeggaappvvaalluueess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG996600xx0000000000000000//**9966bbiittttiimmeess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG888800xx0000002200000000//**8888bbiittttiimmeess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG880000xx0000004400000000//**8800bbiittttiimmeess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG440000xx000000EE00000000//**4400bbiittttiimmeess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__IIFFGG664400xx0000008800000000//**6644bbiittttiimmeess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__DDCCRRSS00xx0000001100000000//**DDiiss..CC..SSeennsseedduurrTTXX**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__RRMMIIIISSPPDD110000xx0000000000000000//**RRMMIIIISSppeeeedd==1100MMbbppss**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__RRMMIIIISSPPDD11000000xx0000000044000000//**RRMMIIIISSppeeeedd==110000MMbbppss**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__DDOO00xx0000000022000000//**DDiissaabblleeRReecceeiivveeOOwwnn**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__LLMM00xx0000000011000000//**LLooooppbbaacckkMMooddeeEEnnaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__DDMM00xx0000000000880000//**DDuupplleexxMMooddeeEEnnaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__IIPPCC00xx0000000000440000//**CChheecckkssuummOOffffllooaadd**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__DDRR00xx0000000000220000//**DDiissaabblleeRReettrryy**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__AACCSS00xx0000000000008800//**AAuuttooPPaaddoorrCCRRCCSSttrriipp**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__DDCC00xx0000000000001100//**DDeeffeerrrraallCChheecckk**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__TTEE00xx0000000000000088//**TTrraannssmmiitttteerrEEnnaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__RREE00xx0000000000000044//**RReecceeiivveerrEEnnaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__PPRREELLEENN7700xx0000000000000000//**PPrreeaammbbllee==77bbyytteess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__PPRREELLEENN5500xx0000000000000011//**PPrreeaammbbllee==55bbyytteess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAACCCCRR__PPRREELLEENN3300xx0000000000000022//**PPrreeaammbbllee==33bbyytteess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMMMCC__CCNNTTFFRREEEEZZ00xx0000000000000088//**FFrreeeezzeeMMMMCCccoouunntteerrvvaalluueess**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMMMCC__CCNNTTRRSSTT00xx0000000000000011//**RReesseettaallllccnnttrrssttoozzeerroo**////**GGMMIIIIAAddddrreessssRReeggiisstteerr**//##ddeeffiinneeEETTHH__QQUUAARRKK__GGMMIIIIAARR__PPAAMMAASSKK00xx00000000FF880000//**PPhhyyssLLaayyeerrAAddddrrMMaasskk**//##ddeeffiinneeEETTHH__QQUUAARRKK__GGMMIIIIAARR__GGRRMMAASSKK00xx000000000077CC00//**GGMMIIIIRReeggiisstteerrMMaasskk**//330 DMA Devices And Drivers (Ethernet) Chap. 16##ddeeffiinneeEETTHH__QQUUAARRKK__GGMMIIIIAARR__CCRR00xx0000000000000044//**CCllkkRRaannggee==110000--115500**////**MMHHzzffoorrQQuuaarrkk**//##ddeeffiinneeEETTHH__QQUUAARRKK__GGMMIIIIAARR__GGWW00xx0000000000000022//**GGMMIIIIWWrriitteeEEnnaabbllee**//##ddeeffiinneeEETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB00xx0000000000000011//**GGMMIIIIBBuussyy**////**BBuussMMooddeeRReeggiisstteerr**//##ddeeffiinneeEETTHH__QQUUAARRKK__BBMMRR__SSWWRR00xx0000000000000011//**SSooffttwwaarreeRReesseett**////**SSttaattuussRReeggiisstteerr**//##ddeeffiinneeEETTHH__QQUUAARRKK__SSRR__MMMMCCII00xx0088000000000000//**MMAACCMMMMCCiinntteerrrruupptt**//##ddeeffiinneeEETTHH__QQUUAARRKK__SSRR__TTSS__SSUUSSPP00xx0000660000000000//**TTXXDDMMAAiissssuussppeennddeedd**//##ddeeffiinneeEETTHH__QQUUAARRKK__SSRR__NNIISS00xx0000001100000000//**NNoorrmmaallIInnttssuummmmaarryy**//##ddeeffiinneeEETTHH__QQUUAARRKK__SSRR__AAIISS00xx0000000088000000//**AAbbnnoorrmmIInnttrruuppttssuummmm..**//##ddeeffiinneeEETTHH__QQUUAARRKK__SSRR__RRII00xx0000000000004400//**RReecceeiivveeIInntteerrrruupptt**//##ddeeffiinneeEETTHH__QQUUAARRKK__SSRR__TTII00xx0000000000000011//**TTrraannssmmiittIInntteerrrruupptt**////**OOppeerraattiioonnMMooddeeRReeggiisstteerr**//##ddeeffiinneeEETTHH__QQUUAARRKK__OOMMRR__TTSSFF00xx0000220000000000//**TTxxssttoorreeaannddffoorrwwaarrdd**//##ddeeffiinneeEETTHH__QQUUAARRKK__OOMMRR__SSTT00xx0000000022000000//**SSttaarrtt//SSttooppTTXX**//##ddeeffiinneeEETTHH__QQUUAARRKK__OOMMRR__SSRR00xx0000000000000022//**SSttaarrtt//SSttooppRRXX**////**IInntteerrrruuppttEEnnaabblleeRReeggiisstteerr**//##ddeeffiinneeEETTHH__QQUUAARRKK__IIEERR__NNIIEE00xx0000001100000000//**EEnnaabblleeNNoorrmmIInnttSSuummmm..**//##ddeeffiinneeEETTHH__QQUUAARRKK__IIEERR__AAIIEE00xx0000000088000000//**EEnnaabblleeAAbbnnnnoomm""""**//##ddeeffiinneeEETTHH__QQUUAARRKK__IIEERR__RRIIEE00xx0000000000004400//**EEnnaabblleeRRXXIInntteerrrruupptt**//##ddeeffiinneeEETTHH__QQUUAARRKK__IIEERR__TTIIEE00xx0000000000000011//**EEnnaabblleeTTXXIInntteerrrruupptt**////**QQuuaarrkkEEtthheerrnneettTTrraannssmmiittDDeessccrriippttoorr**//ssttrruucctteetthh__qq__ttxx__ddeesscc{{uuiinntt3322ccttrrllssttaatt;;//**CCoonnttrroollaannddssttaattuuss**//uuiinntt1166bbuuff11ssiizzee;;//**SSiizzeeooffbbuuffffeerr11**//uuiinntt1166bbuuff22ssiizzee;;//**SSiizzeeooffbbuuffffeerr22**//uuiinntt3322bbuuffffeerr11;;//**AAddddrreessssooffbbuuffffeerr11**//uuiinntt3322bbuuffffeerr22;;//**AAddddrreessssooffbbuuffffeerr22**//}};;##ddeeffiinneeEETTHH__QQUUAARRKK__TTDDCCSS__OOWWNN00xx8800000000000000//**DDeessccrriipp..oowwnneeddbbyyDDMMAA**//##ddeeffiinneeEETTHH__QQUUAARRKK__TTDDCCSS__IICC00xx4400000000000000//**IInnttoonnCCoommpplleettiioonn**//##ddeeffiinneeEETTHH__QQUUAARRKK__TTDDCCSS__LLSS00xx2200000000000000//**LLaassttSSeeggmmeenntt**//##ddeeffiinneeEETTHH__QQUUAARRKK__TTDDCCSS__FFSS00xx1100000000000000//**FFiirrssttSSeeggmmeenntt**//##ddeeffiinneeEETTHH__QQUUAARRKK__TTDDCCSS__TTEERR00xx0000220000000000//**TTrraannssmmiittEEnnddooffRRiinngg**//##ddeeffiinneeEETTHH__QQUUAARRKK__TTDDCCSS__EESS00xx0000000088000000//**EErrrroorrSSuummmmaarryy**////**QQuuaarrkkEEtthheerrnneettRReecceeiivveeDDeessccrriippttoorr**//Sec. 16.5        Device Hardware Definitions And Constants 331ssttrruucctteetthh__qq__rrxx__ddeesscc{{uuiinntt3322ssttaattuuss;;//**DDeessccssttaattuusswwoorrdd**//uuiinntt1166bbuuff11ssiizzee;;//**SSiizzeeooffbbuuffffeerr11**//uuiinntt1166bbuuff22ssiizzee;;//**SSiizzeeooffbbuuffffeerr22**//uuiinntt3322bbuuffffeerr11;;//**AAddddrreessssooffbbuuffffeerr11**//uuiinntt3322bbuuffffeerr22;;//**AAddddrreessssooffbbuuffffeerr22**//}};;##ddeeffiinneerrddccttll11bbuuff11ssiizzee//**BBuuffffeerr11ssiizzeeffiieellddhhaassccoonnttrroollbbiittssttoooo**//##ddeeffiinneerrddccttll22bbuuff22ssiizzee//**BBuuffffeerr22ssiizzeeffiieellddhhaassccoonnttrroollbbiittssttoooo**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN00xx8800000000000000//**DDeessccrriipp..oowwnneeddbbyyDDMMAA**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDSSTT__EESS00xx0000000088000000//**EErrrroorrSSuummmmaarryy**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDSSTT__FFSS00xx0000000000220000//**FFiirrssttSSeeggmmeenntt**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDSSTT__LLSS00xx0000000000110000//**LLaassttsseeggmmeenntt**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDSSTT__FFTTEETTHH00xx0000000000002200//**FFrraammeeTTyyppee==EEtthheerrnneett**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDCCTTLL11__DDIICC00xx88000000//**DDiiss..IInnttoonnCCoommpplleett..**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRDDCCTTLL11__RREERR00xx88000000//**RReeccvvEEnnddooffRRiinngg**//##ddeeffiinneeEETTHH__QQUUAARRKK__RRXX__RRIINNGG__SSIIZZEE3322##ddeeffiinneeEETTHH__QQUUAARRKK__TTXX__RRIINNGG__SSIIZZEE1166##ddeeffiinneeEETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY550000000000//**DDeellaayyiinnmmiiccrroosseeccss**//##ddeeffiinneeEETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS33//**MMaaxxrreettrriieessffoorriinniitt**//16.6 Rings And Buffers In MemoryFrom a device’s perspective, an input or output ring consists of a linked list of descriptors in memory. We said that each descriptor on a ring contains a status word that specifies whether the associated buffer is empty or full. The descriptor also con-tains a pointer to a buffer in memory and a pointer to the next descriptor on the list.Figure 16.1 illustrates the conceptual organization of transmit and receive rings, and shows that each descriptor contains a pointer to a buffer as well as a pointer to the next ring.332 DMA Devices And Drivers (Ethernet) Chap. 16
... .........Transmit ring Receive ring
Transmit buffers Receive buffersFigure 16.1Illustration of the transmit and receive rings used with the exam-ple DMA hardware device.As the figure illustrates, the descriptors are arranged in a circular linked list wherethe final node points back to the first node. When reading the code, it will be importantto remember that the Ethernet device views each ring as a linked list. Thus, the DMA hardware merely follows the pointer in one node to get to the next node on the list. The reason the distinction is important arises from the way our driver code allocates storage. The driver uses getmem to allocate enough memory for all descriptors in a ring, and then links them together. Because they are contiguous, driver code can use pointer in-crement to move along the set of nodes. Figure 16.2 shows the structure of a node and illustrates how nodes of a ring are stored in contiguous storage.Sec. 16.6        Rings And Buffers In Memory 333
Ptr. To Next NodeStatusPtr. To BufferEMPTYEMPTYEMPTYEMPTY
buffer 1buffer 2buffer 3buffer N
(a) (b)...
Figure 16.2(a) The three fields in a node on a receive or transmit ring, and(b) a ring stored in contiguous memory with the second node shaded.16.7 Definitions Of An Ethernet Control BlockFile ether.h defines constants and data structures used by the Ethernet driver, in-cluding the format of an Ethernet packet header, the layout of a packet buffer inmemory, and the contents of an Ethernet control block.334 DMA Devices And Drivers (Ethernet) Chap. 16//**eetthheerr..hh**////**EEtthheerrnneettppaacckkeettffoorrmmaatt::++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++||DDeesstt..MMAACC((66))||SSrrcc..MMAACC((66))||TTyyppee((22))||DDaattaa((4466--11550000))......||++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++--++**//##ddeeffiinneeEETTHH__AADDDDRR__LLEENN66//**LLeenn..ooffEEtthheerrnneett((MMAACC))aaddddrr..**//ttyyppeeddeeffuunnssiiggnneeddcchhaarrEEaaddddrr[[EETTHH__AADDDDRR__LLEENN]];;//**PPhhyyssiiccaallEEtthheerrnneettaaddddrreessss**////**EEtthheerrnneettppaacckkeetthheeaaddeerr**//ssttrruucctteetthheerrPPkktt{{bbyytteeddsstt[[EETTHH__AADDDDRR__LLEENN]];;//**DDeessttiinnaattiioonnMMaaccaaddddrreessss**//bbyytteessrrcc[[EETTHH__AADDDDRR__LLEENN]];;//**SSoouurrcceeMMaaccaaddddrreessss**//uuiinntt1166ttyyppee;;//**EEtthheerrttyyppeeffiieelldd**//bbyytteeddaattaa[[11]];;//**PPaacckkeettppaayyllooaadd**//}};;##ddeeffiinneeEETTHH__HHDDRR__LLEENN1144//**LLeennggtthhooffEEtthheerrnneettppaacckkeett**////**hheeaaddeerr**////**EEtthheerrnneettDDMMAAbbuuffffeerrssiizzeess**//##ddeeffiinneeEETTHH__MMTTUU11550000//**MMaaxxiimmuummttrraannssmmiissssiioonnuunniitt**//##ddeeffiinneeEETTHH__VVLLAANN__LLEENN44//**LLeennggtthhooffEEtthheerrnneettvvllaannttaagg**//##ddeeffiinneeEETTHH__CCRRCC__LLEENN44//**LLeennggtthhooffCCRRCCoonnEEtthheerrnneett**////**ffrraammee**//##ddeeffiinneeEETTHH__MMAAXX__PPKKTT__LLEENN((EETTHH__HHDDRR__LLEENN++EETTHH__VVLLAANN__LLEENN++EETTHH__MMTTUU))##ddeeffiinneeEETTHH__BBUUFF__SSIIZZEE22004488//**AAmmuullttiipplleeooff1166ggrreeaatteerr**////**tthhaanntthheemmaaxxppaacckkeett**////**ssiizzee((ffoorrccaacchheeaalliiggnnmmeenntt))**////**SSttaatteeoofftthheeEEtthheerrnneettiinntteerrffaaccee**//##ddeeffiinneeEETTHH__SSTTAATTEE__FFRREEEE00//**CCoonnttrroollbblloocckkiissuunnuusseedd**//##ddeeffiinneeEETTHH__SSTTAATTEE__DDOOWWNN11//**IInntteerrffaacceeiissiinnaaccttiivvee**//##ddeeffiinneeEETTHH__SSTTAATTEE__UUPP22//**IInntteerrffaacceeiissccuurrrreennttllyyaaccttiivvee**////**EEtthheerrnneettddeevviicceeccoonnttrroollffuunnccttiioonnss**//Sec. 16.7        Definitions Of An Ethernet Control Block 335##ddeeffiinneeEETTHH__CCTTRRLL__GGEETT__MMAACC11//**GGeetttthheeMMAACCffoorrtthhiissddeevviiccee**//##ddeeffiinneeEETTHH__CCTTRRLL__AADDDD__MMCCAASSTT22//**AAddddaammuullttiiccaassttaaddddrreessss**//##ddeeffiinneeEETTHH__CCTTRRLL__RREEMMOOVVEE__MMCCAASSTT33//**RReemmoovveeaammuullttiiccaassttaaddddrreessss**////**EEtthheerrnneettmmuullttiiccaasstt**//##ddeeffiinneeEETTHH__NNUUMM__MMCCAASSTT3322//**MMaaxxmmuullttiiccaassttaaddddrreesssseess**////**EEhhtteerrnneettNNIICCttyyppee**//##ddeeffiinneeEETTHH__TTYYPPEE__33CC990055CC11//**33CCOOMM990055CC**//##ddeeffiinneeEETTHH__TTYYPPEE__EE11000000EE22//**IInntteellEE11000000EE**//##ddeeffiinneeEETTHH__TTYYPPEE__QQUUAARRKK__EETTHH33//**EEtthheerrnneettoonnQQuuaarrkkbbooaarrdd**////**CCoonnttrroollbblloocckkffoorrEEtthheerrnneettddeevviiccee**//ssttrruucctteetthhccbbllkk{{bbyytteessttaattee;;//**EETTHH__SSTTAATTEE__......aassddeeffiinneeddaabboovvee**//ssttrruuccttddeennttrryy**pphhyy;;//**pphhyyssiiccaalleetthhddeevviicceeffoorrTTxxDDMMAA**//bbyytteettyyppee;;//**NNIICCttyyppee__......aassddeeffiinneeddaabboovvee**////**PPooiinntteerrssttooaassssoocciiaatteeddssttrruuccttuurreess**//ssttrruuccttddeennttrryy**ddeevv;;//**AAddddrreessssiinnddeevviicceesswwiittcchhttaabbllee**//vvooiidd**ccssrr;;//**CCoonnttrroollaannddssttaattuussrreeggssiitteerraaddddrreessss**//uuiinntt3322ppcciiddeevv;;//**PPCCIIddeevviicceennuummbbeerr**//uuiinntt3322iioobbaassee;;//**II//OObbaasseeffrroommccoonnffiigg**//uuiinntt3322ffllaasshhbbaassee;;//**FFllaasshhbbaasseeffrroommccoonnffiigg**//uuiinntt3322mmeemmbbaassee;;//**MMeemmoorryybbaasseeffoorrddeevviicceeffrroommccoonnffiigg**//vvooiidd**rrxxRRiinngg;;//**PPttrrttooaarrrraayyooffrreeccvvrriinnggddeessccrriippttoorrss**//vvooiidd**rrxxBBuuffss;;//**PPttrrttooRRxxppaacckkeettbbuuffffeerrssiinnmmeemmoorryy**//uuiinntt3322rrxxHHeeaadd;;//**IInnddeexxooffccuurrrreenntthheeaaddooffRRxxrriinngg**//uuiinntt3322rrxxTTaaiill;;//**IInnddeexxooffccuurrrreennttttaaiillooffRRxxrriinngg**//uuiinntt3322rrxxRRiinnggSSiizzee;;//**SSiizzeeooffRRxxrriinnggddeessccrriippttoorraarrrraayy**//uuiinntt3322rrxxIIrrqq;;//**CCoouunnttooffRRxxiinntteerrrruuppttrreeqquueessttss**//vvooiidd**ttxxRRiinngg;;//**PPttrrttooaarrrraayyooffxxmmiittrriinnggddeessccrriippttoorrss**//vvooiidd**ttxxBBuuffss;;//**PPttrrttooTTxxppaacckkeettbbuuffffeerrssiinnmmeemmoorryy**//uuiinntt3322ttxxHHeeaadd;;//**IInnddeexxooffccuurrrreenntthheeaaddooffTTxxrriinngg**//uuiinntt3322ttxxTTaaiill;;//**IInnddeexxooffccuurrrreennttttaaiillooffTTxxrriinngg**//uuiinntt3322ttxxRRiinnggSSiizzee;;//**SSiizzeeooffTTxxrriinnggddeessccrriippttoorraarrrraayy**//uuiinntt3322ttxxIIrrqq;;//**CCoouunnttooffTTxxiinntteerrrruuppttrreeqquueessttss**//uuiinntt88ddeevvAAddddrreessss[[EETTHH__AADDDDRR__LLEENN]];;//**MMAACCaaddddrreessss**//336 DMA Devices And Drivers (Ethernet) Chap. 16uuiinntt88aaddddrrLLeenn;;//**HHaarrddwwaarreeaaddddrreesssslleennggtthh**//uuiinntt1166mmttuu;;//**MMaaxxiimmuummttrraannssmmiissssiioonnuunniitt((ppaayyllooaadd))**//uuiinntt3322eerrrroorrss;;//**NNuummbbeerrooffEEtthheerrnneetteerrrroorrss**//ssiidd3322iisseemm;;//**SSeemmaapphhoorreeffoorrEEtthheerrnneettiinnppuutt**//ssiidd3322oosseemm;;//**SSeemmaapphhoorreeffoorrEEtthheerrnneettoouuttppuutt**//uuiinntt1166iissttaarrtt;;//**IInnddeexxooffnneexxttppaacckkeettiinntthheerriinngg**//iinntt1166iinnPPooooll;;//**BBuuffffeerrppoooollIIDDffoorriinnppuuttbbuuffffeerrss**//iinntt1166oouuttPPooooll;;//**BBuuffffeerrppoooollIIDDffoorroouuttppuuttbbuuffffeerrss**//iinntt1166pprroommss;;//**NNoonnzzeerroo==>>pprroommiissccuuoouussmmooddee**//iinntt1166eedd__mmccsseett;;//**NNoonnzzeerroo==>>mmuullttiiccaassttrreecceeppttiioonnsseett**//iinntt1166eedd__mmcccc;;//**CCoouunnttooffmmuullttiiccaassttaaddddrreesssseess**//EEaaddddrreedd__mmccaa[[EETTHH__NNUUMM__MMCCAASSTT]];;//**AArrrraayyooffmmuullttiiccaassttaaddddrrss**//}};;eexxtteerrnnssttrruucctteetthhccbbllkkeetthheerrttaabb[[]];;//**AArrrraayyooffccoonnttrroollbblloocckkss**//16.8 Device And Driver InitializationRecall that the operating calls function init on each device at startup. The device switch table is configured such that a call to init on the Ethernet device invokes func-tion ethinit, which initializes both the Ethernet device and the device driver data struc-tures. File ethinit.c contains the code.//**eetthhiinniitt..cc--eetthhiinniitt,,eetthh__pphhyy__rreeaadd,,eetthh__pphhyy__wwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruucctteetthhccbbllkkeetthheerrttaabb[[11]];;//**------------------------------------------------------------------------------------------------------------------------------------------------**eetthh__pphhyy__rreeaadd--RReeaaddaaPPHHYYrreeggiisstteerr**------------------------------------------------------------------------------------------------------------------------------------------------**//uuiinntt1166eetthh__pphhyy__rreeaadd((vvoollaattiilleessttrruucctteetthh__qq__ccssrreegg**ccssrrppttrr,,//**CCSSRRaaddddrreessss**//uuiinntt3322rreeggnnuumm//**RReeggiisstteerr**//)){{uuiinntt3322rreettrriieess;;//**NNoo..ooffrreettrriieessffoorrrreeaadd**//Sec. 16.8        Device And Driver Initialization 337//**WWaaiittffoorrtthheeMMIIIIttoobbeerreeaaddyy**//wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr&&EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;//**PPrreeppaarreetthheeGGMMIIIIaaddddrreessssrreeggiisstteerrffoorrrreeaaddttrraannssaaccttiioonn**//ccssrrppttrr-->>ggmmiiiiaarr==((11<<<<1111))||//**PPhhyyssiiccaallLLaayyeerrAAddddrreessss==11**//((rreeggnnuumm<<<<66))||//**PPHHYYRReeggiisstteerrNNuummbbeerr**//((EETTHH__QQUUAARRKK__GGMMIIIIAARR__CCRR))||//**GGMMIIIICClloocckkRRaannggee110000--115500MMHHzz**//((EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;//**SSttaarrtttthheettrraannssaaccttiioonn**////**WWaaiittffoorrtthheettrraannssaaccttiioonnttooccoommpplleettee**//rreettrriieess==00;;wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr&&EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB)){{DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;iiff((((++++rreettrriieess))>>EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))rreettuurrnn00;;}} //**TTrraannssaaccttiioonniissccoommpplleettee,,rreeaaddtthheePPHHYYrreeggiisstteerrvvaalluueeffrroomm**////**tthheeGGMMIIIIddaattaarreeggiisstteerr**//rreettuurrnn((uuiinntt1166))ccssrrppttrr-->>ggmmiiiiddrr;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eetthh__pphhyy__wwrriittee--WWrriitteeaaPPHHYYrreeggiisstteerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddeetthh__pphhyy__wwrriittee((vvoollaattiilleessttrruucctteetthh__qq__ccssrreegg**ccssrrppttrr,,//**CCSSRRaaddddrreessss**//uuiinntt3322rreeggnnuumm,,//**RReeggiisstteerr**//uuiinntt1166vvaalluuee//**VVaalluueettoowwrriittee**//)){{uuiinntt3322rreettrriieess;;//**NNoo..ooffrreettrriieessffoorrwwrriittee**////**WWaaiittffoorrtthheeMMIIIIttoobbeerreeaaddyy**//wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr&&EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;//**WWrriitteetthheevvaalluueettooGGMMIIIIddaattaarreeggiisstteerr**//ccssrrppttrr-->>ggmmiiiiddrr==((uuiinntt3322))vvaalluuee;;338 DMA Devices And Drivers (Ethernet) Chap. 16//**PPrreeppaarreetthheeGGMMIIIIaaddddrreessssrreeggiisstteerrffoorrwwrriitteettrraannssaaccttiioonn**//ccssrrppttrr-->>ggmmiiiiaarr==((11<<<<1111))||//**PPhhyyssiiccaallLLaayyeerrAAddddrreessss==11**//((rreeggnnuumm<<<<66))||//**PPHHYYRReeggiisstteerrNNuummbbeerr**//((EETTHH__QQUUAARRKK__GGMMIIIIAARR__CCRR))||//**GGMMIIIICClloocckkRRaannggee110000--115500MMHHzz**//((EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGWW))||//**WWrriitteettrraannssaaccttiioonn**//((EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB));;//**SSttaarrtttthheettrraannssaaccttiioonn**////**WWaaiittttiilllltthheettrraannssaaccttiioonniissccoommpplleettee**//rreettrriieess==00;;wwhhiillee((ccssrrppttrr-->>ggmmiiiiaarr&&EETTHH__QQUUAARRKK__GGMMIIIIAARR__GGBB)){{DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;iiff((((++++rreettrriieess))>>EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))rreettuurrnn;;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eetthh__pphhyy__rreesseett--RReesseettaannEEtthheerrnneettPPHHYY**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322eetthh__pphhyy__rreesseett((vvoollaattiilleessttrruucctteetthh__qq__ccssrreegg**ccssrrppttrr//**CCSSRRaaddddrreessss**//)){{uuiinntt1166vvaalluuee;;//**VVaarriiaabblleettoorreeaaddiinnPPHHYYrreeggiisstteerrss**//uuiinntt3322rreettrriieess;;//**NNoo..ooffrreettrriieessffoorrrreesseett**////**RReeaaddtthheePPHHYYccoonnttrroollrreeggiisstteerr((rreeggiisstteerr00))**//vvaalluuee==eetthh__pphhyy__rreeaadd((ccssrrppttrr,,00));;//**SSeettbbiitt1155iinnccoonnttrroollrreeggiisstteerrttoorreesseetttthheePPHHYY**//eetthh__pphhyy__wwrriittee((ccssrrppttrr,,00,,((vvaalluuee||00xx88000000))));;//**WWaaiittffoorrPPHHYYrreesseettpprroocceessssttooccoommpplleettee**//rreettrriieess==00;;wwhhiillee((eetthh__pphhyy__rreeaadd((ccssrrppttrr,,00))&&00xx88000000)){{DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;iiff((((++++rreettrriieess))>>EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))rreettuurrnnSSYYSSEERRRR;;}}Sec. 16.8        Device And Driver Initialization 339//**SSeeeeiifftthheePPHHYYhhaassaauuttoo--nneeggoottiiaattiioonnccaappaabbiilliittyy**//vvaalluuee==eetthh__pphhyy__rreeaadd((ccssrrppttrr,,11));;//**PPHHYYSSttaattuussrreeggiisstteerr**//iiff((vvaalluuee&&00xx00000088)){{//**AAuuttoo--nneeggoottiiaattiioonnccaappaabbllee**////**WWaaiittffoorrtthheeaauuttoo--nneeggoottiiaattiioonnpprroocceessssttooccoommpplleettee**//rreettrriieess==00;;wwhhiillee((((eetthh__pphhyy__rreeaadd((ccssrrppttrr,,11))&&00xx00002200))====00)){{DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;iiff((((++++rreettrriieess))>>EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))rreettuurrnnSSYYSSEERRRR;;}}}} //**WWaaiittffoorrtthheeLLiinnkkttoobbeeUUpp**//rreettrriieess==00;;wwhhiillee((((eetthh__pphhyy__rreeaadd((ccssrrppttrr,,11))&&00xx00000044))====00)){{DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;iiff((((++++rreettrriieess))>>EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))rreettuurrnnSSYYSSEERRRR;;}} DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;kkpprriinnttff((""EEtthheerrnneettLLiinnkkiissUUpp\\nn""));;rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eetthhiinniitt--IInniittiiaalliizzeetthheeIInntteellQQuuaarrkkEEtthheerrnneettddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322eetthhiinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruucctteetthhccbbllkk**eetthhppttrr;;//**PPttrrttooccoonnttrroollbblloocckk**//vvoollaattiilleessttrruucctteetthh__qq__ccssrreegg**ccssrrppttrr;;//**PPttrrttooCCSSRR**//ssttrruucctteetthh__qq__ttxx__ddeesscc**ttxx__ddeessccss;;//**AArrrraayyooffttxxddeessccss**//ssttrruucctteetthh__qq__rrxx__ddeesscc**rrxx__ddeessccss;;//**AArrrraayyooffrrxxddeessccss**//ssttrruuccttnneettppaacckkeett**ppkkttppttrr;;//**PPooiinntteerrttooaappaacckkeett**//vvooiidd**tteemmppttrr;;//**TTeemmpp..ppooiinntteerr**//340 DMA Devices And Drivers (Ethernet) Chap. 16uuiinntt3322rreettrriieess;;//**RReettrryyccoouunnttffoorrrreesseett**//iinntt3322rreettvvaall;;iinntt3322ii;;eetthhppttrr==&&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;eetthhppttrr-->>ccssrr==((ssttrruucctteetthh__qq__ccssrreegg**))ddeevvppttrr-->>ddvvccssrr;;ccssrrppttrr==((ssttrruucctteetthh__qq__ccssrreegg**))eetthhppttrr-->>ccssrr;;//**EEnnaabblleeCCSSRRMMeemmoorryySSppaaccee,,EEnnaabblleeBBuussMMaasstteerr**//ppccii__wwrriittee__ccoonnffiigg__wwoorrdd((eetthhppttrr-->>ppcciiddeevv,,00xx44,,00xx00000066));;//**RReesseetttthheePPHHYY**//rreettvvaall==eetthh__pphhyy__rreesseett((ccssrrppttrr));;iiff((rreettvvaall====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**RReesseetttthheeEEtthheerrnneettMMAACC**//ccssrrppttrr-->>bbmmrr||==EETTHH__QQUUAARRKK__BBMMRR__SSWWRR;;//**WWaaiittffoorrtthheeMMAACCRReesseettpprroocceessssttooccoommpplleettee**//rreettrriieess==00;;wwhhiillee((ccssrrppttrr-->>bbmmrr&&EETTHH__QQUUAARRKK__BBMMRR__SSWWRR)){{DDEELLAAYY((EETTHH__QQUUAARRKK__IINNIITT__DDEELLAAYY));;iiff((((++++rreettrriieess))>>EETTHH__QQUUAARRKK__MMAAXX__RREETTRRIIEESS))rreettuurrnnSSYYSSEERRRR;;}} //**TTrraannssmmiittSSttoorreeaannddFFoorrwwaarrdd**//ccssrrppttrr-->>oommrr||==EETTHH__QQUUAARRKK__OOMMRR__TTSSFF;;//**SSeetttthheeiinntteerrrruupptthhaannddlleerr**//sseett__eevveecc((ddeevvppttrr-->>ddvviirrqq,,((uuiinntt3322))ddeevvppttrr-->>ddvviinnttrr));;//**SSeetttthheeMMAACCSSppeeeedd==110000MMbbppss,,FFuullllDDuupplleexxmmooddee**//ccssrrppttrr-->>mmaaccccrr||==((EETTHH__QQUUAARRKK__MMAACCCCRR__RRMMIIIISSPPDD110000||EETTHH__QQUUAARRKK__MMAACCCCRR__DDMM));;//**RReesseetttthheeMMMMCCCCoouunntteerrss**//ccssrrppttrr-->>mmmmccccrr||==EETTHH__QQUUAARRKK__MMMMCC__CCNNTTFFRREEEEZZ||EETTHH__QQUUAARRKK__MMMMCC__CCNNTTRRSSTT;;//**RReettrriieevveetthheeMMAACCaaddddrreessssffrroommSSPPIIffllaasshh**//ggeett__qquuaarrkk__ppddaatt__eennttrryy__ddaattaa__bbyy__iidd((QQUUAARRKK__MMAACC11__IIDD,,((cchhaarr**))((eetthhppttrr-->>ddeevvAAddddrreessss)),,EETTHH__AADDDDRR__LLEENN));;Sec. 16.8        Device And Driver Initialization 341kkpprriinnttff((""MMAACCaaddddrreessssiiss%%0022xx::%%0022xx::%%0022xx::%%0022xx::%%0022xx::%%0022xx\\nn"",,00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[00]],,00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[11]],,00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[22]],,00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[33]],,00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[44]],,00xxffff&&eetthhppttrr-->>ddeevvAAddddrreessss[[55]]));;//**AAddddtthheeMMAACCaaddddrreessssrreeaaddffrroommSSPPIIffllaasshhiinnttootthhee**////**mmaaccaaddddrrrreeggiisstteerrssffoorraaddddrreessssffiilltteerriinngg**//ccssrrppttrr-->>mmaaccaaddddrr00ll==((uuiinntt3322))((**((((uuiinntt3322**))eetthhppttrr-->>ddeevvAAddddrreessss))));;ccssrrppttrr-->>mmaaccaaddddrr00hh==((((uuiinntt3322))((**((((uuiinntt1166**))((eetthhppttrr-->>ddeevvAAddddrreessss++44))))))||00xx8800000000000000));;eetthhppttrr-->>ttxxRRiinnggSSiizzee==EETTHH__QQUUAARRKK__TTXX__RRIINNGG__SSIIZZEE;;//**AAllllooccaatteemmeemmoorryyffoorrtthheettrraannssmmiittrriinngg**//tteemmppttrr==((vvooiidd**))ggeettmmeemm((ssiizzeeooff((ssttrruucctteetthh__qq__ttxx__ddeesscc))**((eetthhppttrr-->>ttxxRRiinnggSSiizzee++11))));;iiff((((iinntt))tteemmppttrr====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} mmeemmsseett((tteemmppttrr,,00,,ssiizzeeooff((ssttrruucctteetthh__qq__ttxx__ddeesscc))**((eetthhppttrr-->>ttxxRRiinnggSSiizzee++11))));;//**TThheettrraannssmmiittddeessccrriippttoorrssnneeeeddttoobbee44--bbyytteeaalliiggnneedd**//eetthhppttrr-->>ttxxRRiinngg==((vvooiidd**))((((((uuiinntt3322))tteemmppttrr++33))&&((~~33))));;//**AAllllooccaatteemmeemmoorryyffoorrttrraannssmmiittbbuuffffeerrss**//eetthhppttrr-->>ttxxBBuuffss==((vvooiidd**))ggeettmmeemm((ssiizzeeooff((ssttrruuccttnneettppaacckkeett))**((eetthhppttrr-->>ttxxRRiinnggSSiizzee++11))));;iiff((((iinntt))eetthhppttrr-->>ttxxBBuuffss====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} eetthhppttrr-->>ttxxBBuuffss==((vvooiidd**))((((((uuiinntt3322))eetthhppttrr-->>ttxxBBuuffss++33))&&((~~33))));;//**PPooiinntteerrssttooiinniittiiaalliizzeettrraannssmmiittddeessccrriippttoorrss**//ttxx__ddeessccss==((ssttrruucctteetthh__qq__ttxx__ddeesscc**))eetthhppttrr-->>ttxxRRiinngg;;ppkkttppttrr==((ssttrruuccttnneettppaacckkeett**))eetthhppttrr-->>ttxxBBuuffss;;//**IInniittiiaalliizzeetthheettrraannssmmiittddeessccrriippttoorrss**//ffoorr((ii==00;;ii<<eetthhppttrr-->>ttxxRRiinnggSSiizzee;;ii++++)){{ttxx__ddeessccss[[ii]]..bbuuffffeerr11==((uuiinntt3322))((ppkkttppttrr++ii));;}}342 DMA Devices And Drivers (Ethernet) Chap. 16//**CCrreeaatteetthheeoouuttppuuttssyynncchhrroonniizzaattiioonnsseemmaapphhoorree**//eetthhppttrr-->>oosseemm==sseemmccrreeaattee((eetthhppttrr-->>ttxxRRiinnggSSiizzee));;iiff((((iinntt))eetthhppttrr-->>oosseemm====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} eetthhppttrr-->>rrxxRRiinnggSSiizzee==EETTHH__QQUUAARRKK__RRXX__RRIINNGG__SSIIZZEE;;//**AAllllooccaatteemmeemmoorryyffoorrtthheerreecceeiivveeddeessccrriippttoorrss**//tteemmppttrr==((vvooiidd**))ggeettmmeemm((ssiizzeeooff((ssttrruucctteetthh__qq__rrxx__ddeesscc))**((eetthhppttrr-->>rrxxRRiinnggSSiizzee++11))));;iiff((((iinntt))tteemmppttrr====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} mmeemmsseett((tteemmppttrr,,00,,ssiizzeeooff((ssttrruucctteetthh__qq__rrxx__ddeesscc))**((eetthhppttrr-->>rrxxRRiinnggSSiizzee++11))));;//**RReecceeiivveeddeessccrriippttoorrssmmuussttbbee44--bbyytteeaalliiggnneedd**//eetthhppttrr-->>rrxxRRiinngg==((ssttrruucctteetthh__qq__rrxx__ddeesscc**))((((((uuiinntt3322))tteemmppttrr++33))&&((~~33))));;//**AAllllooccaatteemmeemmoorryyffoorrtthheerreecceeiivveebbuuffffeerrss**//eetthhppttrr-->>rrxxBBuuffss==((vvooiidd**))ggeettmmeemm((ssiizzeeooff((ssttrruuccttnneettppaacckkeett))**((eetthhppttrr-->>rrxxRRiinnggSSiizzee++11))));;iiff((((iinntt))eetthhppttrr-->>rrxxBBuuffss====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**RReecceeiivveebbuuffffeerrssmmuussttbbee44--bbyytteeaalliiggnneedd**//eetthhppttrr-->>rrxxBBuuffss==((vvooiidd**))((((((uuiinntt3322))eetthhppttrr-->>rrxxBBuuffss++33))&&((~~33))));;//**PPooiinntteerrttooiinniittiiaalliizzeerreecceeiivveeddeessccrriippttoorrss**//rrxx__ddeessccss==((ssttrruucctteetthh__qq__rrxx__ddeesscc**))eetthhppttrr-->>rrxxRRiinngg;;//**PPooiinntteerrttooddaattaabbuuffffeerrss**//ppkkttppttrr==((ssttrruuccttnneettppaacckkeett**))eetthhppttrr-->>rrxxBBuuffss;;//**IInniittiiaalliizzeetthheerreecceeiivveeddeessccrriippttoorrss**//ffoorr((ii==00;;ii<<eetthhppttrr-->>rrxxRRiinnggSSiizzee;;ii++++)){{rrxx__ddeessccss[[ii]]..ssttaattuuss==EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN;;rrxx__ddeessccss[[ii]]..bbuuff11ssiizzee==((uuiinntt3322))ssiizzeeooff((ssttrruuccttnneettppaacckkeett));;rrxx__ddeessccss[[ii]]..bbuuffffeerr11==((uuiinntt3322))((ppkkttppttrr++ii));;}}Sec. 16.8        Device And Driver Initialization 343//**IInnddiiccaatteeeennddooffrriinnggoonnllaassttddeessccrriippttoorr**//rrxx__ddeessccss[[eetthhppttrr-->>rrxxRRiinnggSSiizzee--11]]..bbuuff11ssiizzee||==((EETTHH__QQUUAARRKK__RRDDCCTTLL11__RREERR));;//**CCrreeaatteetthheeiinnppuuttssyynncchhrroonniizzaattiioonnsseemmaapphhoorree**//eetthhppttrr-->>iisseemm==sseemmccrreeaattee((00));;iiff((((iinntt))eetthhppttrr-->>iisseemm====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**EEnnaabblleetthheeTTrraannssmmiittaannddRReecceeiivveeIInntteerrrruuppttss**//ccssrrppttrr-->>iieerr==((EETTHH__QQUUAARRKK__IIEERR__NNIIEE||EETTHH__QQUUAARRKK__IIEERR__TTIIEE||EETTHH__QQUUAARRKK__IIEERR__RRIIEE));;//**IInniittiiaalliizzeetthheettrraannssmmiittddeessccrriippttoorrbbaasseeaaddddrreessss**//ccssrrppttrr-->>ttddllaa==((uuiinntt3322))eetthhppttrr-->>ttxxRRiinngg;;//**IInniittiiaalliizzeetthheerreecceeiivveeddeessccrriippttoorrbbaasseeaaddddrreessss**//ccssrrppttrr-->>rrddllaa==((uuiinntt3322))eetthhppttrr-->>rrxxRRiinngg;;//**EEnnaabblleetthheeMMAACCRReecceeiivveerraannddTTrraannssmmiitttteerr**//ccssrrppttrr-->>mmaaccccrr||==((EETTHH__QQUUAARRKK__MMAACCCCRR__TTEE||EETTHH__QQUUAARRKK__MMAACCCCRR__RREE));;//**SSttaarrtttthheeTTrraannssmmiittaannddRReecceeiivveePPrroocceesssseessiinntthheeDDMMAA**//ccssrrppttrr-->>oommrr||==((EETTHH__QQUUAARRKK__OOMMRR__SSTT||EETTHH__QQUUAARRKK__OOMMRR__SSRR));;rreettuurrnnOOKK;;}}When it is called, ethinit initializes fields in the device control block, and then ini-tializes the hardware. Many of the details depend on the specific Ethernet hardware, but most hardware has equivalent functionality. Once the descriptor rings have been initial-ized, ethinit enables transmit and receiver interrupts in the hardware, making the device ready to transmit and receive packets.16.9 Reading From An Ethernet DeviceBecause the DMA engine uses the input ring to store incoming packets in succes-sive buffers, reading from an Ethernet device does not involve much interaction withthe device hardware. Instead, the driver uses a semaphore to coordinate reading: the semaphore begins with a count of zero, and is signalled each time a packet arrives.344 DMA Devices And Drivers (Ethernet) Chap. 16When it reads a packet, a process waits on the semaphore, then extracts a packet fromthe next ring buffer. If no packet is available when a process attempts to read a packet,the caller will be blocked. Once a packet becomes available and the interrupt handler signals the semaphore, the caller will proceed. The driver merely needs to copy the packet from the ring buffer to the caller’s buffer and return. File ethread.c contains the code://**eetthhrreeaadd..cc--eetthhrreeaadd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**eetthhrreeaadd--RReeaaddaanniinnccoommiinnggppaacckkeettoonnIInntteellQQuuaarrkkEEtthheerrnneett**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaalllleetthhrreeaadd((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuff,,//**BBuuffffeerrffoorrtthheeppaacckkeett**//iinntt3322lleenn//**SSiizzeeoofftthheebbuuffffeerr**//)){{ssttrruucctteetthhccbbllkk**eetthhppttrr;;//**EEtthheerrttaabbeennttrryyppooiinntteerr**//ssttrruucctteetthh__qq__rrxx__ddeesscc**rrddeessccppttrr;;//**PPooiinntteerrttootthheeddeessccrriippttoorr**//ssttrruuccttnneettppaacckkeett**ppkkttppttrr;;//**PPooiinntteerrttooppaacckkeett**//uuiinntt3322ffrraammeelleenn==00;;//**LLeennggtthhoofftthheeiinnccoommiinnggffrraammee**//bbooooll88vvaalliidd__aaddddrr;;iinntt3322ii;;eetthhppttrr==&&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;wwhhiillee((11)){{//**WWaaiittuunnttiilltthheerreeiissaappaacckkeettiinntthheerreecceeiivveeqquueeuuee**//wwaaiitt((eetthhppttrr-->>iisseemm));;//**PPooiinnttttootthheehheeaaddoofftthheeddeessccrriippttoorrlliisstt**//rrddeessccppttrr==((ssttrruucctteetthh__qq__rrxx__ddeesscc**))eetthhppttrr-->>rrxxRRiinngg++eetthhppttrr-->>rrxxHHeeaadd;;ppkkttppttrr==((ssttrruuccttnneettppaacckkeett**))rrddeessccppttrr-->>bbuuffffeerr11;;//**SSeeeeiiffddeessttiinnaattiioonnaaddddrreessssiissoouurruunniiccaassttaaddddrreessss**//iiff((!!mmeemmccmmpp((ppkkttppttrr-->>nneett__eetthhddsstt,,eetthhppttrr-->>ddeevvAAddddrreessss,,66)))){{Sec. 16.9        Reading From An Ethernet Device 345vvaalliidd__aaddddrr==TTRRUUEE;;//**SSeeeeiiffddeessttiinnaattiioonnaaddddrreessssiisstthheebbrrooaaddccaassttaaddddrreessss**//}}eellsseeiiff((!!mmeemmccmmpp((ppkkttppttrr-->>nneett__eetthhddsstt,,NNeettDDaattaa..eetthhbbccaasstt,,66)))){{vvaalliidd__aaddddrr==TTRRUUEE;;//**FFoorrmmuullttiiccaassttaaddddrreesssseess,,sseeeeiiffwweesshhoouullddaacccceepptt**//}}eellssee{{vvaalliidd__aaddddrr==FFAALLSSEE;;ffoorr((ii==00;;ii<<((eetthhppttrr-->>eedd__mmcccc));;ii++++)){{iiff((mmeemmccmmpp((ppkkttppttrr-->>nneett__eetthhddsstt,,eetthhppttrr-->>eedd__mmccaa[[ii]],,66))====00)){{vvaalliidd__aaddddrr==TTRRUUEE;;bbrreeaakk;;}}}}}} iiff((vvaalliidd__aaddddrr====TTRRUUEE)){{//**AAcccceepptttthhiissppaacckkeett**////**GGeetttthheelleennggtthhoofftthheeffrraammee**//ffrraammeelleenn==((rrddeessccppttrr-->>ssttaattuuss>>>>1166))&&00xx0000000033FFFFFF;;//**OOnnllyyrreettuurrnnlleenncchhaarraacctteerrssttooccaalllleerr**//iiff((ffrraammeelleenn>>lleenn)){{ffrraammeelleenn==lleenn;;}} //**CCooppyytthheeppaacckkeettiinnttootthheeccaalllleerr’’ssbbuuffffeerr**//mmeemmccppyy((bbuuff,,((vvooiidd**))rrddeessccppttrr-->>bbuuffffeerr11,,ffrraammeelleenn));;}} //**IInnccrreemmeenntttthheehheeaaddoofftthheeddeessccrriippttoorrlliisstt**//eetthhppttrr-->>rrxxHHeeaadd++==11;;iiff((eetthhppttrr-->>rrxxHHeeaadd>>==EETTHH__QQUUAARRKK__RRXX__RRIINNGG__SSIIZZEE)){{eetthhppttrr-->>rrxxHHeeaadd==00;;}}346 DMA Devices And Drivers (Ethernet) Chap. 16//**RReesseetttthheeddeessccrriippttoorrttoommaaxxppoossssiibblleeffrraammeelleenn**//rrddeessccppttrr-->>bbuuff11ssiizzee==ssiizzeeooff((ssttrruuccttnneettppaacckkeett));;//**IIffwweerreeaacchhtthheeeennddoofftthheerriinngg,,mmaarrkktthheeddeessccrriippttoorr**//iiff((eetthhppttrr-->>rrxxHHeeaadd====00)){{rrddeessccppttrr-->>rrddccttll11||==((EETTHH__QQUUAARRKK__RRDDCCTTLL11__RREERR));;}} //**IInnddiiccaatteetthhaatttthheeddeessccrriippttoorriissrreeaaddyyffoorrDDMMAAiinnppuutt**//rrddeessccppttrr-->>ssttaattuuss==EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN;;iiff((vvaalliidd__aaddddrr====TTRRUUEE)){{bbrreeaakk;;}}}} //**RReettuurrnntthheennuummbbeerrooffbbyytteessrreettuurrnneeddffrroommtthheeppaacckkeett**//rreettuurrnnffrraammeelleenn;;}}Ethread consists of a loop that reads packets until it finds a packet that should be processed (i.e., valid). A packet is accepted if the packet is addressed to the computer’s unicast address, the network broadcast address, or is one of the multicast addresses to which the computer is listening. Other packets are discarded.Multicast. Like many hardware devices, the Galileo Ethernet does not recognize a large set of multicast addresses. Instead, the hardware receives a set of multicast pack-ets, and relies on the software to decide whether a packet should be accepted. Our driver uses an array of multicast addresses, and checks each incoming multicast packetto see whether the address matches one of the addresses that an application has speci-fied. An exercise explores the use of hardware filters.To block until at least one packet is available, ethread waits on the input sema-phore on each iteration of the loop. Once it proceeds beyond the call to wait, the code locates the next available ring descriptor and obtains a pointer to the buffer associated with the ring. It then examines the destination address on the packet in the buffer. When a valid packet is found, the code copies the packet to the caller’s buffer, and re-turns the size of the packet to the caller. Whether a packet is accepted or skipped, ethread makes the descriptor available to the device (i.e., ready for the DMA engine to deposit another packet).Sec. 16.10        Writing To An Ethernet Device 34716.10 Writing To An Ethernet DeviceUsing DMA makes output as straightforward as input. An application calls write to send a packet, which invokes function ethwrite. As with input, the output side only interacts with the ring buffers: ethwrite copies the caller’s buffer to the next available output buffer. File ethwrite.c contains the code://**eetthhwwrriittee..cc--eetthhwwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**eetthhwwrriittee--eennqquueeuueeppaacckkeettffoorrttrraannssmmiissssiioonnoonnIInntteellQQuuaarrkkEEtthheerrnneett**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaalllleetthhwwrriittee((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuff,,//**BBuuffffeerrtthhaatthhoollssaappaacckkeett**//iinntt3322lleenn//**LLeennggtthhoofftthheeppaacckkeett**//)){{ssttrruucctteetthhccbbllkk**eetthhppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**//ssttrruucctteetthh__qq__ccssrreegg**ccssrrppttrr;;//**AAddddrreessssooffddeevviicceeCCSSRRss**//vvoollaattiilleessttrruucctteetthh__qq__ttxx__ddeesscc**ddeessccppttrr;;//**PPttrrttooddeessccrriippttoorr**//uuiinntt3322ii;;//**CCoouunnttssbbyytteessdduurriinnggccooppyy**//eetthhppttrr==&&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;ccssrrppttrr==((ssttrruucctteetthh__qq__ccssrreegg**))eetthhppttrr-->>ccssrr;;//**WWaaiittffoorraanneemmppttyysslloottiinntthheettrraannssmmiittddeessccrriippttoorrrriinngg**//wwaaiitt((eetthhppttrr-->>oosseemm));;//**PPooiinnttttootthheettaaiilloofftthheeddeessccrriippttoorrrriinngg**//ddeessccppttrr==((ssttrruucctteetthh__qq__ttxx__ddeesscc**))eetthhppttrr-->>ttxxRRiinngg++eetthhppttrr-->>ttxxTTaaiill;;//**IInnccrreemmeenntttthheettaaiilliinnddeexxaannddwwrraapp,,iiffnneeeeddeedd**//eetthhppttrr-->>ttxxTTaaiill++==11;;iiff((eetthhppttrr-->>ttxxTTaaiill>>==eetthhppttrr-->>ttxxRRiinnggSSiizzee)){{eetthhppttrr-->>ttxxTTaaiill==00;;}}348 DMA Devices And Drivers (Ethernet) Chap. 16//**AAddddppaacckkeettlleennggtthhttootthheeddeessccrriippttoorr**//ddeessccppttrr-->>bbuuff11ssiizzee==lleenn;;//**CCooppyyppaacckkeettiinnttootthheebbuuffffeerraassssoocciiaatteeddwwiitthhtthheeddeessccrriippttoorr**//ffoorr((ii==00;;ii<<lleenn;;ii++++)){{**((((cchhaarr**))ddeessccppttrr-->>bbuuffffeerr11++ii))==**((((cchhaarr**))bbuuff++ii));;}} //**MMaarrkktthheeddeessccrriippttoorriiffwweeaarreeaatttthheeeennddoofftthheerriinngg**//iiff((eetthhppttrr-->>ttxxTTaaiill====00)){{ddeessccppttrr-->>ccttrrllssttaatt==EETTHH__QQUUAARRKK__TTDDCCSS__TTEERR;;}}eellssee{{ddeessccppttrr-->>ccttrrllssttaatt==00;;}} //**IInniittiiaalliizzeetthheeddeessccrriippttoorr**//ddeessccppttrr-->>ccttrrllssttaatt||==((EETTHH__QQUUAARRKK__TTDDCCSS__OOWWNN||//**TThheeddeesscciissoowwnneeddbbyyDDMMAA**//EETTHH__QQUUAARRKK__TTDDCCSS__IICC||//**IInntteerrrruuppttaafftteerrttrraannssffeerr**//EETTHH__QQUUAARRKK__TTDDCCSS__LLSS||//**LLaassttsseeggmmeennttooffppaacckkeett**//EETTHH__QQUUAARRKK__TTDDCCSS__FFSS));;//**FFiirrssttsseeggmmeennttooffppaacckkeett**////**UUnn--ssuussppeennddDDMMAAoonntthheeddeevviiccee**//ccssrrppttrr-->>ttppddrr==11;;rreettuurrnnOOKK;;}}Ethwrite waits on the output semaphore, which blocks the calling process until an output ring descriptor is empty and available. The code then copies a packet from the caller’s buffer into the packet buffer associated with the descriptor. If the device is currently idle, ethwrite must start the device. Starting the device is trivial: ethwrite as-signs 1 to the tpdr register in the device’s transmit control register. If the device is al-ready running, the assignment has no effect; if the device is idle, the assignment starts the device, which will examine the next ring descriptor (the one into which the driver placed the packet to be transmitted).Sec. 16.11        Handling Interrupts From An Ethernet Device 34916.11 Handling Interrupts From An Ethernet DeviceOne of the advantages of a DMA device arises because the DMA engine on the de-vice handles many of the details. As a result, interrupt processing does not involvemuch interaction with the device. An interrupt occurs when an input or output opera-tion completes successfully or when the DMA engine encounters an error. To deter-mine the exact cause, the interrupt handler checks the transmit interrupt bit in the con-trol register, and then checks the receive interrupt bit. Other interrupts are acknowl-edged (to reset the hardware), but otherwise ignored. File ethhandler.c contains thecode://**eetthhhhaannddlleerr..cc--eetthhhhaannddlleerr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**eetthhhhaannddlleerr--IInntteerrrruupptthhaannddlleerrffoorrIInntteellQQuuaarrkkEEtthheerrnneett**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntteerrrruupptteetthhhhaannddlleerr((vvooiidd)){{ssttrruucctteetthhccbbllkk**eetthhppttrr;;//**EEtthheerrttaabbeennttrryyppooiinntteerr**//ssttrruucctteetthh__qq__ccssrreegg**ccssrrppttrr;;//**PPooiinntteerrttooEEtthheerrnneettCCRRSSss**//ssttrruucctteetthh__qq__ttxx__ddeesscc**ttddeessccppttrr;;//**PPooiinntteerrttoottxxddeessccrriippttoorr**//ssttrruucctteetthh__qq__rrxx__ddeesscc**rrddeessccppttrr;;//**PPooiinntteerrttoorrxxddeessccrriippttoorr**//vvoollaattiilleeuuiinntt3322ssrr;;//**CCooppyyooffssttaattuussrreeggiisstteerr**//uuiinntt3322ccoouunntt;;//**VVaarriiaabblleeuusseeddttooccoouunnttppkkttss**//eetthhppttrr==&&eetthheerrttaabb[[ddeevvttaabb[[EETTHHEERR00]]..ddvvmmiinnoorr]];;ccssrrppttrr==((ssttrruucctteetthh__qq__ccssrreegg**))eetthhppttrr-->>ccssrr;;//**CCooppyytthheessttaattuussrreeggiisstteerriinnttooaallooccaallvvaarriiaabbllee**//ssrr==ccssrrppttrr-->>ssrr;;//**IIfftthheerreeiissnnooiinntteerrrruuppttppeennddiinngg,,rreettuurrnn**//iiff((((ccssrrppttrr-->>ssrr&&EETTHH__QQUUAARRKK__SSRR__NNIISS))====00)){{rreettuurrnn;;}} //**AAcckknnoowwlleeddggeetthheeiinntteerrrruupptt**//ccssrrppttrr-->>ssrr==ssrr;;350 DMA Devices And Drivers (Ethernet) Chap. 16//**CChheecckkssttaattuussrreeggiisstteerrttooffiigguurreeoouutttthheessoouurrcceeooffiinntteerrrruupptt**//iiff((ssrr&&EETTHH__QQUUAARRKK__SSRR__TTII)){{//**TTrraannssmmiittiinntteerrrruupptt**////**PPooiinntteerrttootthheehheeaaddooffttrraannssmmiittddeessccrriinngg**//ttddeessccppttrr==((ssttrruucctteetthh__qq__ttxx__ddeesscc**))eetthhppttrr-->>ttxxRRiinngg++eetthhppttrr-->>ttxxHHeeaadd;;//**SSttaarrttppaacckkeettccoouunnttaattzzeerroo**//ccoouunntt==00;;//**RReeppeeaattuunnttiillwweepprroocceessssaalllltthheeddeessccrriippttoorrsslloottss**//wwhhiillee((eetthhppttrr-->>ttxxHHeeaadd!!==eetthhppttrr-->>ttxxTTaaiill)){{//**IIfftthheeddeessccrriippttoorriissoowwnneeddbbyyDDMMAA,,ssttoopphheerree**//iiff((ttddeessccppttrr-->>ccttrrllssttaatt&&EETTHH__QQUUAARRKK__TTDDCCSS__OOWWNN)){{bbrreeaakk;;}} //**DDeessccrriippttoorrwwaasspprroocceesssseedd;;iinnccrreemmeennttccoouunntt**//ccoouunntt++++;;//**GGoottootthheenneexxttddeessccrriippttoorr**//ttddeessccppttrr++==11;;//**IInnccrreemmeenntttthheehheeaaddoofftthheettrraannssmmiittddeessccrriinngg**//eetthhppttrr-->>ttxxHHeeaadd++==11;;iiff((eetthhppttrr-->>ttxxHHeeaadd>>==eetthhppttrr-->>ttxxRRiinnggSSiizzee)){{eetthhppttrr-->>ttxxHHeeaadd==00;;ttddeessccppttrr==((ssttrruucctteetthh__qq__ttxx__ddeesscc**))eetthhppttrr-->>ttxxRRiinngg;;}}}} //**’’ccoouunntt’’ppaacckkeettsswweerreepprroocceesssseeddbbyyDDMMAA,,aannddsslloottssaarree**////**nnoowwffrreeee;;ssiiggnnaalltthheesseemmaapphhoorreeaaccccoorrddiinnggllyy**//ssiiggnnaallnn((eetthhppttrr-->>oosseemm,,ccoouunntt));;Sec. 16.11        Handling Interrupts From An Ethernet Device 351}} iiff((ssrr&&EETTHH__QQUUAARRKK__SSRR__RRII)){{//**RReecceeiivveeiinntteerrrruupptt**////**GGeetttthheeppooiinntteerrttootthheettaaiilloofftthheerreecceeiivveeddeesscclliisstt**//rrddeessccppttrr==((ssttrruucctteetthh__qq__rrxx__ddeesscc**))eetthhppttrr-->>rrxxRRiinngg++eetthhppttrr-->>rrxxTTaaiill;;ccoouunntt==00;;//**SSttaarrttppaacckkeettccoouunnttaattzzeerroo**////**RReeppeeaattuunnttiillwweehhaavveerreecceeiivveedd**////**mmaaxxiimmuummnnoo..ppaacckkeettsstthhaattccaannffiittiinnqquueeuuee**//wwhhiillee((ccoouunntt<<==eetthhppttrr-->>rrxxRRiinnggSSiizzee)){{//**IIfftthheeddeessccrriippttoorriissoowwnneeddbbyytthheeDDMMAA,,ssttoopp**//iiff((rrddeessccppttrr-->>ssttaattuuss&&EETTHH__QQUUAARRKK__RRDDSSTT__OOWWNN)){{bbrreeaakk;;}} //**DDeessccrriippttoorrwwaasspprroocceesssseedd;;iinnccrreemmeennttccoouunntt**//ccoouunntt++++;;//**GGoottootthheenneexxttddeessccrriippttoorr**//rrddeessccppttrr++==11;;//**IInnccrreemmeenntttthheettaaiilliinnddeexxoofftthheerrxxddeessccrriinngg**//eetthhppttrr-->>rrxxTTaaiill++==11;;iiff((eetthhppttrr-->>rrxxTTaaiill>>==eetthhppttrr-->>rrxxRRiinnggSSiizzee)){{eetthhppttrr-->>rrxxTTaaiill==00;;rrddeessccppttrr==((ssttrruucctteetthh__qq__rrxx__ddeesscc**))eetthhppttrr-->>rrxxRRiinngg;;}}}} //**’’ccoouunntt’’ppaacckkeettsswweerreerreecceeiivveeddaannddaarreeaavvaaiillaabbllee,,**////**ssoossiiggnnaalltthheesseemmaapphhoorreeaaccccoorrddiinnggllyy**//ssiiggnnaallnn((eetthhppttrr-->>iisseemm,,ccoouunntt));;}} rreettuurrnn;;}}352 DMA Devices And Drivers (Ethernet) Chap. 16Note that when an interrupt occurs, more than one packet may have been transmit-ted or received. The transmit interrupt code iterates through the descriptor ring, countsthe available slots, and uses signaln to signal the output semaphore. The receive inter-rupt code iterates through the descriptor ring, counts available packets, and uses signalnto signal the input semaphore.16.12 Ethernet Control FunctionsThe Ethernet driver supports three control functions: a caller can fetch the MAC address from the device, add a multicast address to the set of addresses that the driver accepts, or remove a multicast address from the set. The MAC address is trivial: be-cause the MAC address is copied into the control block at startup, the code merely copies the address from the control block into the buffer the caller has provided (arg1).Rather than incorporate code for multicast address manipulation into ethcontrol, the code has been placed into two functions.  Ethmcast_add adds an address to the set (inserts it in the array that ethread examines), and ethmcast_remove deletes an address from the array.//**eetthhccoonnttrrooll..cc--eetthhccoonnttrrooll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**eetthhccoonnttrrooll--iimmpplleemmeennttccoonnttrroollffuunnccttiioonnffoorraaqquuaarrkkeetthheerrnneettddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaalllleetthhccoonnttrrooll((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**eennttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322ffuunncc,,//**ccoonnttrroollffuunnccttiioonn**//iinntt3322aarrgg11,,//**aarrgguummeenntt11,,iiffnneeeeddeedd**//iinntt3322aarrgg22//**aarrgguummeenntt22,,iiffnneeeeddeedd**//)){{ssttrruucctteetthhccbbllkk**eetthhppttrr;;//**EEtthheerrttaabbeennttrryyppooiinntteerr**//iinntt3322rreettvvaall==OOKK;;//**RReettuurrnnvvaalluueeooffccnnttllffuunnccttiioonn**//eetthhppttrr==&&eetthheerrttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;sswwiittcchh((ffuunncc)){{//**GGeettMMAACCaaddddrreessss**//ccaasseeEETTHH__CCTTRRLL__GGEETT__MMAACC::Sec. 16.12        Ethernet Control Functions 353mmeemmccppyy((((bbyyttee**))aarrgg11,,eetthhppttrr-->>ddeevvAAddddrreessss,,EETTHH__AADDDDRR__LLEENN));;bbrreeaakk;;//**AAddddaammuullttiiccaassttaaddddrreessss**//ccaasseeEETTHH__CCTTRRLL__AADDDD__MMCCAASSTT::rreettvvaall==eetthhmmccaasstt__aadddd((eetthhppttrr,,((bbyyttee**))aarrgg11));;bbrreeaakk;;//**RReemmoovveeaammuullttiiccaassttaaddddrreessss**//ccaasseeEETTHH__CCTTRRLL__RREEMMOOVVEE__MMCCAASSTT::rreettvvaall==eetthhmmccaasstt__rreemmoovvee((eetthhppttrr,,((bbyyttee**))aarrgg11));;bbrreeaakk;;ddeeffaauulltt::rreettuurrnnSSYYSSEERRRR;;}} rreettuurrnnrreettvvaall;;}}16.13 PerspectiveDMA devices present an interesting irony to a programmer who must write a de-vice driver. On the one hand, DMA hardware can be incredibly complex, and the docu-mentation (which is called a data sheet) is often so difficult to understand that program-mers find it impenetrable. Unlike a device with a few simple control and status regis-ters, a DMA device requires a programmer to create complex data structures in memory and to communicate their location to the device. Furthermore, a programmer must understand exactly how and when the hardware sets response bits in the data structures and how the hardware interprets the requests that the operating system generates. On the other hand, once a programmer masters the documentation, the resulting driver code is usually smaller than the code for a non-DMA device. Thus, DMA devices have a steep learning curve, but offer the reward of both higher performance and smaller driver code.354 DMA Devices And Drivers (Ethernet) Chap. 1616.14 SummaryA device that uses Direct Memory Access (DMA) can move an arbitrary block of data between the device and memory without using the processor to fetch individual words of data. A DMA device typically uses a descriptor ring in memory, where each node in the ring points to one buffer. Once the driver points the hardware to a node of the ring, the DMA engine performs the operation and moves to the next node on the ring automatically.The chief advantage of a DMA device lies in lower overhead: the device onlyneeds to interrupt the processor once per block instead of once per byte or once perword. The driver code for a DMA device is simpler than the code for a conventional device because the driver does not need to perform low-level operations.EXERCISES16.1  Read about Ethernet packets and find the minimum packet size. At 100 Mbps, howmany packets can arrive per second?16.2      Our code merely accepts all multicast packets and allows the driver to filter. Consult thehardware data sheet, and rewrite the code to use the multicast filtering that the hardware provides.16.3     In the previous exercise, is it necessary for the driver to check incoming packets even ifhardware filtering is enabled? Explain.16.4      Build a test program that transmits Ethernet packets as fast as possible. How many largepackets can you send per second? How many small packets?16.5  The current driver is complex and the code is somewhat difficult to read. Can yourewrite the code to allocate ring descriptor and buffers statically? Why or why not?Chapter Contents17.1 Introduction, 35717.2 Required Functionality, 35817.3 Simultaneous Conversations, Timeouts, And Processes, 35917.4 A Consequence Of The Design, 35917.5 ARP Functions, 36017.6 Definition Of A Network Packet, 37117.7 The Network Input Process, 37317.8 Definitions For IP, 37717.9 IP Functions, 37717.10 Definition Of The UDP Table, 388 17.11 UDP Functions, 38917.12 Internet Control Message Protocol, 403 17.13 Dynamic Host Configuration Protocol, 404 17.14 Perspective, 41217.15 Summary, 41317A Minimal Internet Protocol Stack
The lure of the distant and the difficult is deceptive.The great opportunity is where you are.— John Burroughs17.1 IntroductionMost embedded systems are connected — they use computer networks to access remote services and storage facilities. As a result, protocol software has become a re-quired part of even small embedded operating systems. The previous chapter describes a basic Ethernet device driver that can send and receive packets. Although an Ethernet device can transfer packets across a single network, additional communication software is required to permit applications to communicate across the Internet. In particular, the TCP/Internet Protocol Suite defines the protocols used for Internet communication. The protocols are organized into conceptual layers, and an implementation is known as a protocol stack.A complete TCP/IP stack contains many protocols, and requires much more than a single chapter to describe. Therefore, this chapter describes a minimal implementation that is sufficiently powerful to support the remote disk and remote file systems covered later in the book. It provides a brief description without delving into the details of the protocols; the reader is referred to other texts from the author that explain the protocol suite and a full implementation.357358 A Minimal Internet Protocol Stack Chap. 1717.2 Required FunctionalityOur implementation of Internet protocols allows a process running on Xinu to communicate with an application running on a remote computer in the Internet (e.g., aPC, Mac, or Unix system, such as Linux or Solaris). It is possible to identify a remote computer and exchange messages with the computer. The system includes a timeout mechanism that allows a receiver to be informed if no message is received within a specified timeout.In terms of protocols, our implementation supports basic Internet protocols:IP Internet Protocol†UDP User Datagram ProtocolARP Address Resolution ProtocolDHCP Dynamic Host Configuration ProtocolICMP Internet Control Message ProtocolThe Internet Protocol (IP) defines the format of an internet packet, which is known as a datagram. Each datagram is carried in the data area of an Ethernet frame. The In-ternet Protocol also defines the address format. Our implementation does not support IPv4 options or features such as fragmentation (i.e., it is not a complete implementa-tion). Packet forwarding follows the pattern used in most end systems: our IPv4 software knows the computer’s IP address, address mask for the local network, and a single default router address; if a destination is not on the local network, the packet is sent to the default router.The User Datagram Protocol (UDP) defines a set of 16-bit port numbers that an operating system uses to identify a specific application program. Communicating appli-cations must agree on the port numbers they will use. Port numbers allow simultaneous communication without interference: an application can interact with one remote server while a second application interacts with another. Our software allows a process to specify a port number at runtime.The Address Resolution Protocol (ARP) provides two functions. Before another computer can send IP packets to our system, the computer must send an ARP packetthat requests our Ethernet address and our system must respond with an ARP reply. Similarly, before our system can send IP packets to another computer, it first sends an ARP request to obtain the computer’s Ethernet address, then uses the Ethernet address to send IP packets.The Dynamic Host Configuration Protocol (DHCP) provides a mechanism that a computer can use to obtain an IP address, an address mask for the network, and the IP address of a default router. The computer broadcasts a request, and a DHCP server running on the network sends a response. Usually, DHCP is invoked at startup because the information must be obtained before normal Internet communication is possible. Our implementation does not invoke DHCP immediately at startup. Instead, it waits until a process attempts to obtain a local IP address.†Throughout this text, IP will refer to version 4 of the Internet Protocol, which is sometimes written IPv4to distinguish it from the successor, IPv6.Sec. 17.2        Required Functionality 359The Internet Control Message Protocol (ICMP) provides error and informational messages that support IP. Our implementation only handles the two ICMP messages used by the ping program: Echo Request and Echo Reply. Because the code for ICMPis large, we describe the structure of the protocol software without showing all the de-tails; the code is available on the web site for the text.†17.3 Simultaneous Conversations, Timeouts, And ProcessesHow should protocol software be organized? How many processes are needed? There is no easy answer. Our minimal stack implements the set of protocols described above with an elegant design that has a single network input process, named netin,‡ and a single IP output process named ipout. The software uses recvtime to handle timeout-and-retransmission. That is, after transmitting a message, a sender calls recvtime to wait for a response. When a response arrives, the netin process calls a function that sends a message to the waiting process, and recvtime returns the message. If the timer expires, recvtime returns value TIMEOUT. The protocol software provides coordination between application processes and netin. We will see how the software handles timeout. Figure 17.1 illustrates the basic idea: the netin process places an incoming UDP packet in a queue associated with a UDP port number, and uses an incoming ARP packet to supply information for an ARP table entry. In either case, if an application process is waiting for the incoming packet, netin sends a message to allow the waiting process to run.packet arrivesnetin processP1 P2UDP table entries (one per port)ARP table entries (one per address)Figure 17.1The operation of the netin process that handles incoming packetsby using UDP and ARP tables to coordinate with processes that are waiting for the packets.17.4 A Consequence Of The DesignThe use of a netin process has an important consequence for the overall design of protocol software. To understand the consequence, one must know three facts. First, netin is the only process that reads and handles incoming packets — if netin blocks, no more incoming packets will be handled. Second, incoming IP packets sometimes cause †URL: xinu.cs.purdue.edu‡The code for netin can be found later in the chapter in file net.c on page 374.360 A Minimal Internet Protocol Stack Chap. 17the transmission of a reply. For example, the ping protocol, which is used to testwhether a computer is reachable, requires the transmission of a response whenever a ping request arrives. Third, transmission of an outgoing IP packet may require a prel-iminary ARP exchange. That is, before it can send an IP packet, the protocol software may need to send an ARP request and receive an ARP reply.Taken together, the three facts mean that netin must never attempt to transmit anIP packet, or a deadlock can occur. To summarize:Because the netin process must remain running to receive incoming packets, netin must never execute code that blocks waiting for a pack-et to arrive. In particular, netin cannot execute code that sends an IP packet, such as a ping reply.To decouple IP reply output from input, our implementation uses an extra process, ipout. When a local application sends a packet, transmission can proceed directly. When protocol software replies to an incoming packet (e.g., a response to a ping re-quest), however, the netin process enqueues the IP packet for the IP output process to send. Figure 17.2 illustrates the decoupling by showing how a ping request and replypass through the two processes.ping request arrivesnetin processqueue of IP packetsipout processping reply sentFigure 17.2The process structure with ipout decoupled from netin, and theexample of a ping request that causes a reply to be sent.17.5 ARP FunctionsBefore two computers on an Ethernet can communicate using the Internet Protocol,they must learn each other’s Ethernet addresses.† The protocol exchanges two mes-sages: computer A broadcasts an ARP request that contains an IP address. Whichever computer on the network has the IP address in the request sends an ARP response that specifies its Ethernet address. When a response arrives, an entry is added to a table that is known as an ARP cache. The entry contains the remote computer’s IP address and its Ethernet address. Subsequent transmissions to the same destination extract the infor-mation from the ARP cache without sending another request.Our implementation stores ARP information in array arpcache. Struct arpentry defines the contents of each entry in the array to consist of: a state field (which specifies whether the entry is currently unused, being filled in, or already filled in), an IP address, †Technically, they learnMAC addresses, but in our examples, MAC addresses will be Ethernet addresses.Sec. 17.5        ARP Functions 361the corresponding Ethernet address, and a process ID. If the entry is in the pendingstate, the process ID field contains the ID of the process that is waiting for the informa-tion to arrive. File arp.h defines the ARP packet format (when used on an Ethernet) and the format of an ARP cache entry.//**aarrpp..hh**////**IItteemmssrreellaatteeddttooAARRPP--ddeeffiinniittiioonnooffccaacchheeaannddtthheeppaacckkeettffoorrmmaatt**//##ddeeffiinneeAARRPP__HHAALLEENN66//**SSiizzeeooffEEtthheerrnneettMMAACCaaddddrreessss**//##ddeeffiinneeAARRPP__PPAALLEENN44//**SSiizzeeooffIIPPaaddddrreessss**//##ddeeffiinneeAARRPP__HHTTYYPPEE11//**EEtthheerrnneetthhaarrddwwaarreettyyppee**//##ddeeffiinneeAARRPP__PPTTYYPPEE00xx00880000//**IIPPpprroottooccoollttyyppee**//##ddeeffiinneeAARRPP__OOPP__RREEQQ11//**RReeqquueessttooppccooddee**//##ddeeffiinneeAARRPP__OOPP__RRPPLLYY22//**RReeppllyyooppccooddee**//##ddeeffiinneeAARRPP__SSIIZZ1166//**NNuummbbeerrooffeennttrriieessiinnaaccaacchhee**//##ddeeffiinneeAARRPP__RREETTRRYY33//**NNuumm..rreettrriieessffoorrAARRPPrreeqquueesstt**//##ddeeffiinneeAARRPP__TTIIMMEEOOUUTT330000//**RReettrryyttiimmeerriinnmmiilllliisseeccoonnddss**////**SSttaatteeooffaannAARRPPccaacchheeeennttrryy**//##ddeeffiinneeAARR__FFRREEEE00//**SSlloottiissuunnuusseedd**//##ddeeffiinneeAARR__PPEENNDDIINNGG11//**RReessoolluuttiioonniinnpprrooggrreessss**//##ddeeffiinneeAARR__RREESSOOLLVVEEDD22//**EEnnttrryyiissvvaalliidd**//##pprraaggmmaappaacckk((22))ssttrruuccttaarrppppaacckkeett{{//**AARRPPppaacckkeettffoorrIIPP&&EEtthheerrnneett**//bbyytteeaarrpp__eetthhddsstt[[EETTHH__AADDDDRR__LLEENN]];;//**EEtthheerrnneettddeesstt..MMAACCaaddddrr**//bbyytteeaarrpp__eetthhssrrcc[[EETTHH__AADDDDRR__LLEENN]];;//**EEtthheerrnneettssoouurrcceeMMAACCaaddddrreessss**//uuiinntt1166aarrpp__eetthhttyyppee;;//**EEtthheerrnneettttyyppeeffiieelldd**//uuiinntt1166aarrpp__hhttyyppee;;//**AARRPPhhaarrddwwaarreettyyppee**//uuiinntt1166aarrpp__ppttyyppee;;//**AARRPPpprroottooccoollttyyppee**//bbyytteeaarrpp__hhlleenn;;//**AARRPPhhaarrddwwaarreeaaddddrreesssslleennggtthh**//bbyytteeaarrpp__pplleenn;;//**AARRPPpprroottooccoollaaddddrreesssslleennggtthh**//uuiinntt1166aarrpp__oopp;;//**AARRPPooppeerraattiioonn**//bbyytteeaarrpp__ssnnddhhaa[[AARRPP__HHAALLEENN]];;//**AARRPPsseennddeerr’’ssEEtthheerrnneettaaddddrr**//uuiinntt3322aarrpp__ssnnddppaa;;//**AARRPPsseennddeerr’’ssIIPPaaddddrreessss**//bbyytteeaarrpp__ttaarrhhaa[[AARRPP__HHAALLEENN]];;//**AARRPPttaarrggeett’’ssEEtthheerrnneettaaddddrr**//uuiinntt3322aarrpp__ttaarrppaa;;//**AARRPPttaarrggeett’’ssIIPPaaddddrreessss**//}};;362 A Minimal Internet Protocol Stack Chap. 17##pprraaggmmaappaacckk(())ssttrruuccttaarrppeennttrryy{{//**EEnnttrryyiinntthheeAARRPPccaacchhee**//iinntt3322aarrssttaattee;;//**SSttaatteeoofftthheeeennttrryy**//uuiinntt3322aarrppaaddddrr;;//**IIPPaaddddrreessssoofftthheeeennttrryy**//ppiidd3322aarrppiidd;;//**WWaaiittiinnggpprroocceessssoorr--11**//bbyytteeaarrhhaaddddrr[[AARRPP__HHAALLEENN]];;//**EEtthheerrnneettaaddddrreessssoofftthheeeennttrryy**//}};;eexxtteerrnnssttrruuccttaarrppeennttrryyaarrppccaacchhee[[]];;ARP uses the same packet format for both requests and responses; a field in the header specifies the type as a request or response. In each case, the packet contains the sender’s IP address and Ethernet address as well as the target’s IP address and Ethernet address. In a request, the target’s Ethernet address is unknown, so the field contains zeroes.Our ARP software consists of four functions, arp_init, arp_resolve, arp_in, andarp_alloc. All four functions reside in a single source file, arp.c://**aarrpp..cc--aarrpp__iinniitt,,aarrpp__rreessoollvvee,,aarrpp__iinn,,aarrpp__aalllloocc,,aarrpp__nnttoohh,,aarrpp__hhttoonn**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttaarrppeennttrryyaarrppccaacchhee[[AARRPP__SSIIZZ]];;//**AARRPPccaacchhee**////**------------------------------------------------------------------------------------------------------------------------------------------------**aarrpp__iinniitt--IInniittiiaalliizzeeAARRPPccaacchheeffoorraannEEtthheerrnneettiinntteerrffaaccee**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddaarrpp__iinniitt((vvooiidd)){{iinntt3322ii;;//**AARRPPccaacchheeiinnddeexx**//ffoorr((ii==11;;ii<<AARRPP__SSIIZZ;;ii++++)){{//**IInniittiiaalliizzeeccaacchheettooeemmppttyy**//aarrppccaacchhee[[ii]]..aarrssttaattee==AARR__FFRREEEE;;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**aarrpp__rreessoollvvee--UUsseeAARRPPttoorreessoollvveeaannIIPPaaddddrreessssttooaannEEtthheerrnneettaaddddrreessss**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussaarrpp__rreessoollvvee((uuiinntt3322nnxxtthhoopp,,//**NNeexxtt--hhooppaaddddrreessssttoorreessoollvvee**//Sec. 17.5        ARP Functions 363bbyytteemmaacc[[EETTHH__AADDDDRR__LLEENN]]//**AArrrraayyiinnttoowwhhiicchhEEtthheerrnneett**//))//**aaddddrreesssssshhoouullddbbeeppllaacceedd**//{{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttaarrppppaacckkeettaappkktt;;//**LLooccaallppaacckkeettbbuuffffeerr**//iinntt3322ii;;//**IInnddeexxiinnttooaarrppccaacchhee**//iinntt3322sslloott;;//**AARRPPttaabblleesslloottttoouussee**//ssttrruuccttaarrppeennttrryy**aarrppttrr;;//**PPttrrttooAARRPPccaacchheeeennttrryy**//iinntt3322mmssgg;;//**MMeessssaaggeerreettuurrnneeddbbyyrreeccvvttiimmee**////**UUsseeMMAACCbbrrooaaddccaassttaaddddrreessssffoorrIIPPlliimmiitteeddbbrrooaaddccaasstt**//iiff((nnxxtthhoopp====IIPP__BBCCAASSTT)){{mmeemmccppyy((mmaacc,,NNeettDDaattaa..eetthhbbccaasstt,,EETTHH__AADDDDRR__LLEENN));;rreettuurrnnOOKK;;}} //**UUsseeMMAACCbbrrooaaddccaassttaaddddrreessssffoorrIIPPnneettwwoorrkkbbrrooaaddccaasstt**//iiff((nnxxtthhoopp====NNeettDDaattaa..iippbbccaasstt)){{mmeemmccppyy((mmaacc,,NNeettDDaattaa..eetthhbbccaasstt,,EETTHH__AADDDDRR__LLEENN));;rreettuurrnnOOKK;;}} //**EEnnssuurreeoonnllyyoonneepprroocceessssuusseessAARRPPaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**SSeeeeiiffnneexxtthhooppaaddddrreessssiissaallrreeaaddyypprreesseennttiinnAARRPPccaacchhee**//ffoorr((ii==00;;ii<<AARRPP__SSIIZZ;;ii++++)){{aarrppttrr==&&aarrppccaacchhee[[ii]];;iiff((aarrppttrr-->>aarrssttaattee====AARR__FFRREEEE)){{ccoonnttiinnuuee;;}} iiff((aarrppttrr-->>aarrppaaddddrr====nnxxtthhoopp)){{//**AAddddddrreessssiissiinnccaacchhee**//bbrreeaakk;;}}}} iiff((ii<<AARRPP__SSIIZZ)){{//**EEnnttrryywwaassffoouunndd**////**IIffeennttrryyiissrreessoollvveedd--hhaannddlleeaannddrreettuurrnn**//iiff((aarrppttrr-->>aarrssttaattee====AARR__RREESSOOLLVVEEDD)){{364 A Minimal Internet Protocol Stack Chap. 17mmeemmccppyy((mmaacc,,aarrppttrr-->>aarrhhaaddddrr,,AARRPP__HHAALLEENN));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**EEnnttrryyiissaallrreeaaddyyppeennddiinngg--rreettuurrnneerrrroorrbbeeccaauussee**////**oonnllyyoonneepprroocceessssccaannbbeewwaaiittiinnggaattaattiimmee**//iiff((aarrppttrr-->>aarrssttaattee====AARR__PPEENNDDIINNGG)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}}} //**IIPPaaddddrreessssnnoottiinnccaacchhee--aallllooccaatteeaanneewwccaacchheeeennttrryyaanndd**////**sseennddaannAARRPPrreeqquueessttttoooobbttaaiinntthheeaannsswweerr**//sslloott==aarrpp__aalllloocc(());;iiff((sslloott====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} aarrppttrr==&&aarrppccaacchhee[[sslloott]];;aarrppttrr-->>aarrssttaattee==AARR__PPEENNDDIINNGG;;aarrppttrr-->>aarrppaaddddrr==nnxxtthhoopp;;aarrppttrr-->>aarrppiidd==ccuurrrrppiidd;;//**HHaanndd--ccrraaffttaannAARRPPRReeqquueessttppaacckkeett**//mmeemmccppyy((aappkktt..aarrpp__eetthhddsstt,,NNeettDDaattaa..eetthhbbccaasstt,,EETTHH__AADDDDRR__LLEENN));;mmeemmccppyy((aappkktt..aarrpp__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;aappkktt..aarrpp__eetthhttyyppee==EETTHH__AARRPP;;//**PPaacckkeettttyyppeeiissAARRPP**//aappkktt..aarrpp__hhttyyppee==AARRPP__HHTTYYPPEE;;//**HHaarrddwwaarreettyyppeeiissEEtthheerrnneett**//aappkktt..aarrpp__ppttyyppee==AARRPP__PPTTYYPPEE;;//**PPrroottooccoollttyyppeeiissIIPP**//aappkktt..aarrpp__hhlleenn==00xxffff&&AARRPP__HHAALLEENN;;//**EEtthheerrnneettMMAACCssiizzeeiinnbbyytteess**//aappkktt..aarrpp__pplleenn==00xxffff&&AARRPP__PPAALLEENN;;//**IIPPaaddddrreessssssiizzeeiinnbbyytteess**//aappkktt..aarrpp__oopp==00xxffffffff&&AARRPP__OOPP__RREEQQ;;//**AARRPPttyyppeeiissRReeqquueesstt**//mmeemmccppyy((aappkktt..aarrpp__ssnnddhhaa,,NNeettDDaattaa..eetthhuuccaasstt,,AARRPP__HHAALLEENN));;aappkktt..aarrpp__ssnnddppaa==NNeettDDaattaa..iippuuccaasstt;;//**IIPPaaddddrreessssooffiinntteerrffaaccee**//mmeemmsseett((aappkktt..aarrpp__ttaarrhhaa,,’’\\00’’,,AARRPP__HHAALLEENN));;//**TTaarrggeettHHAAiissuunnkknnoowwnn**//aappkktt..aarrpp__ttaarrppaa==nnxxtthhoopp;;//**TTaarrggeettpprroottooccoollaaddddrreessss**////**CCoonnvveerrttAARRPPppaacckkeettffrroommhhoossttttoonneettbbyytteeoorrddeerr**//Sec. 17.5        ARP Functions 365aarrpp__hhttoonn((&&aappkktt));;//**CCoonnvveerrttEEtthheerrnneetthheeaaddeerrffrroommhhoossttttoonneettbbyytteeoorrddeerr**//eetthh__hhttoonn((((ssttrruuccttnneettppaacckkeett**))&&aappkktt));;//**SSeennddtthheeppaacckkeettAARRPP__RREETTRRYYttiimmeessaannddaawwaaiittrreessppoonnssee**//mmssgg==rreeccvvccllrr(());;ffoorr((ii==00;;ii<<AARRPP__RREETTRRYY;;ii++++)){{wwrriittee((EETTHHEERR00,,((cchhaarr**))&&aappkktt,,ssiizzeeooff((ssttrruuccttaarrppppaacckkeett))));;mmssgg==rreeccvvttiimmee((AARRPP__TTIIMMEEOOUUTT));;iiff((mmssgg====TTIIMMEEOOUUTT)){{ccoonnttiinnuuee;;}}eellsseeiiff((mmssgg====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}eellssee{{//**eennttrryyiissrreessoollvveedd**//bbrreeaakk;;}}}} //**IIffnnoorreessppoonnssee,,rreettuurrnnTTIIMMEEOOUUTT**//iiff((mmssgg====TTIIMMEEOOUUTT)){{aarrppttrr-->>aarrssttaattee==AARR__FFRREEEE;;//**IInnvvaalliiddaatteeccaacchheeeennttrryy**//rreessttoorree((mmaasskk));;rreettuurrnnTTIIMMEEOOUUTT;;}} //**RReettuurrnnhhaarrddwwaarreeaaddddrreessss**//mmeemmccppyy((mmaacc,,aarrppttrr-->>aarrhhaaddddrr,,AARRPP__HHAALLEENN));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**aarrpp__iinn--HHaannddlleeaanniinnccoommiinnggAARRPPppaacckkeett**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddaarrpp__iinn((ssttrruuccttaarrppppaacckkeett**ppkkttppttrr//**PPttrrttooiinnccoommiinnggppaacckkeett**//))366 A Minimal Internet Protocol Stack Chap. 17{{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttaarrppppaacckkeettaappkktt;;//**LLooccaallppaacckkeettbbuuffffeerr**//iinntt3322sslloott;;//**SSlloottiinnccaacchhee**//ssttrruuccttaarrppeennttrryy**aarrppttrr;;//**PPttrrttooAARRPPccaacchheeeennttrryy**//bbooooll88ffoouunndd;;//**IIsstthheesseennddeerr’’ssaaddddrreessssiinn**////**tthheeccaacchhee??**////**CCoonnvveerrttppaacckkeettffrroommnneettwwoorrkkoorrddeerrttoohhoossttoorrddeerr**//aarrpp__nnttoohh((ppkkttppttrr));;//**VVeerriiffyyAARRPPiissffoorrIIPPvv44aannddEEtthheerrnneett**//iiff((((ppkkttppttrr-->>aarrpp__hhttyyppee!!==AARRPP__HHTTYYPPEE))||||((ppkkttppttrr-->>aarrpp__ppttyyppee!!==AARRPP__PPTTYYPPEE)))){{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}} //**EEnnssuurreeoonnllyyoonneepprroocceessssuusseessAARRPPaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**SSeeaarrcchhccaacchheeffoorrsseennddeerr’’ssIIPPaaddddrreessss**//ffoouunndd==FFAALLSSEE;;ffoorr((sslloott==00;;sslloott<<AARRPP__SSIIZZ;;sslloott++++)){{aarrppttrr==&&aarrppccaacchhee[[sslloott]];;//**SSkkiippttaabblleeeennttrriieesstthhaattaarreeuunnuusseedd**//iiff((aarrppttrr-->>aarrssttaattee====AARR__FFRREEEE)){{ccoonnttiinnuuee;;}} //**IIffsseennddeerr’’ssaaddddrreessssmmaattcchheess,,wwee’’vveeffoouunnddiitt**//iiff((aarrppttrr-->>aarrppaaddddrr====ppkkttppttrr-->>aarrpp__ssnnddppaa)){{ffoouunndd==TTRRUUEE;;bbrreeaakk;;}}}}Sec. 17.5        ARP Functions 367iiff((ffoouunndd)){{//**UUppddaatteesseennddeerr’’sshhaarrddwwaarreeaaddddrreessss**//mmeemmccppyy((aarrppttrr-->>aarrhhaaddddrr,,ppkkttppttrr-->>aarrpp__ssnnddhhaa,,AARRPP__HHAALLEENN));;//**IIffaapprroocceesssswwaasswwaaiittiinngg,,iinnffoorrmmtthheepprroocceessss**//iiff((aarrppttrr-->>aarrssttaattee====AARR__PPEENNDDIINNGG)){{//**MMaarrkkrreessoollvveeddaannddnnoottiiffyywwaaiittiinnggpprroocceessss**//aarrppttrr-->>aarrssttaattee==AARR__RREESSOOLLVVEEDD;;sseenndd((aarrppttrr-->>aarrppiidd,,OOKK));;}}}} //**FFoorraannAARRPPrreeppllyy,,pprroocceessssiinnggiissccoommpplleettee**//iiff((ppkkttppttrr-->>aarrpp__oopp====AARRPP__OOPP__RRPPLLYY)){{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnn;;}} //**TThheeffoolllloowwiinnggiissffoorraannAARRPPrreeqquueessttppaacckkeett::iifftthheellooccaall**////**mmaacchhiinneeiissnnootttthheettaarrggeettoorrtthheellooccaallIIPPaaddddrreessssiissnnoott**////**yyeettkknnoowwnn,,iiggnnoorreetthheerreeqquueesstt((ii..ee..,,pprroocceessssiinnggiissccoommpplleettee))**//iiff((((!!NNeettDDaattaa..iippvvaalliidd))||||((ppkkttppttrr-->>aarrpp__ttaarrppaa!!==NNeettDDaattaa..iippuuccaasstt)))){{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnn;;}} //**RReeqquueesstthhaassbbeeeennsseennttttootthheellooccaallmmaacchhiinnee’’ssaaddddrreessss..SSoo,,**////**aaddddsseennddeerr’’ssiinnffoottooccaacchhee,,iiffnnoottaallrreeaaddyypprreesseenntt**//iiff((!!ffoouunndd)){{sslloott==aarrpp__aalllloocc(());;iiff((sslloott====SSYYSSEERRRR)){{//**CCaacchheeiissffuullll**//kkpprriinnttff((""AARRPPccaacchheeoovveerrfflloowwoonniinntteerrffaaccee\\nn""));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnn;;}}368 A Minimal Internet Protocol Stack Chap. 17aarrppttrr==&&aarrppccaacchhee[[sslloott]];;aarrppttrr-->>aarrppaaddddrr==ppkkttppttrr-->>aarrpp__ssnnddppaa;;mmeemmccppyy((aarrppttrr-->>aarrhhaaddddrr,,ppkkttppttrr-->>aarrpp__ssnnddhhaa,,AARRPP__HHAALLEENN));;aarrppttrr-->>aarrssttaattee==AARR__RREESSOOLLVVEEDD;;}} //**HHaanndd--ccrraaffttaannAARRPPrreeppllyyppaacckkeettaannddsseennddbbaacckkttoorreeqquueesstteerr**//mmeemmccppyy((aappkktt..aarrpp__eetthhddsstt,,ppkkttppttrr-->>aarrpp__ssnnddhhaa,,AARRPP__HHAALLEENN));;mmeemmccppyy((aappkktt..aarrpp__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,AARRPP__HHAALLEENN));;aappkktt..aarrpp__eetthhttyyppee==EETTHH__AARRPP;;//**FFrraammeeccaarrrriieessAARRPP**//aappkktt..aarrpp__hhttyyppee==AARRPP__HHTTYYPPEE;;//**HHaarrddwwaarreeiissEEtthheerrnneett**//aappkktt..aarrpp__ppttyyppee==AARRPP__PPTTYYPPEE;;//**PPrroottooccoolliissIIPP**//aappkktt..aarrpp__hhlleenn==AARRPP__HHAALLEENN;;//**EEtthheerrnneettaaddddrreessssssiizzee**//aappkktt..aarrpp__pplleenn==AARRPP__PPAALLEENN;;//**IIPPaaddddrreessssssiizzee**//aappkktt..aarrpp__oopp==AARRPP__OOPP__RRPPLLYY;;//**TTyyppeeiissRReeppllyy**////**IInnsseerrttllooccaallEEtthheerrnneettaannddIIPPaaddddrreessssiinnsseennddeerrffiieellddss**//mmeemmccppyy((aappkktt..aarrpp__ssnnddhhaa,,NNeettDDaattaa..eetthhuuccaasstt,,AARRPP__HHAALLEENN));;aappkktt..aarrpp__ssnnddppaa==NNeettDDaattaa..iippuuccaasstt;;//**CCooppyyttaarrggeettEEtthheerrnneettaannddIIPPaaddddrreesssseessffrroommrreeqquueessttppaacckkeett**//mmeemmccppyy((aappkktt..aarrpp__ttaarrhhaa,,ppkkttppttrr-->>aarrpp__ssnnddhhaa,,AARRPP__HHAALLEENN));;aappkktt..aarrpp__ttaarrppaa==ppkkttppttrr-->>aarrpp__ssnnddppaa;;//**CCoonnvveerrttAARRPPppaacckkeettffrroommhhoossttttoonneettwwoorrkkbbyytteeoorrddeerr**//aarrpp__hhttoonn((&&aappkktt));;//**CCoonnvveerrtttthheeEEtthheerrnneetthheeaaddeerrttoonneettwwoorrkkbbyytteeoorrddeerr**//eetthh__hhttoonn((((ssttrruuccttnneettppaacckkeett**))&&aappkktt));;//**SSeennddtthheerreeppllyy**//wwrriittee((EETTHHEERR00,,((cchhaarr**))&&aappkktt,,ssiizzeeooff((ssttrruuccttaarrppppaacckkeett))));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**aarrpp__aalllloocc--FFiinnddaaffrreeeesslloottoorrkkiicckkoouuttaanneennttrryyttooccrreeaatteeoonneeSec. 17.5        ARP Functions 369**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322aarrpp__aalllloocc(()){{iinntt3322sslloott;;//**SSlloottiinnAARRPPccaacchhee**////**SSeeaarrcchhffoorraaffrreeeesslloott**//ffoorr((sslloott==00;;sslloott<<AARRPP__SSIIZZ;;sslloott++++)){{iiff((aarrppccaacchhee[[sslloott]]..aarrssttaattee====AARR__FFRREEEE)){{mmeemmsseett((((cchhaarr**))&&aarrppccaacchhee[[sslloott]],,NNUULLLLCCHH,,ssiizzeeooff((ssttrruuccttaarrppeennttrryy))));;rreettuurrnnsslloott;;}}}} //**SSeeaarrcchhffoorraarreessoollvveeddeennttrryy**//ffoorr((sslloott==00;;sslloott<<AARRPP__SSIIZZ;;sslloott++++)){{iiff((aarrppccaacchhee[[sslloott]]..aarrssttaattee====AARR__RREESSOOLLVVEEDD)){{mmeemmsseett((((cchhaarr**))&&aarrppccaacchhee[[sslloott]],,NNUULLLLCCHH,,ssiizzeeooff((ssttrruuccttaarrppeennttrryy))));;rreettuurrnnsslloott;;}}}} //**AAtttthhiissppooiinntt,,aallllsslloottssaarreeppeennddiinngg((sshhoouullddnnootthhaappppeenn))**//kkpprriinnttff((""AARRPPccaacchheessiizzeeeexxcceeeeddeedd\\nn""));;rreettuurrnnSSYYSSEERRRR;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**aarrpp__nnttoohh--CCoonnvveerrttAARRPPppaacckkeettffiieellddssffrroommnneettttoohhoossttbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddaarrpp__nnttoohh((ssttrruuccttaarrppppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>aarrpp__hhttyyppee==nnttoohhss((ppkkttppttrr-->>aarrpp__hhttyyppee));;ppkkttppttrr-->>aarrpp__ppttyyppee==nnttoohhss((ppkkttppttrr-->>aarrpp__ppttyyppee));;ppkkttppttrr-->>aarrpp__oopp==nnttoohhss((ppkkttppttrr-->>aarrpp__oopp));;ppkkttppttrr-->>aarrpp__ssnnddppaa==nnttoohhll((ppkkttppttrr-->>aarrpp__ssnnddppaa));;370 A Minimal Internet Protocol Stack Chap. 17ppkkttppttrr-->>aarrpp__ttaarrppaa==nnttoohhll((ppkkttppttrr-->>aarrpp__ttaarrppaa));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**aarrpp__hhttoonn--CCoonnvveerrttAARRPPppaacckkeettffiieellddssffrroommnneettttoohhoossttbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddaarrpp__hhttoonn((ssttrruuccttaarrppppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>aarrpp__hhttyyppee==hhttoonnss((ppkkttppttrr-->>aarrpp__hhttyyppee));;ppkkttppttrr-->>aarrpp__ppttyyppee==hhttoonnss((ppkkttppttrr-->>aarrpp__ppttyyppee));;ppkkttppttrr-->>aarrpp__oopp==hhttoonnss((ppkkttppttrr-->>aarrpp__oopp));;ppkkttppttrr-->>aarrpp__ssnnddppaa==hhttoonnll((ppkkttppttrr-->>aarrpp__ssnnddppaa));;ppkkttppttrr-->>aarrpp__ttaarrppaa==hhttoonnll((ppkkttppttrr-->>aarrpp__ttaarrppaa));;}}Function arp_init is called once when the system starts. It marks each entry in the ARP cache free, and creates a mutual exclusion semaphore that ensures only one proc-ess will attempt to change the ARP cache (e.g., insert an entry) at any time. Functions arp_resolve and arp_in are used to handle address lookup for outgoing IP packets and to process incoming ARP packets, respectively. The final function, arp_alloc, is called to allocate an entry in the table whenever a new item must be added.Function arp_resolve is called when an IP packet is ready to be sent. Arp_resolve takes two arguments: the first specifies the IP address of a computer for which an Ether-net address is needed; the second is a pointer to an array that will hold the Ethernet ad-dress.Although the code may seem complex, there are only three cases: the IP address isa broadcast address, the information is already in the ARP cache, or the information isnot known. For an IP broadcast address, arp_resolve copies the Ethernet broadcast ad-dress into the array specified by the second argument. If the information is present in the cache, arp_resolve finds the correct entry, copies the Ethernet address from the en-try into the caller’s array, and returns to the caller without sending any packets over the network.In the case where the requested mapping is not in the cache, arp_resolvemust send packets over the network to obtain the information. The exchange involves sending a request and waiting for a reply.  Arp_resolve creates an entry in the table, marks the en-try AR_PENDING, forms an ARP request packet, broadcasts the packet on the local net-work, and then waits for a reply. As discussed above, arp_resolve uses recvtime to wait. The call to recvtime will return if a response arrives or the timer expires, which-ever occurs first. In the next section, we will describe how an incoming packet is pro-cessed and how a message is sent to a waiting process.Sec. 17.5        ARP Functions 371The code is more complex than we have described because arp_resolve does not merely give up if a timeout occurs. Instead, our implementation is designed to retry the operation: it sends a request and waits for a reply ARP_RETRY times before it returns TIMEOUT to the caller.Arp_in, the second major ARP function, runs when an incoming ARP packet ar-rives. The netin process examines the type field in each incoming Ethernet packet. If it finds the ARP packet type (0x806), netin calls function arp_in to handle the packet. Arp_in must handle two cases: either the packet is a request that was initiated by anoth-er computer or it is a reply, possibly to a request that we have sent.The protocol specifies that when either type of packet arrives, ARP must examine the sender’s information (IP address and Ethernet address), and update the local cache accordingly. If a process is waiting for the reply, arp_in sends a message to the proc-ess.Because an ARP request is broadcast, all computers on the network receive each request. Therefore, after it updates the sender’s information, arp_in checks the target IP address in a request to determine whether the request is for the local system or some other computer on the network. If the request is for another computer, arp_in returns without taking further action. If the target IP address in the incoming request matches the IP address of the local system, arp_in sends an ARP reply.  Arp_in forms a reply in variable apkt. Once all fields of the packet have been filled in, the code calls write on the Ethernet device to transmit the reply back to the requester.17.6 Definition Of A Network PacketOur minimal implementation of network protocols combines IP, UDP, ICMP, and Ethernet. That is, we use a single data structure, named netpacket, to describe an Ether-net packet that carries an IP datagram which either carries a UDP message or an ICMP message. File net.h defines netpacket as well as constants, such as the Ethernet type values used for ARP and IP. Finally, the file defines a network data structure that holds address information for the local machine (both Ethernet and IP addresses), and variable NetData to be a struct of type network.372 A Minimal Internet Protocol Stack Chap. 17//**nneett..hh**//##ddeeffiinneeNNEETTSSTTKK88119922//**SSttaacckkssiizzeeffoorrnneettwwoorrkksseettuupp**//##ddeeffiinneeNNEETTPPRRIIOO550000//**NNeettwwoorrkkssttaarrttuupppprriioorriittyy**//##ddeeffiinneeNNEETTBBOOOOTTFFIILLEE112288//**SSiizzeeoofftthheenneettbboooottffiilleennaammee**////**CCoonnssttaannttssuusseeddiinntthheenneettwwoorrkkiinnggccooddee**//##ddeeffiinneeEETTHH__AARRPP00xx00880066//**EEtthheerrnneettttyyppeeffoorrAARRPP**//##ddeeffiinneeEETTHH__IIPP00xx00880000//**EEtthheerrnneettttyyppeeffoorrIIPP**//##ddeeffiinneeEETTHH__IIPPvv6600xx8866DDDD//**EEtthheerrnneettttyyppeeffoorrIIPPvv66**////**FFoorrmmaattooffaannEEtthheerrnneettppaacckkeettccaarrrryyiinnggIIPPvv44aannddUUDDPP**//##pprraaggmmaappaacckk((22))ssttrruuccttnneettppaacckkeett{{bbyytteenneett__eetthhddsstt[[EETTHH__AADDDDRR__LLEENN]];;//**EEtthheerrnneettddeesstt..MMAACCaaddddrreessss**//bbyytteenneett__eetthhssrrcc[[EETTHH__AADDDDRR__LLEENN]];;//**EEtthheerrnneettssoouurrcceeMMAACCaaddddrreessss**//uuiinntt1166nneett__eetthhttyyppee;;//**EEtthheerrnneettttyyppeeffiieelldd**//bbyytteenneett__iippvvhh;;//**IIPPvveerrssiioonnaannddhhddrrlleennggtthh**//bbyytteenneett__iippttooss;;//**IIPPttyyppeeooffsseerrvviiccee**//uuiinntt1166nneett__iipplleenn;;//**IIPPttoottaallppaacckkeettlleennggtthh**//uuiinntt1166nneett__iippiidd;;//**IIPPddaattaaggrraammIIDD**//uuiinntt1166nneett__iippffrraagg;;//**IIPPffllaaggss&&ffrraaggmmeennttooffffsseett**//bbyytteenneett__iippttttll;;//**IIPPttiimmee--ttoo--lliivvee**//bbyytteenneett__iipppprroottoo;;//**IIPPpprroottooccooll((aaccttuuaallllyyttyyppee))**//uuiinntt1166nneett__iippcckkssuumm;;//**IIPPcchheecckkssuumm**//uuiinntt3322nneett__iippssrrcc;;//**IIPPssoouurrcceeaaddddrreessss**//uuiinntt3322nneett__iippddsstt;;//**IIPPddeessttiinnaattiioonnaaddddrreessss**//uunniioonn{{ssttrruucctt{{uuiinntt1166nneett__uuddppssppoorrtt;;//**UUDDPPssoouurrcceepprroottooccoollppoorrtt**//uuiinntt1166nneett__uuddppddppoorrtt;;//**UUDDPPddeessttiinnaattiioonnpprroottooccoollppoorrtt**//uuiinntt1166nneett__uuddpplleenn;;//**UUDDPPttoottaalllleennggtthh**//uuiinntt1166nneett__uuddppcckkssuumm;;//**UUDDPPcchheecckkssuumm**//bbyytteenneett__uuddppddaattaa[[11550000--2288]];;//**UUDDPPppaayyllooaadd((11550000--aabboovvee))**//}};;ssttrruucctt{{bbyytteenneett__iiccttyyppee;;//**IICCMMPPmmeessssaaggeettyyppee**//bbyytteenneett__iiccccooddee;;//**IICCMMPPccooddeeffiieelldd((00ffoorrppiinngg))**//uuiinntt1166nneett__iicccckkssuumm;;//**IICCMMPPmmeessssaaggeecchheecckkssuumm**//uuiinntt1166nneett__iicciiddeenntt;;//**IICCMMPPiiddeennttiiffiieerr**//uuiinntt1166nneett__iiccsseeqq;;//**IICCMMPPsseeqquueenncceennuummbbeerr**//bbyytteenneett__iiccddaattaa[[11550000--2288]];;//**IICCMMPPppaayyllooaadd((11550000--aabboovvee))**//}};;}};;}};;##pprraaggmmaappaacckk(())Sec. 17.6        Definition Of A Network Packet 373##ddeeffiinneePPAACCKKLLEENNssiizzeeooff((ssttrruuccttnneettppaacckkeett))eexxtteerrnnbbppiidd3322nneettbbuuffppooooll;;//**IIDDooffnneettppaacckkeettbbuuffffeerrppooooll**//ssttrruuccttnneettwwoorrkk{{uuiinntt3322iippuuccaasstt;;uuiinntt3322iippbbccaasstt;;uuiinntt3322iippmmaasskk;;uuiinntt3322iipppprreeffiixx;;uuiinntt3322iipprroouutteerr;;uuiinntt3322bboooottsseerrvveerr;;bbooooll88iippvvaalliidd;;bbyytteeeetthhuuccaasstt[[EETTHH__AADDDDRR__LLEENN]];;bbyytteeeetthhbbccaasstt[[EETTHH__AADDDDRR__LLEENN]];;cchhaarrbboooottffiillee[[NNEETTBBOOOOTTFFIILLEE]];;}};;eexxtteerrnnssttrruuccttnneettwwoorrkkNNeettDDaattaa;;//**LLooccaallNNeettwwoorrkkIInntteerrffaaccee**//17.7 The Network Input ProcessAt startup, Xinu calls function net_init to initialize data structures and start the net-work processes. After it creates the network buffer pool and initializes global variables, net_init calls arp_init, udp_init, and icmp_init. It then initializes the IP output queue to empty, and creates the netin and netout processes.The netin process repeatedly allocates a buffer, waits for the next packet, and then performs packet demultiplexing. That is, netin uses information in each incoming pack-et to decide which protocol to use to process the packet. When it reads a packet froman Ethernet, netin uses the Ethernet type field in the packet to determine whether the Ethernet packet is carrying an ARP message or an IP datagram. In the case of ARP, netin passes the packet to arp_in, which performs input processing on arriving ARP packets. In the case of an IP datagram, netin passes the packet to ip_in, which performs input processing on arriving IP datagrams.The code contains two additional cases: one for IPv6 and a default for all other packets. In each case, the action is the same: netin drops (i.e., discards) the packet without further processing. To do so, netin calls freebuf and passes a pointer to the buffer. The case for IPv6 has been separated from the default to indicate where onewould add code for IPv6.File net.c contains the code for both net_init and netin.374 A Minimal Internet Protocol Stack Chap. 17//**nneett..cc--nneett__iinniitt,,nneettiinn,,eetthh__hhttoonn**//##iinncclluuddee<<xxiinnuu..hh>>##iinncclluuddee<<ssttddiioo..hh>>ssttrruuccttnneettwwoorrkkNNeettDDaattaa;;bbppiidd3322nneettbbuuffppooooll;;//**------------------------------------------------------------------------------------------------------------------------------------------------**nneett__iinniitt--IInniittiiaalliizzeenneettwwoorrkkddaattaassttrruuccttuurreessaannddpprroocceesssseess**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddnneett__iinniitt((vvooiidd)){{iinntt3322nnbbuuffss;;//**TToottaallnnooooffbbuuffffeerrss**////**IInniittiiaalliizzeetthheenneettwwoorrkkddaattaassttrruuccttuurree**//mmeemmsseett((((cchhaarr**))&&NNeettDDaattaa,,NNUULLLLCCHH,,ssiizzeeooff((ssttrruuccttnneettwwoorrkk))));;//**OObbttaaiinntthheeEEtthheerrnneettMMAACCaaddddrreessss**//ccoonnttrrooll((EETTHHEERR00,,EETTHH__CCTTRRLL__GGEETT__MMAACC,,((iinntt3322))NNeettDDaattaa..eetthhuuccaasstt,,00));;mmeemmsseett((((cchhaarr**))NNeettDDaattaa..eetthhbbccaasstt,,00xxFFFF,,EETTHH__AADDDDRR__LLEENN));;//**CCrreeaatteetthheenneettwwoorrkkbbuuffffeerrppooooll**//nnbbuuffss==UUDDPP__SSLLOOTTSS**UUDDPP__QQSSIIZZ++IICCMMPP__SSLLOOTTSS**IICCMMPP__QQSSIIZZ++11;;nneettbbuuffppooooll==mmkkbbuuffppooooll((PPAACCKKLLEENN,,nnbbuuffss));;//**IInniittiiaalliizzeetthheeAARRPPccaacchhee**//aarrpp__iinniitt(());;//**IInniittiiaalliizzeeUUDDPP**//uuddpp__iinniitt(());;//**IInniittiiaalliizzeeIICCMMPP**//iiccmmpp__iinniitt(());;//**IInniittiiaalliizzeetthheeIIPPoouuttppuuttqquueeuuee**//Sec. 17.7        The Network Input Process 375iippooqquueeuuee..iiqqhheeaadd==00;;iippooqquueeuuee..iiqqttaaiill==00;;iippooqquueeuuee..iiqqsseemm==sseemmccrreeaattee((00));;iiff((((iinntt3322))iippooqquueeuuee..iiqqsseemm====SSYYSSEERRRR)){{ppaanniicc((""CCaannnnoottccrreeaatteeiippoouuttppuuttqquueeuueesseemmaapphhoorree""));;rreettuurrnn;;}} //**CCrreeaatteetthheeIIPPoouuttppuuttpprroocceessss**//rreessuummee((ccrreeaattee((iippoouutt,,NNEETTSSTTKK,,NNEETTPPRRIIOO,,""iippoouutt"",,00,,NNUULLLL))));;//**CCrreeaatteeaanneettwwoorrkkiinnppuuttpprroocceessss**//rreessuummee((ccrreeaattee((nneettiinn,,NNEETTSSTTKK,,NNEETTPPRRIIOO,,""nneettiinn"",,00,,NNUULLLL))));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**nneettiinn--RReeppeeaatteeddllyyrreeaaddaannddpprroocceesssstthheenneexxttiinnccoommiinnggppaacckkeett**------------------------------------------------------------------------------------------------------------------------------------------------**//pprroocceessssnneettiinn(()){{ssttrruuccttnneettppaacckkeett**ppkktt;;//**PPttrrttooccuurrrreennttppaacckkeett**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluueeffrroommrreeaadd**////**DDooffoorreevveerr::rreeaaddaappaacckkeettffrroommtthheenneettwwoorrkkaannddpprroocceessss**//wwhhiillee((11)){{//**AAllllooccaatteeaabbuuffffeerr**//ppkktt==((ssttrruuccttnneettppaacckkeett**))ggeettbbuuff((nneettbbuuffppooooll));;//**OObbttaaiinnnneexxttppaacckkeetttthhaattaarrrriivveess**//rreettvvaall==rreeaadd((EETTHHEERR00,,((cchhaarr**))ppkktt,,PPAACCKKLLEENN));;iiff((rreettvvaall====SSYYSSEERRRR)){{ppaanniicc((""CCaannnnoottrreeaaddffrroommEEtthheerrnneett\\nn""));;}} //**CCoonnvveerrttEEtthheerrnneettTTyyppeettoohhoossttoorrddeerr**//eetthh__nnttoohh((ppkktt));;376 A Minimal Internet Protocol Stack Chap. 17//**DDeemmuullttiipplleexxoonnEEtthheerrnneettttyyppee**//sswwiittcchh((ppkktt-->>nneett__eetthhttyyppee)){{ccaasseeEETTHH__AARRPP:://**HHaannddlleeAARRPP**//aarrpp__iinn((((ssttrruuccttaarrppppaacckkeett**))ppkktt));;ccoonnttiinnuuee;;ccaasseeEETTHH__IIPP:://**HHaannddlleeIIPP**//iipp__iinn((ppkktt));;ccoonnttiinnuuee;;ccaasseeEETTHH__IIPPvv66:://**HHaannddlleeIIPPvv66**//ffrreeeebbuuff((((cchhaarr**))ppkktt));;ccoonnttiinnuuee;;ddeeffaauulltt:://**IIggnnoorreeaallllootthheerriinnccoommiinnggppaacckkeettss**//ffrreeeebbuuff((((cchhaarr**))ppkktt));;ccoonnttiinnuuee;;}}}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eetthh__hhttoonn--CCoonnvveerrttEEtthheerrnneettttyyppeeffiieellddttoonneettwwoorrkkbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddeetthh__hhttoonn((ssttrruuccttnneettppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>nneett__eetthhttyyppee==hhttoonnss((ppkkttppttrr-->>nneett__eetthhttyyppee));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**eetthh__nnttoohh--CCoonnvveerrttEEtthheerrnneettttyyppeeffiieellddttoohhoossttbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddeetthh__nnttoohh((ssttrruuccttnneettppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>nneett__eetthhttyyppee==nnttoohhss((ppkkttppttrr-->>nneett__eetthhttyyppee));;}}Sec. 17.8        Definitions For IP 37717.8 Definitions For IPFile ip.h contains definitions needed for functions that handle the Internet Protocol (IP), including constants for the local broadcast address, type values for UDP and ICMP, and header constants. The file also defines struct iqentry that specifies the con-tents of an entry in the IP output queue.//**iipp..hh--CCoonnssttaannttssrreellaatteeddttooIInntteerrnneettPPrroottooccoollvveerrssiioonn44((IIPPvv44))**//##ddeeffiinneeIIPP__BBCCAASSTT00xxffffffffffffffff//**IIPPllooccaallbbrrooaaddccaassttaaddddrreessss**//##ddeeffiinneeIIPP__TTHHIISS00xxffffffffffffffff//**""tthhiisshhoosstt""ssrrccIIPPaaddddrreessss**//##ddeeffiinneeIIPP__AALLLLZZEERROOSS00xx0000000000000000//**TThheeaallll--zzeerroossIIPPaaddddrreessss**//##ddeeffiinneeIIPP__IICCMMPP11//**IICCMMPPpprroottooccoollttyyppeeffoorrIIPP**//##ddeeffiinneeIIPP__UUDDPP1177//**UUDDPPpprroottooccoollttyyppeeffoorrIIPP**//##ddeeffiinneeIIPP__AASSIIZZEE44//**BByytteessiinnaannIIPPaaddddrreessss**//##ddeeffiinneeIIPP__HHDDRR__LLEENN2200//**BByytteessiinnaannIIPPhheeaaddeerr**//##ddeeffiinneeIIPP__VVHH00xx4455//**IIPPvveerrssiioonnaannddhhddrrlleennggtthh**//##ddeeffiinneeIIPP__OOQQSSIIZZ88//**SSiizzeeooffIIPPoouuttppuuttqquueeuuee**////**QQuueeuueeooffoouuttggooiinnggIIPPppaacckkeettsswwaaiittiinnggffoorriippoouuttpprroocceessss**//ssttrruuccttiiqqeennttrryy{{iinntt3322iiqqhheeaadd;;//**IInnddeexxooffnneexxttppaacckkeettttoosseenndd**//iinntt3322iiqqttaaiill;;//**IInnddeexxooffnneexxttffrreeeesslloott**//ssiidd3322iiqqsseemm;;//**SSeemmaapphhoorreetthhaattccoouunnttssppkkttss**//ssttrruuccttnneettppaacckkeett**iiqqbbuuff[[IIPP__OOQQSSIIZZ]];;//**CCiirrccuullaarrppaacckkeettqquueeuuee**//}};;eexxtteerrnnssttrruuccttiiqqeennttrryyiippooqquueeuuee;;//**NNeettwwoorrkkoouuttppuuttqquueeuuee**//17.9 IP FunctionsOur IP software uses eight functions that are specified in file ip.c: ip_in, ip_send,ip_local, ip_out, ipcksum, ip_hton, ip_ntoh, and ip_enqueue. In addition, the file con-tains the code for ipout, the IP output process.On input, ip_in passes valid datagrams to ip_local, which examines the type field in the datagram. Datagrams carrying UDP are passed to udp_in, datagrams carrying ICMP are passed to icmp_in, and other datagrams are dropped.378 A Minimal Internet Protocol Stack Chap. 17//**iipp..cc--iipp__iinn,,iipp__sseenndd,,iipp__llooccaall,,iipp__oouutt,,iippcckkssuumm,,iipp__hhttoonn,,iipp__nnttoohh,,**////**iippoouutt,,iipp__eennqquueeuuee**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttiiqqeennttrryyiippooqquueeuuee;;//**QQuueeuueeooffoouuttggooiinnggppaacckkeettss**////**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__iinn--HHaannddlleeaannIIPPppaacckkeetttthhaatthhaassaarrrriivveeddoovveerraanneettwwoorrkk**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddiipp__iinn((ssttrruuccttnneettppaacckkeett**ppkkttppttrr//**PPooiinntteerrttootthheeppaacckkeett**//)){{iinntt3322iiccmmpplleenn;;//**LLeennggtthhooffIICCMMPPmmeessssaaggee**////**VVeerriiffyycchheecckkssuumm**//iiff((iippcckkssuumm((ppkkttppttrr))!!==00)){{kkpprriinnttff((""IIPPhheeaaddeerrcchheecckkssuummffaaiilleedd\\nn\\rr""));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}} //**CCoonnvveerrttIIPPhheeaaddeerrffiieellddssttoohhoossttoorrddeerr**//iipp__nnttoohh((ppkkttppttrr));;//**EEnnssuurreevveerrssiioonnaannddlleennggtthhaarreevvaalliidd**//iiff((ppkkttppttrr-->>nneett__iippvvhh!!==00xx4455)){{kkpprriinnttff((""IIPPvveerrssiioonnffaaiilleedd\\nn\\rr""));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}} //**VVeerriiffyyeennccaappssuullaatteeddpprroottoottccoollcchheecckkssuummssaannddtthheennccoonnvveerrtt**////**tthheeeennccaappssuullaatteeddhheeaaddeerrssttoohhoossttbbyytteeoorrddeerr**//sswwiittcchh((ppkkttppttrr-->>nneett__iipppprroottoo)){{ccaasseeIIPP__UUDDPP:://**SSkkiippppiinnggUUDDPPcchheecckkssuummffoorrnnooww**//Sec. 17.9        IP Functions379uuddpp__nnttoohh((ppkkttppttrr));;bbrreeaakk;;ccaasseeIIPP__IICCMMPP::iiccmmpplleenn==ppkkttppttrr-->>nneett__iipplleenn--IIPP__HHDDRR__LLEENN;;iiff((iiccmmpp__cckkssuumm((((cchhaarr**))&&ppkkttppttrr-->>nneett__iiccttyyppee,,iiccmmpplleenn))!!==00)){{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}} iiccmmpp__nnttoohh((ppkkttppttrr));;bbrreeaakk;;ddeeffaauulltt::bbrreeaakk;;}} //**DDeelliivveerr225555..225555..225555..225555ttoollooccaallssttaacckk**//iiff((ppkkttppttrr-->>nneett__iippddsstt====IIPP__BBCCAASSTT)){{iipp__llooccaall((ppkkttppttrr));;rreettuurrnn;;}} //**IIffwweeddoonnoottyyeetthhaavveeaavvaalliiddaaddddrreessss,,aacccceeppttUUDDPPppaacckkeettss**////**((ttooggeettDDHHCCPPrreepplliieess))aannddddrrooppootthheerrss**//iiff((!!NNeettDDaattaa..iippvvaalliidd)){{iiff((ppkkttppttrr-->>nneett__iipppprroottoo====IIPP__UUDDPP)){{iipp__llooccaall((ppkkttppttrr));;rreettuurrnn;;}}eellssee{{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}}}} //**IIffppaacckkeettiissddeessttiinneeddffoorruuss,,aacccceeppttiitt;;ootthheerrwwiissee,,ddrrooppiitt**//iiff((((ppkkttppttrr-->>nneett__iippddsstt====NNeettDDaattaa..iippuuccaasstt))||||((ppkkttppttrr-->>nneett__iippddsstt====NNeettDDaattaa..iippbbccaasstt))||||((ppkkttppttrr-->>nneett__iippddsstt====IIPP__BBCCAASSTT)))){{iipp__llooccaall((ppkkttppttrr));;rreettuurrnn;;380 A Minimal Internet Protocol Stack Chap. 17}}eellssee{{//**DDrroopptthheeppaacckkeett**//ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__sseenndd--SSeennddaannoouuttggooiinnggIIPPddaattaaggrraammffrroommtthheellooccaallssttaacckk**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussiipp__sseenndd((ssttrruuccttnneettppaacckkeett**ppkkttppttrr//**PPooiinntteerrttootthheeppaacckkeett**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//uuiinntt3322ddeesstt;;//**DDeessttiinnaattiioonnoofftthheeddaattaaggrraamm**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluueeffrroommffuunnccttiioonnss**//uuiinntt3322nnxxtthhoopp;;//**NNeexxtt--hhooppaaddddrreessss**//mmaasskk==ddiissaabbllee(());;//**PPiicckkuupptthheeIIPPddeessttiinnaattiioonnaaddddrreessssffrroommtthheeppaacckkeett**//ddeesstt==ppkkttppttrr-->>nneett__iippddsstt;;//**LLooooppbbaacckkttoollooccaallssttaacckkiiffddeessttiinnaattiioonn112277..00..00..00//88**//iiff((((ddeesstt&&00xxffff000000000000))====00xx77ff000000000000)){{iipp__llooccaall((ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**LLooooppbbaacckkiifftthheeddeessttiinnaattiioonnmmaattcchheessoouurrIIPPuunniiccaassttaaddddrreessss**//iiff((ddeesstt====NNeettDDaattaa..iippuuccaasstt)){{iipp__llooccaall((ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}Sec. 17.9        IP Functions381//**BBrrooaaddccaassttiiffddeessttiinnaattiioonniiss225555..225555..225555..225555**//iiff((((ddeesstt====IIPP__BBCCAASSTT))||||((ddeesstt====NNeettDDaattaa..iippbbccaasstt)))){{mmeemmccppyy((ppkkttppttrr-->>nneett__eetthhddsstt,,NNeettDDaattaa..eetthhbbccaasstt,,EETTHH__AADDDDRR__LLEENN));;rreettvvaall==iipp__oouutt((ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}} //**IIffddeessttiinnaattiioonniissoonntthheellooccaallnneettwwoorrkk,,nneexxtthhooppiisstthhee**////**ddeessttiinnaattiioonn;;ootthheerrwwiissee,,nneexxtthhooppiissddeeffaauullttrroouutteerr**//iiff((((ddeesstt&&NNeettDDaattaa..iippmmaasskk))====NNeettDDaattaa..iipppprreeffiixx)){{//**NNeexxtthhooppiisstthheeddeessttiinnaattiioonniittsseellff**//nnxxtthhoopp==ddeesstt;;}}eellssee{{//**NNeexxtthhooppiissddeeffaauullttrroouutteerroonntthheenneettwwoorrkk**//nnxxtthhoopp==NNeettDDaattaa..iipprroouutteerr;;}} iiff((nnxxtthhoopp====00)){{//**DDeesstt..iinnvvaalliiddoorrnnooddeeffaauullttrroouuttee**//ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnnSSYYSSEERRRR;;}} //**RReessoollvveetthheenneexxtt--hhooppaaddddrreessssttooggeettaaMMAACCaaddddrreessss**//rreettvvaall==aarrpp__rreessoollvvee((nnxxtthhoopp,,ppkkttppttrr-->>nneett__eetthhddsstt));;iiff((rreettvvaall!!==OOKK)){{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnnSSYYSSEERRRR;;}} //**SSeennddtthheeppaacckkeett**//rreettvvaall==iipp__oouutt((ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnrreettvvaall;;}}382 A Minimal Internet Protocol Stack Chap. 17//**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__llooccaall--DDeelliivveerraannIIPPddaattaaggrraammttootthheellooccaallssttaacckk**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddiipp__llooccaall((ssttrruuccttnneettppaacckkeett**ppkkttppttrr//**PPooiinntteerrttootthheeppaacckkeett**//)){{//**UUsseeddaattaaggrraammccoonntteennttssttooddeetteerrmmiinneehhoowwttoopprroocceessss**//sswwiittcchh((ppkkttppttrr-->>nneett__iipppprroottoo)){{ccaasseeIIPP__UUDDPP::uuddpp__iinn((ppkkttppttrr));;rreettuurrnn;;ccaasseeIIPP__IICCMMPP::iiccmmpp__iinn((ppkkttppttrr));;rreettuurrnn;;ddeeffaauulltt::ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreettuurrnn;;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__oouutt--TTrraannssmmiittaannoouuttggooiinnggIIPPddaattaaggrraamm**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussiipp__oouutt((ssttrruuccttnneettppaacckkeett**ppkkttppttrr//**PPooiinntteerrttootthheeppaacckkeett**//)){{uuiinntt1166cckkssuumm;;//**CChheecckkssuummiinnhhoossttbbyytteeoorrddeerr**//iinntt3322lleenn;;//**LLeennggtthhooffIICCMMPPmmeessssaaggee**//iinntt3322ppkkttlleenn;;//**LLeennggtthhooffeennttiirreeppaacckkeett**//iinntt3322rreettvvaall;;//**VVaalluueerreettuurrnneeddbbyywwrriittee**////**CCoommppuutteettoottaallppaacckkeettlleennggtthh**//ppkkttlleenn==ppkkttppttrr-->>nneett__iipplleenn++EETTHH__HHDDRR__LLEENN;;Sec. 17.9        IP Functions383//**CCoonnvveerrtteennccaappssuullaatteeddpprroottooccoollttoonneettwwoorrkkbbyytteeoorrddeerr**//sswwiittcchh((ppkkttppttrr-->>nneett__iipppprroottoo)){{ccaasseeIIPP__UUDDPP::ppkkttppttrr-->>nneett__uuddppcckkssuumm==00;;uuddpp__hhttoonn((ppkkttppttrr));;//**......sskkiippppiinnggUUDDPPcchheecckkssuummccoommppuuttaattiioonn**//bbrreeaakk;;ccaasseeIIPP__IICCMMPP:: iiccmmpp__hhttoonn((ppkkttppttrr));;//**CCoommppuutteeIICCMMPPcchheecckkssuumm**//ppkkttppttrr-->>nneett__iicccckkssuumm==00;;lleenn==ppkkttppttrr-->>nneett__iipplleenn--IIPP__HHDDRR__LLEENN;;cckkssuumm==iiccmmpp__cckkssuumm((((cchhaarr**))&&ppkkttppttrr-->>nneett__iiccttyyppee,,lleenn));;ppkkttppttrr-->>nneett__iicccckkssuumm==00xxffffffff&&hhttoonnss((cckkssuumm));;bbrreeaakk;;ddeeffaauulltt::bbrreeaakk;;}} //**CCoonnvveerrttIIPPffiieellddssttoonneettwwoorrkkbbyytteeoorrddeerr**//iipp__hhttoonn((ppkkttppttrr));;//**CCoommppuutteeIIPPhheeaaddeerrcchheecckkssuumm**//ppkkttppttrr-->>nneett__iippcckkssuumm==00;;cckkssuumm==iippcckkssuumm((ppkkttppttrr));;ppkkttppttrr-->>nneett__iippcckkssuumm==00xxffffffff&&hhttoonnss((cckkssuumm));;//**CCoonnvveerrttEEtthheerrnneettffiieellddssttoonneettwwoorrkkbbyytteeoorrddeerr**//eetthh__hhttoonn((ppkkttppttrr));;384 A Minimal Internet Protocol Stack Chap. 17//**SSeennddppaacckkeettoovveerrtthheeEEtthheerrnneett**//rreettvvaall==wwrriittee((EETTHHEERR00,,((cchhaarr**))ppkkttppttrr,,ppkkttlleenn));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;iiff((rreettvvaall====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}}eellssee{{rreettuurrnnOOKK;;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iippcckkssuumm--CCoommppuutteetthheeIIPPhheeaaddeerrcchheecckkssuummffoorraaddaattaaggrraamm**------------------------------------------------------------------------------------------------------------------------------------------------**//uuiinntt1166iippcckkssuumm((ssttrruuccttnneettppaacckkeett**ppkktt//**PPooiinntteerrttootthheeppaacckkeett**//)){{uuiinntt1166**hhppttrr;;//**PPttrrttoo1166--bbiitthheeaaddeerrvvaalluueess**//iinntt3322ii;;//**CCoouunnttss1166--bbiittvvaalluueessiinnhhddrr**//uuiinntt1166wwoorrdd;;//**OOnnee1166--bbiittwwoorrdd**//uuiinntt3322cckkssuumm;;//**CCoommppuutteeddvvaalluueeooffcchheecckkssuumm**//hhppttrr==((uuiinntt1166**))&&ppkktt-->>nneett__iippvvhh;;//**SSuumm1166--bbiittwwoorrddssiinntthheeppaacckkeett**//cckkssuumm==00;;ffoorr((ii==00;;ii<<1100;;ii++++)){{wwoorrdd==**hhppttrr++++;;cckkssuumm++==((uuiinntt3322))hhttoonnss((wwoorrdd));;}} //**AAddddiinnccaarrrryy,,aannddttaakkeetthheeoonneess--ccoommpplleemmeenntt**//cckkssuumm++==((cckkssuumm>>>>1166));;cckkssuumm==00xxffffffff&&~~cckkssuumm;;Sec. 17.9        IP Functions385//**UUsseeaallll--11ssffoorrzzeerroo**//iiff((cckkssuumm====00xxffffffff)){{cckkssuumm==00;;}} rreettuurrnn((uuiinntt1166))((00xxffffffff&&cckkssuumm));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__nnttoohh--CCoonnvveerrttIIPPhheeaaddeerrffiieellddssttoohhoossttbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddiipp__nnttoohh((ssttrruuccttnneettppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>nneett__iipplleenn==nnttoohhss((ppkkttppttrr-->>nneett__iipplleenn));;ppkkttppttrr-->>nneett__iippiidd==nnttoohhss((ppkkttppttrr-->>nneett__iippiidd));;ppkkttppttrr-->>nneett__iippffrraagg==nnttoohhss((ppkkttppttrr-->>nneett__iippffrraagg));;ppkkttppttrr-->>nneett__iippssrrcc==nnttoohhll((ppkkttppttrr-->>nneett__iippssrrcc));;ppkkttppttrr-->>nneett__iippddsstt==nnttoohhll((ppkkttppttrr-->>nneett__iippddsstt));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__hhttoonn--CCoonnvveerrttIIPPhheeaaddeerrffiieellddssttoonneettwwoorrkkbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddiipp__hhttoonn((ssttrruuccttnneettppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>nneett__iipplleenn==hhttoonnss((ppkkttppttrr-->>nneett__iipplleenn));;ppkkttppttrr-->>nneett__iippiidd==hhttoonnss((ppkkttppttrr-->>nneett__iippiidd));;ppkkttppttrr-->>nneett__iippffrraagg==hhttoonnss((ppkkttppttrr-->>nneett__iippffrraagg));;ppkkttppttrr-->>nneett__iippssrrcc==hhttoonnll((ppkkttppttrr-->>nneett__iippssrrcc));;ppkkttppttrr-->>nneett__iippddsstt==hhttoonnll((ppkkttppttrr-->>nneett__iippddsstt));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iippoouutt--PPrroocceesssstthhaattttrraannssmmiittssIIPPppaacckkeettssffrroommtthheeIIPPoouuttppuuttqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//386 A Minimal Internet Protocol Stack Chap. 17pprroocceessssiippoouutt((vvooiidd)){{ssttrruuccttnneettppaacckkeett**ppkkttppttrr;;//**PPooiinntteerrttoonneexxtttthheeppaacckkeett**//ssttrruuccttiiqqeennttrryy**iippqqppttrr;;//**PPooiinntteerrttooIIPPoouuttppuuttqquueeuuee**//uuiinntt3322ddeessttiipp;;//**DDeessttiinnaattiioonnIIPPaaddddrreessss**//uuiinntt3322nnxxtthhoopp;;//**NNeexxtthhooppIIPPaaddddrreessss**//iinntt3322rreettvvaall;;//**VVaalluueerreettuurrnneeddbbyyffuunnccttiioonnss**//iippqqppttrr==&&iippooqquueeuuee;;wwhhiillee((11)){{//**OObbttaaiinnnneexxttppaacckkeettffrroommtthheeIIPPoouuttppuuttqquueeuuee**//wwaaiitt((iippqqppttrr-->>iiqqsseemm));;ppkkttppttrr==iippqqppttrr-->>iiqqbbuuff[[iippqqppttrr-->>iiqqhheeaadd++++]];;iiff((iippqqppttrr-->>iiqqhheeaadd>>==IIPP__OOQQSSIIZZ)){{iippqqppttrr-->>iiqqhheeaadd==00;;}} //**FFiilllliinntthheeMMAACCssoouurrcceeaaddddrreessss**//mmeemmccppyy((ppkkttppttrr-->>nneett__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;//**EExxttrraaccttddeessttiinnaattiioonnaaddddrreessssffrroommppaacckkeett**//ddeessttiipp==ppkkttppttrr-->>nneett__iippddsstt;;//**SSaanniittyycchheecckk::ppaacckkeettsssseennttttooiioooouuttsshhoouulldd**nnoott****////**ccoonnttaaiinnaabbrrooaaddccaassttaaddddrreessss..**//iiff((((ddeessttiipp====IIPP__BBCCAASSTT))||||((ddeessttiipp====NNeettDDaattaa..iippbbccaasstt)))){{kkpprriinnttff((""iippoouutt::eennccoouunntteerreeddaabbrrooaaddccaasstt\\nn""));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;ccoonnttiinnuuee;;}} //**CChheecckkwwhheetthheerrddeessttiinnaattiioonniisstthheellooccaallccoommppuutteerr**//iiff((ddeessttiipp====NNeettDDaattaa..iippuuccaasstt)){{iipp__llooccaall((ppkkttppttrr));;ccoonnttiinnuuee;;}}Sec. 17.9        IP Functions387//**CChheecckkwwhheetthheerrddeessttiinnaattiioonniissoonntthheellooccaallnneett**//iiff((((ddeessttiipp&&NNeettDDaattaa..iippmmaasskk))====NNeettDDaattaa..iipppprreeffiixx)){{//**NNeexxtthhooppiisstthheeddeessttiinnaattiioonniittsseellff**//nnxxtthhoopp==ddeessttiipp;;}}eellssee{{//**NNeexxtthhooppiissddeeffaauullttrroouutteerroonntthheenneettwwoorrkk**//nnxxtthhoopp==NNeettDDaattaa..iipprroouutteerr;;}} iiff((nnxxtthhoopp====00)){{//**DDeesstt..iinnvvaalliiddoorrnnooddeeffaauullttrroouuttee**//ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;ccoonnttiinnuuee;;}} //**UUsseeAARRPPttoorreessoollvveenneexxtt--hhooppaaddddrreessss**//rreettvvaall==aarrpp__rreessoollvvee((nnxxtthhoopp,,ppkkttppttrr-->>nneett__eetthhddsstt));;iiff((rreettvvaall!!==OOKK)){{ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;ccoonnttiinnuuee;;}} //**UUsseeiippoouuttttooCCoonnvveerrttbbyytteeoorrddeerraannddsseenndd**//iipp__oouutt((ppkkttppttrr));;}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------**iipp__eennqquueeuuee--DDeeppoossiittaannoouuttggooiinnggIIPPddaattaaggrraammoonntthheeIIPPoouuttppuuttqquueeuuee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussiipp__eennqquueeuuee((ssttrruuccttnneettppaacckkeett**ppkkttppttrr//**PPooiinntteerrttootthheeppaacckkeett**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttiiqqeennttrryy**iippttrr;;//**PPttrr..ttoonneettwwoorrkkoouuttppuuttqquueeuuee**//388 A Minimal Internet Protocol Stack Chap. 17//**EEnnssuurreeoonnllyyoonneepprroocceessssaacccceesssseessoouuttppuuttqquueeuueeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**EEnnqquueeuueeppaacckkeettoonnnneettwwoorrkkoouuttppuuttqquueeuuee**//iippttrr==&&iippooqquueeuuee;;iiff((sseemmccoouunntt((iippttrr-->>iiqqsseemm))>>==IIPP__OOQQSSIIZZ)){{kkpprriinnttff((""iippoouutt::oouuttppuuttqquueeuueeoovveerrffllooww\\nn""));;ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} iippttrr-->>iiqqbbuuff[[iippttrr-->>iiqqttaaiill++++]]==ppkkttppttrr;;iiff((iippttrr-->>iiqqttaaiill>>==IIPP__OOQQSSIIZZ)){{iippttrr-->>iiqqttaaiill==00;;}} ssiiggnnaall((iippttrr-->>iiqqsseemm));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}When a local application sends a datagram, ip_send is invoked. When the netinprocess needs to send a reply, it calls ip_enqueue to enqueue the packet for the IP out-put process to handle.17.10 Definition Of The UDP TableUDP maintains a table that specifies the pairs of UDP endpoints that are currentlyin use. A single endpoint consists of an IP address and a UDP port number. Therefore,an entry in the table has four fields that specify two endpoints: one for a remote com-puter and one for the local computer.To act as a server that can receive a packet from an arbitrary remote computer, a process allocates a table entry, fills in the local endpoint information, and leaves the re-mote endpoint unspecified. To act as a client that communicates with a specific remote computer, a process allocates a table entry and fills in both the local and remote end-point information.In addition to endpoint information, each entry in the UDP table contains a queue of packets that have arrived from the remote system (i.e., packets where the endpoints specified in the packet match those in the table entry). An entry in the UDP table is described by struct udpentry; file udp.h defines the structure as well as associated sym-bolic constants.Sec. 17.10        Definition Of The UDP Table 389//**uuddpp..hh--DDeeccllaarraattiioonnssppeerrttaaiinniinnggttooUUsseerrDDaattaaggrraammPPrroottooccooll((UUDDPP))**//##ddeeffiinneeUUDDPP__SSLLOOTTSS66//**NNuummbbeerrooffooppeennUUDDPPeennddppooiinnttss**//##ddeeffiinneeUUDDPP__QQSSIIZZ88//**PPaacckkeettsseennqquueeuueeddppeerreennddppooiinntt**//##ddeeffiinneeUUDDPP__DDHHCCPP__CCPPOORRTT6688//**PPoorrttnnuummbbeerrffoorrDDHHCCPPcclliieenntt**//##ddeeffiinneeUUDDPP__DDHHCCPP__SSPPOORRTT6677//**PPoorrttnnuummbbeerrffoorrDDHHCCPPsseerrvveerr**////**CCoonnssttaannttssffoorrtthheessttaatteeooffaanneennttrryy**//##ddeeffiinneeUUDDPP__FFRREEEE00//**EEnnttrryyiissuunnuusseedd**//##ddeeffiinneeUUDDPP__UUSSEEDD11//**EEnnttrryyiissbbeeiinngguusseedd**//##ddeeffiinneeUUDDPP__RREECCVV22//**EEnnttrryyhhaassaapprroocceesssswwaaiittiinngg**//##ddeeffiinneeUUDDPP__AANNYYIIFF--22//**RReeggiisstteerraanneennddppooiinnttffoorraannyy**////**iinntteerrffaacceeoonntthheemmaacchhiinnee**//##ddeeffiinneeUUDDPP__HHDDRR__LLEENN88//**BByytteessiinnaaUUDDPPhheeaaddeerr**//ssttrruuccttuuddppeennttrryy{{//**EEnnttrryyiinntthheeUUDDPPeennddppooiinnttttbbll**//iinntt3322uuddssttaattee;;//**SSttaatteeooffeennttrryy::ffrreeee//uusseedd**//uuiinntt3322uuddrreemmiipp;;//**RReemmootteeIIPPaaddddrreessss((zzeerroo**////**mmeeaannss""ddoonn’’ttccaarree""))**//uuiinntt1166uuddrreemmppoorrtt;;//**RReemmootteepprroottooccoollppoorrttnnuummbbeerr**//uuiinntt1166uuddllooccppoorrtt;;//**LLooccaallpprroottooccoollppoorrttnnuummbbeerr**//iinntt3322uuddhheeaadd;;//**IInnddeexxooffnneexxttppaacckkeettttoorreeaadd**//iinntt3322uuddttaaiill;;//**IInnddeexxooffnneexxttsslloottttooiinnsseerrtt**//iinntt3322uuddccoouunntt;;//**CCoouunnttooffppaacckkeettsseennqquueeuueedd**//ppiidd3322uuddppiidd;;//**IIDDooffwwaaiittiinnggpprroocceessss**//ssttrruuccttnneettppaacckkeett**uuddqquueeuuee[[UUDDPP__QQSSIIZZ]];;//**CCiirrccuullaarrppaacckkeettqquueeuuee**//}};;eexxtteerrnnssttrruuccttuuddppeennttrryyuuddppttaabb[[]];;17.11 UDP FunctionsTo permit applications to communicate over the Internet, the UDP interface is designed to allow applications to send and receive UDP messages and to act as either a client or a server. Our UDP software includes eight interface functions†: udp_init, udp_in, udp_register, udp_recv, udp_recvaddr, udp_send, udp_sendto, and udp_release. The functions are collected into a single file, udp.c. Following the file, the text describes each UDP function.†The code also contains two internal functions, udp_ntoh and udp_hton, that translate between host byteorder and network byte order.390 A Minimal Internet Protocol Stack Chap. 17//**uuddpp..cc--uuddpp__iinniitt,,uuddpp__iinn,,uuddpp__rreeggiisstteerr,,uuddpp__sseenndd,,uuddpp__sseennddttoo,,**////**uuddpp__rreeccvv,,uuddpp__rreeccvvaaddddrr,,uuddpp__rreelleeaassee,,uuddpp__nnttoohh,,uuddpp__hhttoonn**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttuuddppeennttrryyuuddppttaabb[[UUDDPP__SSLLOOTTSS]];;//**TTaabblleeooffUUDDPPeennddppooiinnttss**////**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__iinniitt--IInniittiiaalliizzeeaalllleennttrriieessiinntthheeUUDDPPeennddppooiinnttttaabbllee**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiidduuddpp__iinniitt((vvooiidd)){{iinntt3322ii;;//**IInnddeexxiinnttootthheeUUDDPPttaabbllee**//ffoorr((ii==00;;ii<<UUDDPP__SSLLOOTTSS;;ii++++)){{uuddppttaabb[[ii]]..uuddssttaattee==UUDDPP__FFRREEEE;;}} rreettuurrnn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__iinn--HHaannddlleeaanniinnccoommiinnggUUDDPPppaacckkeett**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiidduuddpp__iinn((ssttrruuccttnneettppaacckkeett**ppkkttppttrr//**PPooiinntteerrttootthheeppaacckkeett**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//iinntt3322ii;;//**IInnddeexxiinnttoouuddppttaabb**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttooaauuddppttaabbeennttrryy**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;ffoorr((ii==00;;ii<<UUDDPP__SSLLOOTTSS;;ii++++)){{uuddppttrr==&&uuddppttaabb[[ii]];;iiff((uuddppttrr-->>uuddssttaattee====UUDDPP__FFRREEEE)){{ccoonnttiinnuuee;;Sec. 17.11        UDP Functions 391}} iiff((((ppkkttppttrr-->>nneett__uuddppddppoorrtt====uuddppttrr-->>uuddllooccppoorrtt))&&&&((((uuddppttrr-->>uuddrreemmppoorrtt====00))||||((ppkkttppttrr-->>nneett__uuddppssppoorrtt====uuddppttrr-->>uuddrreemmppoorrtt))))&&&&((((((uuddppttrr-->>uuddrreemmiipp====00))||||((ppkkttppttrr-->>nneett__iippssrrcc====uuddppttrr-->>uuddrreemmiipp)))))))){{//**EEnnttrryymmaattcchheessiinnccoommiinnggppaacckkeett**//iiff((uuddppttrr-->>uuddccoouunntt<<UUDDPP__QQSSIIZZ)){{uuddppttrr-->>uuddccoouunntt++++;;uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddttaaiill++++]]==ppkkttppttrr;;iiff((uuddppttrr-->>uuddttaaiill>>==UUDDPP__QQSSIIZZ)){{uuddppttrr-->>uuddttaaiill==00;;}} iiff((uuddppttrr-->>uuddssttaattee====UUDDPP__RREECCVV)){{uuddppttrr-->>uuddssttaattee==UUDDPP__UUSSEEDD;;sseenndd((uuddppttrr-->>uuddppiidd,,OOKK));;}} rreessttoorree((mmaasskk));;rreettuurrnn;;}}}}}} //**NNoommaattcchh--ssiimmppllyyddiissccaarrddppaacckkeett**//ffrreeeebbuuff((((cchhaarr**))ppkkttppttrr));;rreessttoorree((mmaasskk));;rreettuurrnn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__rreeggiisstteerr--RReeggiisstteerraarreemmootteeIIPP,,rreemmootteeppoorrtt&&llooccaallppoorrttttoo**rreecceeiivveeiinnccoommiinnggUUDDPPmmeessssaaggeessffrroommtthheessppeecciiffiieedd**rreemmootteessiitteesseennttttootthheessppeecciiffiieeddllooccaallppoorrtt**------------------------------------------------------------------------------------------------------------------------------------------------**//uuiidd3322uuddpp__rreeggiisstteerr((uuiinntt3322rreemmiipp,,//**RReemmootteeIIPPaaddddrreessssoorrzzeerroo**//uuiinntt1166rreemmppoorrtt,,//**RReemmootteeUUDDPPpprroottooccoollppoorrtt**//uuiinntt1166llooccppoorrtt//**LLooccaallUUDDPPpprroottooccoollppoorrtt**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//392 A Minimal Internet Protocol Stack Chap. 17iinntt3322sslloott;;//**IInnddeexxiinnttoouuddppttaabb**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttoouuddppttaabbeennttrryy**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**SSeeeeiiffrreeqquueessttaallrreeaaddyyrreeggiisstteerreedd**//ffoorr((sslloott==00;;sslloott<<UUDDPP__SSLLOOTTSS;;sslloott++++)){{uuddppttrr==&&uuddppttaabb[[sslloott]];;iiff((uuddppttrr-->>uuddssttaattee====UUDDPP__FFRREEEE)){{ccoonnttiinnuuee;;}} //**LLooookkaatttthhiisseennttrryyiinnttaabbllee**//iiff((((rreemmppoorrtt====uuddppttrr-->>uuddrreemmppoorrtt))&&&&((llooccppoorrtt====uuddppttrr-->>uuddllooccppoorrtt))&&&&((rreemmiipp====uuddppttrr-->>uuddrreemmiipp)))){{//**RReeqquueessttiissaallrreeaaddyyiinntthheettaabbllee**//rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}}} //**FFiinnddaaffrreeeesslloottaannddaallllooccaatteeiitt**//ffoorr((sslloott==00;;sslloott<<UUDDPP__SSLLOOTTSS;;sslloott++++)){{uuddppttrr==&&uuddppttaabb[[sslloott]];;iiff((uuddppttrr-->>uuddssttaattee!!==UUDDPP__FFRREEEE)){{ccoonnttiinnuuee;;}} uuddppttrr-->>uuddllooccppoorrtt==llooccppoorrtt;;uuddppttrr-->>uuddrreemmppoorrtt==rreemmppoorrtt;;uuddppttrr-->>uuddrreemmiipp==rreemmiipp;;uuddppttrr-->>uuddccoouunntt==00;;uuddppttrr-->>uuddhheeaadd==uuddppttrr-->>uuddttaaiill==00;;uuddppttrr-->>uuddppiidd==--11;;uuddppttrr-->>uuddssttaattee==UUDDPP__UUSSEEDD;;rreessttoorree((mmaasskk));;rreettuurrnnsslloott;;}}Sec. 17.11        UDP Functions 393rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__rreeccvv--RReecceeiivveeaaUUDDPPppaacckkeett**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322uuddpp__rreeccvv((uuiidd3322sslloott,,//**SSlloottiinnttaabblleettoouussee**//cchhaarr**bbuuffff,,//**BBuuffffeerrttoohhoollddUUDDPPddaattaa**//iinntt3322lleenn,,//**LLeennggtthhooffbbuuffffeerr**//uuiinntt3322ttiimmeeoouutt//**RReeaaddttiimmeeoouuttiinnmmsseecc**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttoouuddppttaabbeennttrryy**//uummssgg3322mmssgg;;//**MMeessssaaggeeffrroommrreeccvvttiimmee(())**//ssttrruuccttnneettppaacckkeett**ppkktt;;//**PPooiinntteerrttooppaacckkeettbbeeiinnggrreeaadd**//iinntt3322ii;;//**CCoouunnttssbbyytteessccooppiieedd**//iinntt3322mmssgglleenn;;//**LLeennggtthhooffUUDDPPddaattaaiinnppaacckkeett**//cchhaarr**uuddaattaappttrr;;//**PPooiinntteerrttooUUDDPPddaattaa**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**VVeerriiffyytthhaatttthheesslloottiissvvaalliidd**//iiff((((sslloott<<00))||||((sslloott>>==UUDDPP__SSLLOOTTSS)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**GGeettppooiinntteerrttoottaabblleeeennttrryy**//uuddppttrr==&&uuddppttaabb[[sslloott]];;//**VVeerriiffyytthhaatttthheessllootthhaassbbeeeennrreeggiisstteerreeddaannddiissvvaalliidd**//iiff((uuddppttrr-->>uuddssttaattee!!==UUDDPP__UUSSEEDD)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}394 A Minimal Internet Protocol Stack Chap. 17//**WWaaiittffoorraappaacckkeettttooaarrrriivvee**//iiff((uuddppttrr-->>uuddccoouunntt====00)){{//**NNooppaacckkeettiisswwaaiittiinngg**//uuddppttrr-->>uuddssttaattee==UUDDPP__RREECCVV;;uuddppttrr-->>uuddppiidd==ccuurrrrppiidd;;mmssgg==rreeccvvccllrr(());;mmssgg==rreeccvvttiimmee((ttiimmeeoouutt));;//**WWaaiittffoorraappaacckkeett**//uuddppttrr-->>uuddssttaattee==UUDDPP__UUSSEEDD;;iiff((mmssgg====TTIIMMEEOOUUTT)){{rreessttoorree((mmaasskk));;rreettuurrnnTTIIMMEEOOUUTT;;}}eellsseeiiff((mmssgg!!==OOKK)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}}} //**PPaacckkeetthhaassaarrrriivveedd----ddeeqquueeuueeiitt**//ppkktt==uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddhheeaadd++++]];;iiff((uuddppttrr-->>uuddhheeaadd>>==UUDDPP__QQSSIIZZ)){{uuddppttrr-->>uuddhheeaadd==00;;}} uuddppttrr-->>uuddccoouunntt----;;//**CCooppyyUUDDPPddaattaaffrroommppaacckkeettiinnttooccaalllleerr’’ssbbuuffffeerr**//mmssgglleenn==ppkktt-->>nneett__uuddpplleenn--UUDDPP__HHDDRR__LLEENN;;uuddaattaappttrr==((cchhaarr**))ppkktt-->>nneett__uuddppddaattaa;;iiff((lleenn<<mmssgglleenn)){{mmssgglleenn==lleenn;;}} ffoorr((ii==00;;ii<<mmssgglleenn;;ii++++)){{**bbuuffff++++==**uuddaattaappttrr++++;;}} ffrreeeebbuuff((((cchhaarr**))ppkktt));;rreessttoorree((mmaasskk));;rreettuurrnnmmssgglleenn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__rreeccvvaaddddrr--RReecceeiivveeaaUUDDPPppaacckkeettaannddrreeccoorrddtthheesseennddeerr’’ssaaddddrreessss**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322uuddpp__rreeccvvaaddddrr((Sec. 17.11        UDP Functions 395uuiidd3322sslloott,,//**SSlloottiinnttaabblleettoouussee**//uuiinntt3322**rreemmiipp,,//**LLooccffoorrrreemmootteeIIPPaaddddrreessss**//uuiinntt1166**rreemmppoorrtt,,//**LLooccffoorrrreemmootteepprroottooccoollppoorrtt**//cchhaarr**bbuuffff,,//**BBuuffffeerrttoohhoollddUUDDPPddaattaa**//iinntt3322lleenn,,//**LLeennggtthhooffbbuuffffeerr**//uuiinntt3322ttiimmeeoouutt//**RReeaaddttiimmeeoouuttiinnmmsseecc**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttoouuddppttaabbeennttrryy**//uummssgg3322mmssgg;;//**MMeessssaaggeeffrroommrreeccvvttiimmee(())**//ssttrruuccttnneettppaacckkeett**ppkktt;;//**PPooiinntteerrttooppaacckkeettbbeeiinnggrreeaadd**//iinntt3322mmssgglleenn;;//**LLeennggtthhooffUUDDPPddaattaaiinnppaacckkeett**//iinntt3322ii;;//**CCoouunnttssbbyytteessccooppiieedd**//cchhaarr**uuddaattaappttrr;;//**PPooiinntteerrttooUUDDPPddaattaa**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**VVeerriiffyytthhaatttthheesslloottiissvvaalliidd**//iiff((((sslloott<<00))||||((sslloott>>==UUDDPP__SSLLOOTTSS)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**GGeettppooiinntteerrttoottaabblleeeennttrryy**//uuddppttrr==&&uuddppttaabb[[sslloott]];;//**VVeerriiffyytthhaatttthheessllootthhaassbbeeeennrreeggiisstteerreeddaannddiissvvaalliidd**//iiff((uuddppttrr-->>uuddssttaattee!!==UUDDPP__UUSSEEDD)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**WWaaiittffoorraappaacckkeettttooaarrrriivvee**//iiff((uuddppttrr-->>uuddccoouunntt====00)){{//**NNooppaacckkeettiisswwaaiittiinngg**//uuddppttrr-->>uuddssttaattee==UUDDPP__RREECCVV;;uuddppttrr-->>uuddppiidd==ccuurrrrppiidd;;mmssgg==rreeccvvccllrr(());;mmssgg==rreeccvvttiimmee((ttiimmeeoouutt));;//**WWaaiittffoorraappaacckkeett**//396 A Minimal Internet Protocol Stack Chap. 17uuddppttrr-->>uuddssttaattee==UUDDPP__UUSSEEDD;;iiff((mmssgg====TTIIMMEEOOUUTT)){{rreessttoorree((mmaasskk));;rreettuurrnnTTIIMMEEOOUUTT;;}}eellsseeiiff((mmssgg!!==OOKK)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}}} //**PPaacckkeetthhaassaarrrriivveedd----ddeeqquueeuueeiitt**//ppkktt==uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddhheeaadd++++]];;iiff((uuddppttrr-->>uuddhheeaadd>>==UUDDPP__QQSSIIZZ)){{uuddppttrr-->>uuddhheeaadd==00;;}} //**RReeccoorrddsseennddeerr’’ssIIPPaaddddrreessssaannddUUDDPPppoorrttnnuummbbeerr**//**rreemmiipp==ppkktt-->>nneett__iippssrrcc;;**rreemmppoorrtt==ppkktt-->>nneett__uuddppssppoorrtt;;uuddppttrr-->>uuddccoouunntt----;;//**CCooppyyUUDDPPddaattaaffrroommppaacckkeettiinnttooccaalllleerr’’ssbbuuffffeerr**//mmssgglleenn==ppkktt-->>nneett__uuddpplleenn--UUDDPP__HHDDRR__LLEENN;;uuddaattaappttrr==((cchhaarr**))ppkktt-->>nneett__uuddppddaattaa;;iiff((lleenn<<mmssgglleenn)){{mmssgglleenn==lleenn;;}} ffoorr((ii==00;;ii<<mmssgglleenn;;ii++++)){{**bbuuffff++++==**uuddaattaappttrr++++;;}} ffrreeeebbuuff((((cchhaarr**))ppkktt));;rreessttoorree((mmaasskk));;rreettuurrnnmmssgglleenn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__sseenndd--SSeennddaaUUDDPPppaacckkeettuussiinnggiinnffooiinnaaUUDDPPttaabblleeeennttrryy**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussuuddpp__sseenndd((uuiidd3322sslloott,,//**TTaabblleesslloottttoouussee**//Sec. 17.11        UDP Functions 397cchhaarr**bbuuffff,,//**BBuuffffeerrooffUUDDPPddaattaa**//iinntt3322lleenn//**LLeennggtthhooffddaattaaiinnbbuuffffeerr**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttnneettppaacckkeett**ppkktt;;//**PPooiinntteerrttooppaacckkeettbbuuffffeerr**//iinntt3322ppkkttlleenn;;//**TToottaallppaacckkeettlleennggtthh**//ssttaattiiccuuiinntt1166iiddeenntt==11;;//**DDaattaaggrraammIIDDEENNTTffiieelldd**//cchhaarr**uuddaattaappttrr;;//**PPooiinntteerrttooUUDDPPddaattaa**//uuiinntt3322rreemmiipp;;//**RReemmootteeIIPPaaddddrreessssttoouussee**//uuiinntt1166rreemmppoorrtt;;//**RReemmootteepprroottooccoollppoorrttttoouussee**//uuiinntt1166llooccppoorrtt;;//**LLooccaallpprroottooccoollppoorrttttoouussee**//uuiinntt3322lloocciipp;;//**LLooccaallIIPPaaddddrreessssttaakkeennffrroomm**////**tthheeiinntteerrffaaccee**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttoottaabblleeeennttrryy**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**VVeerriiffyytthhaatttthheesslloottiissvvaalliidd**//iiff((((sslloott<<00))||||((sslloott>>==UUDDPP__SSLLOOTTSS)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**GGeettppooiinntteerrttoottaabblleeeennttrryy**//uuddppttrr==&&uuddppttaabb[[sslloott]];;//**VVeerriiffyytthhaatttthheessllootthhaassbbeeeennrreeggiisstteerreeddaannddiissvvaalliidd**//iiff((uuddppttrr-->>uuddssttaattee====UUDDPP__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyytthhaatttthheessllootthhaassaassppeecciiffiieeddrreemmootteeaaddddrreessss**//rreemmiipp==uuddppttrr-->>uuddrreemmiipp;;iiff((rreemmiipp====00)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}398 A Minimal Internet Protocol Stack Chap. 17lloocciipp==NNeettDDaattaa..iippuuccaasstt;;rreemmppoorrtt==uuddppttrr-->>uuddrreemmppoorrtt;;llooccppoorrtt==uuddppttrr-->>uuddllooccppoorrtt;;//**AAllllooccaatteeaanneettwwoorrkkbbuuffffeerrttoohhoollddtthheeppaacckkeett**//ppkktt==((ssttrruuccttnneettppaacckkeett**))ggeettbbuuff((nneettbbuuffppooooll));;iiff((((iinntt3322))ppkktt====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**CCoommppuutteeppaacckkeettlleennggtthhaassUUDDPPddaattaassiizzee++ffiixxeeddhheeaaddeerrssiizzee**//ppkkttlleenn==((((cchhaarr**))&&ppkktt-->>nneett__uuddppddaattaa--((cchhaarr**))ppkktt))++lleenn;;//**CCrreeaatteeaaUUDDPPppaacckkeettiinnppkktt**//mmeemmccppyy((((cchhaarr**))ppkktt-->>nneett__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;ppkktt-->>nneett__eetthhttyyppee==00xx00880000;;//**TTyyppeeiissIIPP**//ppkktt-->>nneett__iippvvhh==00xx4455;;//**IIPPvveerrssiioonnaannddhhddrrlleennggtthh**//ppkktt-->>nneett__iippttooss==00xx0000;;//**TTyyppeeooffsseerrvviiccee**//ppkktt-->>nneett__iipplleenn==ppkkttlleenn--EETTHH__HHDDRR__LLEENN;;//**TToottaallIIPPddaattaaggrraammlleennggtthh**//ppkktt-->>nneett__iippiidd==iiddeenntt++++;;//**DDaattaaggrraammggeettssnneexxttIIDDEENNTT**//ppkktt-->>nneett__iippffrraagg==00xx00000000;;//**IIPPffllaaggss&&ffrraaggmmeennttooffffsseett**//ppkktt-->>nneett__iippttttll==00xxffff;;//**IIPPttiimmee--ttoo--lliivvee**//ppkktt-->>nneett__iipppprroottoo==IIPP__UUDDPP;;//**DDaattaaggrraammccaarrrriieessUUDDPP**//ppkktt-->>nneett__iippcckkssuumm==00xx00000000;;//**iinniittiiaallcchheecckkssuumm**//ppkktt-->>nneett__iippssrrcc==lloocciipp;;//**IIPPssoouurrcceeaaddddrreessss**//ppkktt-->>nneett__iippddsstt==rreemmiipp;;//**IIPPddeessttiinnaattiioonnaaddddrreessss**//ppkktt-->>nneett__uuddppssppoorrtt==llooccppoorrtt;;//**LLooccaallUUDDPPpprroottooccoollppoorrtt**//ppkktt-->>nneett__uuddppddppoorrtt==rreemmppoorrtt;;//**RReemmootteeUUDDPPpprroottooccoollppoorrtt**//ppkktt-->>nneett__uuddpplleenn==((uuiinntt1166))((UUDDPP__HHDDRR__LLEENN++lleenn));;//**UUDDPPlleennggtthh**//ppkktt-->>nneett__uuddppcckkssuumm==00xx00000000;;//**IIggnnoorreeUUDDPPcchheecckkssuumm**//uuddaattaappttrr==((cchhaarr**))ppkktt-->>nneett__uuddppddaattaa;;ffoorr((;;lleenn>>00;;lleenn----)){{**uuddaattaappttrr++++==**bbuuffff++++;;}} //**CCaalllliippsseennddttoosseennddtthheeddaattaaggrraamm**//iipp__sseenndd((ppkktt));;rreessttoorree((mmaasskk));;Sec. 17.11        UDP Functions 399rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__sseennddttoo--SSeennddaaUUDDPPppaacckkeettttooaassppeecciiffiieeddddeessttiinnaattiioonn**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussuuddpp__sseennddttoo((uuiidd3322sslloott,,//**UUDDPPttaabblleesslloottttoouussee**//uuiinntt3322rreemmiipp,,//**RReemmootteeIIPPaaddddrreessssttoouussee**//uuiinntt1166rreemmppoorrtt,,//**RReemmootteepprroottooccoollppoorrttttoouussee**//cchhaarr**bbuuffff,,//**BBuuffffeerrooffUUDDPPddaattaa**//iinntt3322lleenn//**LLeennggtthhooffddaattaaiinnbbuuffffeerr**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttnneettppaacckkeett**ppkktt;;//**PPooiinntteerrttooaappaacckkeettbbuuffffeerr**//iinntt3322ppkkttlleenn;;//**TToottaallppaacckkeettlleennggtthh**//ssttaattiiccuuiinntt1166iiddeenntt==11;;//**DDaattaaggrraammIIDDEENNTTffiieelldd**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttooaaUUDDPPttaabblleeeennttrryy**//cchhaarr**uuddaattaappttrr;;//**PPooiinntteerrttooUUDDPPddaattaa**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**VVeerriiffyytthhaatttthheesslloottiissvvaalliidd**//iiff((((sslloott<<00))||||((sslloott>>==UUDDPP__SSLLOOTTSS)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**GGeettppooiinntteerrttoottaabblleeeennttrryy**//uuddppttrr==&&uuddppttaabb[[sslloott]];;//**VVeerriiffyytthhaatttthheessllootthhaassbbeeeennrreeggiisstteerreeddaannddiissvvaalliidd**//iiff((uuddppttrr-->>uuddssttaattee====UUDDPP__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}400 A Minimal Internet Protocol Stack Chap. 17//**AAllllooccaatteeaanneettwwoorrkkbbuuffffeerrttoohhoollddtthheeppaacckkeett**//ppkktt==((ssttrruuccttnneettppaacckkeett**))ggeettbbuuff((nneettbbuuffppooooll));;iiff((((iinntt3322))ppkktt====SSYYSSEERRRR)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**CCoommppuutteeppaacckkeettlleennggtthhaassUUDDPPddaattaassiizzee++ffiixxeeddhheeaaddeerrssiizzee**//ppkkttlleenn==((((cchhaarr**))&&ppkktt-->>nneett__uuddppddaattaa--((cchhaarr**))ppkktt))++lleenn;;//**CCrreeaatteeUUDDPPppaacckkeettiinnppkktt**//mmeemmccppyy((((cchhaarr**))ppkktt-->>nneett__eetthhssrrcc,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;ppkktt-->>nneett__eetthhttyyppee==00xx00880000;;//**TTyyppeeiissIIPP**//ppkktt-->>nneett__iippvvhh==00xx4455;;//**IIPPvveerrssiioonnaannddhhddrrlleennggtthh**//ppkktt-->>nneett__iippttooss==00xx0000;;//**TTyyppeeooffsseerrvviiccee**//ppkktt-->>nneett__iipplleenn==ppkkttlleenn--EETTHH__HHDDRR__LLEENN;;//**ttoottaallIIPPddaattaaggrraammlleennggtthh**//ppkktt-->>nneett__iippiidd==iiddeenntt++++;;//**DDaattaaggrraammggeettssnneexxttIIDDEENNTT**//ppkktt-->>nneett__iippffrraagg==00xx00000000;;//**IIPPffllaaggss&&ffrraaggmmeennttooffffsseett**//ppkktt-->>nneett__iippttttll==00xxffff;;//**IIPPttiimmee--ttoo--lliivvee**//ppkktt-->>nneett__iipppprroottoo==IIPP__UUDDPP;;//**DDaattaaggrraammccaarrrriieessUUDDPP**//ppkktt-->>nneett__iippcckkssuumm==00xx00000000;;//**IInniittiiaallcchheecckkssuumm**//ppkktt-->>nneett__iippssrrcc==NNeettDDaattaa..iippuuccaasstt;;//**IIPPssoouurrcceeaaddddrreessss**//ppkktt-->>nneett__iippddsstt==rreemmiipp;;//**IIPPddeessttiinnaattiioonnaaddddrreessss**//ppkktt-->>nneett__uuddppssppoorrtt==uuddppttrr-->>uuddllooccppoorrtt;;//**llooccaallUUDDPPpprroottooccoollppoorrtt**//ppkktt-->>nneett__uuddppddppoorrtt==rreemmppoorrtt;;//**RReemmootteeUUDDPPpprroottooccoollppoorrtt**//ppkktt-->>nneett__uuddpplleenn==((uuiinntt1166))((UUDDPP__HHDDRR__LLEENN++lleenn));;//**UUDDPPlleennggtthh**//ppkktt-->>nneett__uuddppcckkssuumm==00xx00000000;;//**IIggnnoorreeUUDDPPcchheecckkssuumm**//uuddaattaappttrr==((cchhaarr**))ppkktt-->>nneett__uuddppddaattaa;;ffoorr((;;lleenn>>00;;lleenn----)){{**uuddaattaappttrr++++==**bbuuffff++++;;}} //**CCaalllliippsseennddttoosseennddtthheeddaattaaggrraamm**//iipp__sseenndd((ppkktt));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------Sec. 17.11        UDP Functions 401**uuddpp__rreelleeaassee--RReelleeaasseeaapprreevviioouussllyy--rreeggiisstteerreeddUUDDPPsslloott**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussuuddpp__rreelleeaassee((uuiidd3322sslloott//**TTaabblleesslloottttoorreelleeaassee**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttuuddppeennttrryy**uuddppttrr;;//**PPooiinntteerrttoouuddppttaabbeennttrryy**//ssttrruuccttnneettppaacckkeett**ppkktt;;//**ppooiinntteerrttooppaacckkeettbbeeiinnggrreeaadd**////**EEnnssuurreeoonnllyyoonneepprroocceessssccaannaacccceesssstthheeUUDDPPttaabblleeaattaattiimmee**//mmaasskk==ddiissaabbllee(());;//**VVeerriiffyytthhaatttthheesslloottiissvvaalliidd**//iiff((((sslloott<<00))||||((sslloott>>==UUDDPP__SSLLOOTTSS)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**GGeettppooiinntteerrttoottaabblleeeennttrryy**//uuddppttrr==&&uuddppttaabb[[sslloott]];;//**VVeerriiffyytthhaatttthheessllootthhaassbbeeeennrreeggiisstteerreeddaannddiissvvaalliidd**//iiff((uuddppttrr-->>uuddssttaattee====UUDDPP__FFRREEEE)){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} //**DDeeffeerrrreesscchheedduulliinnggttoopprreevveennttffrreeeebbuuffffrroommsswwiittcchhiinnggccoonntteexxtt**//rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTAARRTT));;wwhhiillee((uuddppttrr-->>uuddccoouunntt>>00)){{ppkktt==uuddppttrr-->>uuddqquueeuuee[[uuddppttrr-->>uuddhheeaadd++++]];;iiff((uuddppttrr-->>uuddhheeaadd>>==UUDDPP__QQSSIIZZ)){{uuddppttrr-->>uuddhheeaadd==00;;}} ffrreeeebbuuff((((cchhaarr**))ppkktt));;uuddppttrr-->>uuddccoouunntt----;;}} uuddppttrr-->>uuddssttaattee==UUDDPP__FFRREEEE;;402 A Minimal Internet Protocol Stack Chap. 17rreesscchheedd__ccnnttll((DDEEFFEERR__SSTTOOPP));;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__nnttoohh--CCoonnvveerrttUUDDPPhheeaaddeerrffiieellddssffrroommnneettttoohhoossttbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiidduuddpp__nnttoohh((ssttrruuccttnneettppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>nneett__uuddppssppoorrtt==nnttoohhss((ppkkttppttrr-->>nneett__uuddppssppoorrtt));;ppkkttppttrr-->>nneett__uuddppddppoorrtt==nnttoohhss((ppkkttppttrr-->>nneett__uuddppddppoorrtt));;ppkkttppttrr-->>nneett__uuddpplleenn==nnttoohhss((ppkkttppttrr-->>nneett__uuddpplleenn));;rreettuurrnn;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**uuddpp__hhttoonn--CCoonnvveerrttppaacckkeetthheeaaddeerrffiieellddssffrroommhhoossttttoonneettbbyytteeoorrddeerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiidduuddpp__hhttoonn((ssttrruuccttnneettppaacckkeett**ppkkttppttrr)){{ppkkttppttrr-->>nneett__uuddppssppoorrtt==hhttoonnss((ppkkttppttrr-->>nneett__uuddppssppoorrtt));;ppkkttppttrr-->>nneett__uuddppddppoorrtt==hhttoonnss((ppkkttppttrr-->>nneett__uuddppddppoorrtt));;ppkkttppttrr-->>nneett__uuddpplleenn==hhttoonnss((ppkkttppttrr-->>nneett__uuddpplleenn));;rreettuurrnn;;}}Udp_init. The initialization function is easiest to understand. The system callsudp_init once during startup, and udp_init sets the state of each entry in the UDP tableto indicate that the entry is unused.Udp_in. The ip_in process calls function udp_in when a packet arrives carrying aUDP message. Argument pktptr points to the incoming packet. Udp_in searches theUDP table to see if an entry in the table matches the port numbers and IP addresses inthe current packet. If there is no match, the incoming packet is dropped — udp_in calls freebuf to return the buffer to the buffer pool. If a match does occur, udp_in inserts the incoming packet in the queue associated with the table entry. If the queue is full, udp_in drops the packet. When it inserts a packet in the queue, udp_in checks to see if a process is waiting for a packet to arrive (state UDP_RECV), and sends a message toSec. 17.11        UDP Functions 403the waiting process. Note that at any time, only one process can be waiting for an entryin the table; if multiple processes need to use an entry to communicate, they must coor-dinate among themselves.Udp_register. Before it can use UDP to communicate, an application must call udp_register to specify that it expects to receive incoming packets sent to a specific protocol port. The application can act as a client by specifying a remote IP address or can act as a server to accept packets from an arbitrary sender.  Udp_register allocates an entry in the UDP table, records the remote and local protocol port and IP address infor-mation in the entry, and creates a queue to hold incoming packets.Udp_recv. Once a local port number has been registered, an application can calludp_recv to extract a packet from a table entry. Arguments to the call specify a slot inthe UDP table, a buffer to hold the incoming message, and a buffer length. The slotmust have been registered previously using udp_register. In terms of coordination,udp_recv uses the same paradigm as ARP. If no packet is waiting (i.e., the queue forthe entry is empty), udp_recv blocks and waits for the amount of time specified by thelast argument. When a UDP packet arrives, netin calls udp_in. The code in udp_infinds the appropriate entry in the UDP table, and if an application process is waiting, sends a message to the waiting process. Thus, if a packet arrives within the specified time, udp_recv copies the UDP data to the caller’s buffer and returns the length. If the timer expires before a packet arrives, udp_recv returns TIMEOUT.Udp_recvaddr. When it acts as a server, a process must learn the address of the client that contacted it. A server process calls udp_recvaddr, which acts like udp_recv except that the call returns both an incoming packet and the address of the sender. The server can use the address to send a reply.Udp_send. A process calls udp_send to transmit a UDP message. Argumentsspecify a slot in the UDP table, the address of a message in memory, and the length ofthe message. The slot must have been registered with udp_register. Udp_send createsan Ethernet packet that contains an IP datagram carrying the specified UDP message. Udp_send obtains the IP address and port numbers from the table entry.Udp_release. Once a process has finished using a UDP endpoint, the process can call udp_release to release the table entry. If packets are enqueued in an entry,udp_release returns each to the buffer pool before marking the table entry free.17.12 Internet Control Message ProtocolOur implementation of ICMP only handles the two message types used by the ping program: ICMP Echo Request and ICMP Echo Reply. Despite the restriction on mes-sage types, the code contains seven major functions: icmp_init, icmp_in, icmp_out,icmp_register, icmp_send, icmp_recv, and icmp_release.As with other parts of the protocol stack, the network input function initializesICMP by calling icmp_init. The network input process calls icmp_in when an ICMPpacket arrives. An application process calls icmp_register to register its use of a remoteIP address, then uses icmp_send to send a ping request and icmp_recv to receive a re-404 A Minimal Internet Protocol Stack Chap. 17ply. Finally, once it has finished, the application calls icmp_release to release the re-mote IP address and allow other processes to use it.Although it is not shown in the text,† the functions follow the same general struc-ture as the UDP functions. A trick is used to associate ping replies with requests: the identification field in an outgoing ping packet is the slot in the ping table (i.e., the index of an entry). When a reply arrives, the reply contains the same identification, which icmp_in uses as an index into the array. Thus, unlike UDP, the ICMP code never needs to search the table. Of course, the identification field alone is not sufficient: once a table entry has been identified, icmp_in verifies that the IP source address in the reply matches the IP address in the entry. Recall from the discussion earlier in the chapter that the netin process is running when icmp_in is called. Therefore, if a reply is needed, icmp_in does not send the reply directly. Instead, it calls ip_enqueue to enqueue the outgoing packet for the IP output process to send.17.13 Dynamic Host Configuration ProtocolWhen it boots, a computer must obtain its IP address, the IP address of a default router, and the address mask used on the local network. The protocol used to obtain in-formation at startup is known as the Dynamic Host Configuration Protocol (DHCP). Although a DHCP packet contains many fields, the basic packet exchange is straightfor-ward. A computer, known as a host, broadcasts a DHCP Discover message. A DHCP server on the local network replies by sending a DHCP Offer message that contains an IP address for the host, a 32-bit subnet mask for the local network, and the address of a default router. The computer replies by sending a Requestmessage to the server.Instead of engaging in a DHCP exchange when the system boots, our code waits until an IP address is needed. An application calls getlocalip to obtain the local IP ad-dress. If the IP address has been fetched previously, the code merely returns the value. If the host’s IP address is unknown, getlocalip uses DHCP to obtain the address. The code starts by creating and sending a DHCP Discover message. It then uses udp_recv to wait for a reply.File dhcp.h defines the structure of a DHCP message. The entire DHCP message will be carried in the payload of a UDP message, which is carried in an IP datagram, which is carried in an Ethernet packet.//**ddhhccpp..hh--DDeeffiinniittiioonnssrreellaatteeddttooDDHHCCPP**//##ddeeffiinneeDDHHCCPP##ddeeffiinneeDDHHCCPP__RREETTRRYY55##ddeeffiinneeDDHHCCPP__PPAADDDDIINNGG00##ddeeffiinneeDDHHCCPP__SSUUBBNNEETT__MMAASSKK11##ddeeffiinneeDDHHCCPP__RROOUUTTEERR33†The code can be obtained from the website xinu.cs.purdue.eduSec. 17.13        Dynamic Host Configuration Protocol 405##ddeeffiinneeDDHHCCPP__DDNNSS__SSEERRVVEERR66##ddeeffiinneeDDHHCCPP__DDOOMMAAIINN__NNAAMMEE1155##ddeeffiinneeDDHHCCPP__VVEENNDDEERR__OOPPTTIIOONNSS4433##ddeeffiinneeDDHHCCPP__RREEQQUUEESSTTEEDD__IIPP5500##ddeeffiinneeDDHHCCPP__IIPP__AADDDDRR__LLEEAASSEE__TTIIMMEE5511##ddeeffiinneeDDHHCCPP__OOPPTTIIOONN__OOVVEERRLLOOAADD5522##ddeeffiinneeDDHHCCPP__MMEESSSSAAGGEE__TTYYPPEE5533##ddeeffiinneeDDHHCCPP__SSEERRVVEERR__IIDD5544##ddeeffiinneeDDHHCCPP__PPAARRAAMMEETTEERR__RREEQQUUEESSTT__LLIISSTT5555##ddeeffiinneeDDHHCCPP__MMEESSSSAAGGEE5566##ddeeffiinneeDDHHCCPP__MMAAXXIIMMUUMM__DDHHCCPP__MMEESSSSAAGGEE__SSIIZZEE5577##ddeeffiinneeDDHHCCPP__RREENNEEWWAALL__TTIIMMEE__VVAALLUUEE5588##ddeeffiinneeDDHHCCPP__RREEBBIINNDDIINNGG__TTIIMMEE__VVAALLUUEE5599##ddeeffiinneeDDHHCCPP__VVEENNDDOORR__CCLLAASSSS__IIDD6600##ddeeffiinneeDDHHCCPP__CCLLIIEENNTT__IIDD6611##ddeeffiinneeDDHHCCPP__TTFFTTPP__SSEERRVVEERR__NNAAMMEE6666##ddeeffiinneeDDHHCCPP__BBOOOOTTFFIILLEE__NNAAMMEE6677##ddeeffiinneeDDHHCCPP__CCLLIIEENNTT__SSYYSS__AARRCCHH9933##ddeeffiinneeDDHHCCPP__CCLLIIEENNTT__NNEETT__IIDD9944##ddeeffiinneeDDHHCCPP__CCLLIIEENNTT__MMAACCHHIINNEE__IIDD9977##ddeeffiinneeDDHHCCPP__MMEESSSSAAGGEE__EENNDD225555##pprraaggmmaappaacckk((22))ssttrruuccttddhhccppmmssgg{{bbyytteeddcc__bboopp;;//**DDHHCCPPbboooottppoopp11==rreeqq22==rreeppllyy**//bbyytteeddcc__hhttyyppee;;//**DDHHCCPPhhaarrddwwaarreettyyppee**//bbyytteeddcc__hhlleenn;;//**DDHHCCPPhhaarrddwwaarreeaaddddrreesssslleennggtthh**//bbyytteeddcc__hhooppss;;//**DDHHCCPPhhooppccoouunntt**//uuiinntt3322ddcc__xxiidd;;//**DDHHCCPPxxiidd**//uuiinntt1166ddcc__sseeccss;;//**DDHHCCPPsseeccoonnddss**//uuiinntt1166ddcc__ffllaaggss;;//**DDHHCCPPffllaaggss**//uuiinntt3322ddcc__cciipp;;//**DDHHCCPPcclliieennttIIPPaaddddrreessss**//uuiinntt3322ddcc__yyiipp;;//**DDHHCCPPyyoouurrIIPPaaddddrreessss**//uuiinntt3322ddcc__ssiipp;;//**DDHHCCPPsseerrvveerrIIPPaaddddrreessss**//uuiinntt3322ddcc__ggiipp;;//**DDHHCCPPggaatteewwaayyIIPPaaddddrreessss**//bbyytteeddcc__cchhaaddddrr[[1166]];;//**DDHHCCPPcclliieenntthhaarrddwwaarreeaaddddrreessss**//uunniioonn{{bbyytteeddcc__bboooottpp[[119922]];;//**DDHHCCPPbboooottppaarreeaa((zzeerroo))**//ssttrruucctt{{bbyytteessnnaammee[[6644]];;//**TTFFTTPPSSeerrvveerrNNaammee**//bbyytteebboooottffiillee[[112288]];;//**TTFFTTPPFFiilleennaammee**//}};;}};;uuiinntt3322ddcc__ccooookkiiee;;//**DDHHCCPPccooookkiiee**//bbyytteeddcc__oopptt[[11002244]];;//**DDHHCCPPooppttiioonnssaarreeaa((llaarrggee**//406 A Minimal Internet Protocol Stack Chap. 17//**eennoouugghhttoohhoollddmmoorreetthhaann**////**rreeaassoonnaabblleeooppttiioonnss**//}};;##pprraaggmmaappaacckk(())If the local IP address has not been initialized, function getlocalip creates andsends a DHCP Discover message, waits to receive a reply, extracts the IP address, sub-net mask, and default router address from the reply and stores them in Netdata, and re-turns the IP address. The code can be found in file dhcp.c://**ddhhccpp..cc--ggeettllooccaalliipp**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ddhhccpp__ggeett__oopptt__vvaall--RReettrriieevveeaappooiinntteerrttootthheevvaalluueeffoorraassppeecciiffiieedd**DDHHCCPPooppttiioonnsskkeeyy**------------------------------------------------------------------------------------------------------------------------------------------------**//cchhaarr**ddhhccpp__ggeett__oopptt__vvaall((ccoonnssttssttrruuccttddhhccppmmssgg**ddmmssgg,,//**DDHHCCPPMMeessssaaggee**//uuiinntt3322ddmmssgg__ssiizzee,,//**SSiizzeeooffDDHHCCPPMMeessssaaggee**//uuiinntt88ooppttiioonn__kkeeyy//**OOppttiioonnkkeeyyttoorreettrriieevvee**//)){{uunnssiiggnneeddcchhaarr**oopptt__ttmmpp;;uunnssiiggnneeddcchhaarr**eeoomm;;eeoomm==((uunnssiiggnneeddcchhaarr**))ddmmssgg++ddmmssgg__ssiizzee--11;;oopptt__ttmmpp==((uunnssiiggnneeddcchhaarr**))ddmmssgg-->>ddcc__oopptt;;wwhhiillee((oopptt__ttmmpp<<eeoomm)){{//**IIfftthheeooppttiioonnvvaalluueemmaattcchheessrreettuurrnntthheevvaalluuee**//iiff((((**oopptt__ttmmpp))====ooppttiioonn__kkeeyy)){{//**OOffffsseettppaasstttthheeooppttiioonnvvaalluueeaannddtthheessiizzee**//rreettuurrnn((cchhaarr**))((oopptt__ttmmpp++22));;}} oopptt__ttmmpp++++;;//**MMoovveettoolleennggtthhoocctteett**//oopptt__ttmmpp++==**((uuiinntt88**))oopptt__ttmmpp++11;;}}Sec. 17.13        Dynamic Host Configuration Protocol 407//**OOppttiioonnvvaalluueennoottffoouunndd**//rreettuurrnnNNUULLLL;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ddhhccpp__bblldd__bboooottpp__mmssgg--SSeetttthheeccoommmmoonnffiieellddssffoorraallllDDHHCCPPmmeessssaaggeess**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddddhhccpp__bblldd__bboooottpp__mmssgg((ssttrruuccttddhhccppmmssgg**ddmmssgg)){{uuiinntt3322xxiidd;;//**XXiidduusseeddffoorrtthheeeexxcchhaannggee**//mmeemmccppyy((&&xxiidd,,NNeettDDaattaa..eetthhuuccaasstt,,44));;//**UUssee44bbyytteessffrroommMMAACCaass**////**uunniiqquueeXXIIDD**//mmeemmsseett((ddmmssgg,,00xx0000,,ssiizzeeooff((ssttrruuccttddhhccppmmssgg))));;ddmmssgg-->>ddcc__bboopp==00xx0011;;//**OOuuttggooiinnggrreeqquueesstt**//ddmmssgg-->>ddcc__hhttyyppee==00xx0011;;//**HHaarrddwwaarreettyyppeeiissEEtthheerrnneett**//ddmmssgg-->>ddcc__hhlleenn==00xx0066;;//**HHaarrddwwaarreeaaddddrreesssslleennggtthh**//ddmmssgg-->>ddcc__hhooppss==00xx0000;;//**HHooppccoouunntt**//ddmmssgg-->>ddcc__xxiidd==hhttoonnll((xxiidd));;//**XXiidd((uunniiqquueeIIDD))**//ddmmssgg-->>ddcc__sseeccss==00xx00000000;;//**SSeeccoonnddss**//ddmmssgg-->>ddcc__ffllaaggss==00xx00000000;;//**FFllaaggss**//ddmmssgg-->>ddcc__cciipp==00xx0000000000000000;;//**CClliieennttIIPPaaddddrreessss**//ddmmssgg-->>ddcc__yyiipp==00xx0000000000000000;;//**YYoouurrIIPPaaddddrreessss**//ddmmssgg-->>ddcc__ssiipp==00xx0000000000000000;;//**SSeerrvveerrIIPPaaddddrreessss**//ddmmssgg-->>ddcc__ggiipp==00xx0000000000000000;;//**GGaatteewwaayyIIPPaaddddrreessss**//mmeemmsseett((&&ddmmssgg-->>ddcc__cchhaaddddrr,,’’\\00’’,,1166));;//**CClliieenntthhaarrddwwaarreeaaddddrreessss**//mmeemmccppyy((&&ddmmssgg-->>ddcc__cchhaaddddrr,,NNeettDDaattaa..eetthhuuccaasstt,,EETTHH__AADDDDRR__LLEENN));;mmeemmsseett((&&ddmmssgg-->>ddcc__bboooottpp,,’’\\00’’,,119922));;//**ZZeerrootthheebboooottppaarreeaa**//ddmmssgg-->>ddcc__ccooookkiiee==hhttoonnll((00xx6633882255336633));;//**MMaaggiiccccooookkiieeffoorrDDHHCCPP**//}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ddhhccpp__bblldd__ddiisscc--hhaannddccrraaffttaaDDHHCCPPDDiissccoovveerrmmeessssaaggeeiinnddmmssgg**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322ddhhccpp__bblldd__ddiisscc((ssttrruuccttddhhccppmmssgg**ddmmssgg)){{uuiinntt3322jj==00;;ddhhccpp__bblldd__bboooottpp__mmssgg((ddmmssgg));;408 A Minimal Internet Protocol Stack Chap. 17ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&5533;;//**DDHHCCPPmmeessssaaggeettyyppeeooppttiioonn**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&11;;//**OOppttiioonnlleennggtthh**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&11;;//**DDHHCCPPDDiiccoovveerrmmeessssaaggee**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&00;;//**OOppttiioonnssppaaddddiinngg**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&5555;;//**DDHHCCPPppaarraammeetteerrrreeqquueessttlliisstt**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&22;;//**OOppttiioonnlleennggtthh**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&11;;//**RReeqquueessttssuubbnneettmmaasskk**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&33;;//**RReeqquueessttddeeffaauullttrroouutteerraaddddrr-->>**//rreettuurrnn((uuiinntt3322))((((cchhaarr**))&&ddmmssgg-->>ddcc__oopptt[[jj]]--((cchhaarr**))ddmmssgg++11));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ddhhccpp__bblldd__rreeqq--hhaannddccrraaffttaaDDHHCCPPrreeqquueessttmmeessssaaggeeiinnddmmssgg**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322ddhhccpp__bblldd__rreeqq((ssttrruuccttddhhccppmmssgg**ddmmssgg,,//**DDHHCCPPmmeessssaaggeettoobbuuiilldd**//ccoonnssttssttrruuccttddhhccppmmssgg**ddmmssgg__ooffffeerr,,//**DDHHCCPPooffffeerrmmeessssaaggee**//uuiinntt3322ddssmmgg__ooffffeerr__ssiizzee//**SSiizzeeooffDDHHCCPPooffffeerrmmeessssaaggee**//)){{uuiinntt3322jj==00;;uuiinntt3322**sseerrvveerr__iipp;;//**TTaakkeetthheeDDHHCCPPsseerrvveerrIIPPaaddddrr**////**ffrroommDDHHCCPPooffffeerrmmeessssaaggee**//ddhhccpp__bblldd__bboooottpp__mmssgg((ddmmssgg));;ddmmssgg-->>ddcc__ssiipp==ddmmssgg__ooffffeerr-->>ddcc__ssiipp;;//**SSeerrvveerrIIPPaaddddrreessss**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&5533;;//**DDHHCCPPmmeessssaaggeettyyppeeooppttiioonn**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&11;;//**OOppttiioonnlleennggtthh**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&33;;//**DDHHCCPPRReeqquueessttmmeessssaaggee**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&00;;//**OOppttiioonnssppaaddddiinngg**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&5500;;//**RReeqquueesstteeddIIPP**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&44;;//**OOppttiioonnlleennggtthh**//**((((uuiinntt3322**))&&ddmmssgg-->>ddcc__oopptt[[jj]]))==ddmmssgg__ooffffeerr-->>ddcc__yyiipp;;jj++==44;;//**RReettrriieevveetthheeDDHHCCPPsseerrvveerrIIPPffrroommtthheeDDHHCCPPooppttiioonnss**//sseerrvveerr__iipp==((uuiinntt3322**))ddhhccpp__ggeett__oopptt__vvaall((ddmmssgg__ooffffeerr,,ddssmmgg__ooffffeerr__ssiizzee,,DDHHCCPP__SSEERRVVEERR__IIDD));;iiff((sseerrvveerr__iipp====00)){{Sec. 17.13        Dynamic Host Configuration Protocol 409kkpprriinnttff((""UUnnaabblleettooggeettsseerrvveerrIIPPaadddd..ffrroommDDHHCCPPOOffffeerr\\nn""));;rreettuurrnnSSYYSSEERRRR;;}} ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&5544;;//**SSeerrvveerrIIPP**//ddmmssgg-->>ddcc__oopptt[[jj++++]]==00xxffff&&44;;//**OOppttiioonnlleennggtthh**//**((((uuiinntt3322**))&&ddmmssgg-->>ddcc__oopptt[[jj]]))==**sseerrvveerr__iipp;;jj++==44;;rreettuurrnn((uuiinntt3322))((((cchhaarr**))&&ddmmssgg-->>ddcc__oopptt[[jj]]--((cchhaarr**))ddmmssgg++11));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**ggeettllooccaalliipp--uusseeDDHHCCPPttoooobbttaaiinnaannIIPPaaddddrreessss**------------------------------------------------------------------------------------------------------------------------------------------------**//uuiinntt3322ggeettllooccaalliipp((vvooiidd)){{iinntt3322sslloott;;//**UUDDPPsslloottttoouussee**//ssttrruuccttddhhccppmmssggddmmssgg__ssnndd;;//**HHoollddssoouuttggooiinnggDDHHCCPPmmeessssaaggeess**//ssttrruuccttddhhccppmmssggddmmssgg__rrvvcc;;//**HHoollddssiinnccoommiinnggDDHHCCPPmmeessssaaggeess**//iinntt3322ii,,jj;;//**RReettrryyccoouunntteerrss**//iinntt3322lleenn;;//**LLeennggtthhooffddaattaasseenntt**//iinntt3322iinnlleenn;;//**LLeennggtthhooffddaattaarreecceeiivveedd**//cchhaarr**ooppttppttrr;;//**PPooiinntteerrttooooppttiioonnssaarreeaa**//cchhaarr**eeoopp;;//**AAddddrreessssooffeennddooffppaacckkeett**//iinntt3322mmssggttyyppee;;//**TTyyppeeooffDDCCHHPPmmeessssaaggee**//uuiinntt3322aaddddrrmmaasskk;;//**AAddddrreessssmmaasskkffoorrnneettwwoorrkk**//uuiinntt3322rroouutteerraaddddrr;;//**DDeeffaauullttrroouutteerraaddddrreessss**//uuiinntt3322ttmmpp;;//**UUsseeddffoorrbbyytteeccoonnvveerrssiioonn**//uuiinntt3322**ttmmpp__sseerrvveerr__iipp;;//**TTeemmppoorraarryyDDHHCCPPsseerrvveerrppooiinntteerr**//sslloott==uuddpp__rreeggiisstteerr((00,,UUDDPP__DDHHCCPP__SSPPOORRTT,,UUDDPP__DDHHCCPP__CCPPOORRTT));;iiff((sslloott====SSYYSSEERRRR)){{kkpprriinnttff((""ggeettllooccaalliipp::ccaannnnoottrreeggiisstteerrwwiitthhUUDDPP\\nn""));;rreettuurrnnSSYYSSEERRRR;;}} lleenn==ddhhccpp__bblldd__ddiisscc((&&ddmmssgg__ssnndd));;iiff((lleenn====SSYYSSEERRRR)){{kkpprriinnttff((""ggeettllooccaalliipp::UUnnaabblleettoobbuuiillddDDHHCCPPddiissccoovveerr\\nn""));;rreettuurrnnSSYYSSEERRRR;;}}410 A Minimal Internet Protocol Stack Chap. 17ffoorr((ii==00;;ii<<DDHHCCPP__RREETTRRYY;;ii++++)){{uuddpp__sseennddttoo((sslloott,,IIPP__BBCCAASSTT,,UUDDPP__DDHHCCPP__SSPPOORRTT,,((cchhaarr**))&&ddmmssgg__ssnndd,,lleenn));;//**RReeaadd33iinnccoommiinnggDDHHCCPPmmeessssaaggeessaannddcchheecckkffoorraannooffffeerr**////**oorrwwaaiittffoorrtthhrreeeettiimmeeoouuttppeerriiooddssiiffnnoommeessssaaggee**////**aarrrriivveess..**//ffoorr((jj==00;;jj<<33;;jj++++)){{iinnlleenn==uuddpp__rreeccvv((sslloott,,((cchhaarr**))&&ddmmssgg__rrvvcc,,ssiizzeeooff((ssttrruuccttddhhccppmmssgg)),,22000000));;iiff((iinnlleenn====TTIIMMEEOOUUTT)){{ccoonnttiinnuuee;;}}eellsseeiiff((iinnlleenn====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**CChheecckktthhaattiinnccoommiinnggmmeessssaaggeeiissaavvaalliidd**////**rreessppoonnssee((IIDDmmaattcchheessoouurrrreeqquueesstt))**//iiff((ddmmssgg__rrvvcc..ddcc__xxiidd!!==ddmmssgg__ssnndd..ddcc__xxiidd)){{ccoonnttiinnuuee;;}} eeoopp==((cchhaarr**))&&ddmmssgg__rrvvcc++iinnlleenn--11;;ooppttppttrr==((cchhaarr**))&&ddmmssgg__rrvvcc..ddcc__oopptt;;mmssggttyyppee==aaddddrrmmaasskk==rroouutteerraaddddrr==00;;wwhhiillee((ooppttppttrr<<eeoopp)){{sswwiittcchh((**ooppttppttrr)){{ccaassee5533:://**MMeessssaaggeettyyppee**//mmssggttyyppee==00xxffff&&**((ooppttppttrr++22));;bbrreeaakk;;ccaassee11:://**SSuubbnneettmmaasskk**//mmeemmccppyy((((vvooiidd**))&&ttmmpp,,ooppttppttrr++22,,44));;aaddddrrmmaasskk==nnttoohhll((ttmmpp));;bbrreeaakk;;ccaassee33:://**RRoouutteerraaddddrreessss**//mmeemmccppyy((((vvooiidd**))&&ttmmpp,,ooppttppttrr++22,,44));;rroouutteerraaddddrr==nnttoohhll((ttmmpp));;bbrreeaakk;;}} ooppttppttrr++++;;//**MMoovveettoolleennggtthhoocctteett**//Sec. 17.13        Dynamic Host Configuration Protocol 411ooppttppttrr++==((00xxffff&&**ooppttppttrr))++11;;}} iiff((mmssggttyyppee====00xx0022)){{//**OOffffeerr--sseennddrreeqquueesstt**//lleenn==ddhhccpp__bblldd__rreeqq((&&ddmmssgg__ssnndd,,&&ddmmssgg__rrvvcc,,iinnlleenn));;iiff((lleenn====SSYYSSEERRRR)){{kkpprriinnttff((""ggeettllooccaalliipp::%%ss\\nn"",,""UUnnaabblleettoobbuuiillddDDHHCCPPrreeqquueesstt""));;rreettuurrnnSSYYSSEERRRR;;}} uuddpp__sseennddttoo((sslloott,,IIPP__BBCCAASSTT,,UUDDPP__DDHHCCPP__SSPPOORRTT,,((cchhaarr**))&&ddmmssgg__ssnndd,,lleenn));;ccoonnttiinnuuee;;}}eellsseeiiff((ddmmssgg__rrvvcc..ddcc__oopptt[[22]]!!==00xx0055)){{//**IIffnnoottaannaacckksskkiippiitt**//ccoonnttiinnuuee;;}} iiff((aaddddrrmmaasskk!!==00)){{NNeettDDaattaa..iippmmaasskk==aaddddrrmmaasskk;;}} iiff((rroouutteerraaddddrr!!==00)){{NNeettDDaattaa..iipprroouutteerr==rroouutteerraaddddrr;;}} NNeettDDaattaa..iippuuccaasstt==nnttoohhll((ddmmssgg__rrvvcc..ddcc__yyiipp));;NNeettDDaattaa..iipppprreeffiixx==NNeettDDaattaa..iippuuccaasstt&&NNeettDDaattaa..iippmmaasskk;;NNeettDDaattaa..iippbbccaasstt==NNeettDDaattaa..iipppprreeffiixx||~~NNeettDDaattaa..iippmmaasskk;;NNeettDDaattaa..iippvvaalliidd==TTRRUUEE;;uuddpp__rreelleeaassee((sslloott));;//**RReettrriieevveetthheebboooottsseerrvveerrIIPP**//iiff((ddoott22iipp((((cchhaarr**))ddmmssgg__rrvvcc..ssnnaammee,,&&NNeettDDaattaa..bboooottsseerrvveerr))!!==OOKK)){{//**CCoouullddnnoottrreettrriieevveetthheebboooottsseerrvveerrffrroomm**////**tthheeBBOOOOTTPPffiieellddss,,ssoouusseetthheeDDHHCCPPsseerrvveerr**////**aaddddrreessss**//ttmmpp__sseerrvveerr__iipp==((uuiinntt3322**))ddhhccpp__ggeett__oopptt__vvaall((&&ddmmssgg__rrvvcc,,lleenn,,DDHHCCPP__SSEERRVVEERR__IIDD));;iiff((ttmmpp__sseerrvveerr__iipp====00)){{kkpprriinnttff((""CCaannnnoottrreettrriieevveebboooottsseerrvveerraaddddrr\\nn""));;rreettuurrnn((uuiinntt3322))SSYYSSEERRRR;;412 A Minimal Internet Protocol Stack Chap. 17}}NNeettDDaattaa..bboooottsseerrvveerr==nnttoohhll((**ttmmpp__sseerrvveerr__iipp));;}} mmeemmccppyy((NNeettDDaattaa..bboooottffiillee,,ddmmssgg__rrvvcc..bboooottffiillee,,ssiizzeeooff((ddmmssgg__rrvvcc..bboooottffiillee))));;rreettuurrnnNNeettDDaattaa..iippuuccaasstt;;}}}} kkpprriinnttff((""DDHHCCPPffaaiilleeddttooggeettrreessppoonnssee\\nn""));;uuddpp__rreelleeaassee((sslloott));;rreettuurrnn((uuiinntt3322))SSYYSSEERRRR;;}}A DHCP server responds to the initial Discover message by sending the requested information, and the client responds with a Request. When it receives a reply, getlo-calip examines the options area of the message. DHCP is unusual because the options carry important information. In particular, the type of the DHCP message is stored in the options area as well as information that a computer system uses to initialize network parameters. Three options are crucial to our implementation: option 53 defines the type of a DHCP message, option 1 specifies a subnet mask used on the local network, and option 3 specifies the address of a default router. If the options are present, getlocalip can extract the needed information from the reply, store the information for successive calls, and return the IP address to the caller.Further details of DHCP are beyond the scope of this text. However, it is suffi-cient to understand that the DHCP code uses the UDP interface exactly the same waythat other applications use it. That is, before communication can begin, getlocalip must call udp_register to register the port that DHCP will use. Once the port has been re-gistered, getlocalip can create a DHCP Discovermessage and call udp_sendto to broad-cast the message. The DHCP Discover message causes a DHCP server to respond, and the code can use udp_recv to obtain the response, which contains the computer’s IP ad-dress.17.14 PerspectiveThe implementation of Internet protocols described in this chapter is indeed minimalistic. Many details have been omitted, and the code takes many shortcuts. For example, the structures used to define message formats combine multiple layers of the protocol stack and assume that the underlying network is always an Ethernet. More im-portant, the code presented here omits TCP, the major transport protocol used in the In-ternet. The code also omits IP version 6, the new version of the Internet Protocol that is much more complex than version 4. Unlike IPv4, for example, IPv6 uses variable-size headers, which makes it impossible to use a struct to specify IPv6 datagrams. There-Sec. 17.14        Perspective413fore, you should not view the code as typical of a protocol implementation, nor should you assume that the same structure will suffice for a more extensive protocol stack.Despite its limitations, the code does illustrate the importance of timed operations.In particular, the availability of a timed receive function simplifies the overall structureof the code and makes the operation much easier to understand. If the system did not provide a timed receive, multiple processes would be needed — one process would im-plement a timer function and another would handle responses.17.15 SummaryEven small embedded systems use Internet protocols to communicate. As a conse-quence, most operating systems include software known as a protocol stack.The chapter examines a minimal protocol stack that supports limited versions of IP, UDP, ICMP, ARP, and DHCP running over an Ethernet. The above protocols are closely interrelated. Both ICMP and UDP messages travel in an IP datagram; a DHCP message travels in a UDP packet.To accommodate asynchronous packet arrivals, our protocol implementation uses a network input process, netin. The netin process repeatedly reads an Ethernet packet, validates header fields, and uses header information to determine how to process the packet. When an ARP packet arrives, netin calls arp_in to handle the packet, when a UDP packet arrives, netin calls udp_in, and when an ICMP packet arrives, netin calls icmp_in. For all other packets, netin ignores the packet. When receiving packets, our implementation allows a process to specify the maximum time to wait for a packet to arrive. The timeout mechanism can be used to implement retransmission: if a response does not arrive before the timeout occurs, a process can retransmit the request.EXERCISES17.1  Can you rewrite the code to eliminate the need for a separate IP output process? Hint:keep a queue of outgoing IP packets with each ARP table entry and arrange for thepackets to be sent once an ARP reply arrives.17.2  Assume you have access to a pair of Xinu systems that connect to the Internet. Use theUDP functions to write two programs that communicate by sending UDP messages toeach other.17.3 To ensure that ARP information does not become stale, the ARP protocol requires an en-try to be removed from the cache after a fixed time (even if the entry has been used). Rewrite the code to remove entries that are more than 5 minutes old without using an extra process.17.4  Redesign udp_recv to use timer processes instead of recvtime. How many processes areneeded? Explain.414 A Minimal Internet Protocol Stack Chap. 1717.5 Instead of structuring network code around a netin process and an ipout process, someoperating systems use software interrupts. Redesign the networking code in this chapterto use software interrupts.17.6 If a computer connects to two separate networks (e.g., a Wi-Fi network as well as anEthernet), what major change is required in the structure of the network code? Hint:how many processes are needed?17.7  Xinu uses a device paradigm for abstract devices as well as hardware devices. Rewritethe UDP code to use a device paradigm in which a process calls open on a UDP master device to specify protocol port and IP address information, and receives the descriptor of a pseudo-device that can be used for communication.17.8  Can the device paradigm described in the previous exercise handle all of ICMP? Doesthe answer change if the question is restricted to ICMP echo (i.e., ping)? Explain.17.9 Wireless routers used in residences and dorm rooms pass Internet packets between anEthernet connection and a Wi-Fi connection. Can you use the code in this chapter tobuild a wireless router? Why or why not?Chapter Contents18.1 Introduction, 41718.2 The Disk Abstraction, 41718.3 Operations A Disk Driver Supports, 41818.4 Block Transfer And High–level I/O Functions, 41818.5 A Remote Disk Paradigm, 41918.6 The Important Concept Of Caching, 42018.7 Semantics Of Disk Operations, 42118.8 Definition Of Driver Data Structures, 42118.9 Driver Initialization (rdsinit), 42718.10 The Upper–half Open Function (rdsopen), 43018.11 The Remote Communication Function (rdscomm), 432 18.12 The Upper–half Write Function (rdswrite), 43518.13 The Upper–half Read Function (rdsread), 438 18.14 Flushing Pending Requests, 44218.15 The Upper–half Control Function (rdscontrol), 442 18.16 Allocating A Disk Buffer (rdsbufalloc), 44518.17 The Upper–half Close Function (rdsclose), 44718.18 The Lower–half Communication Process (rdsprocess), 448 18.19 Perspective, 45318.20 Summary, 45418A Remote Disk Driver
For my purpose holds  ... To strive, to seek, to find,and not to yield.— Alfred, Lord Tennyson18.1 IntroductionEarlier chapters explain I/O devices and the structure of a device driver. Chapter 16 describes how block-oriented devices use DMA, and shows an example Ethernet driver.This chapter considers the design of a device driver for secondary storage devices known as disks or hard drives. The chapter focuses on basic data transfer operations.The next chapter describes how higher levels of the system use disk hardware to pro-vide files and directories.18.2 The Disk AbstractionDisk hardware provides a basic abstraction in which a disk is a storage mechanismthat has the following properties: Nonvolatile: stored data persists even if power is removed. Block-oriented: the hardware can only fetch or store fixed-size blocks. Multi-use: a given block can be read and written many times.Random-access: blocks can be read or written in any order.417418 A Remote Disk Driver Chap. 18Like the Ethernet hardware described in Chapter 16, disk hardware typically uses Direct-Memory-Access (DMA) to allow the disk to transfer an entire block before inter-rupting the processor. Also like the Ethernet driver, a disk driver does not understand or examine the contents of data blocks. Instead, the driver merely treats the entire storage device as an array of data blocks.18.3 Operations A Disk Driver SupportsAt the device driver level, a disk consists of fixed-size data blocks that can be ac-cessed randomly using three basic operations:Fetch: Copy the contents of a specified block from the disk to abuffer in memory.Store: Copy the contents of a memory buffer to a specified blockon the disk.Seek: Move to a specified block on the disk. The seek option isonly used on electro-mechanical devices (i.e., a magnetic disk) be-cause it provides an optimization that positions the disk head where it will be needed in the future. Thus, when solid state disk technol-ogy is used, seek is unimportant.The block size of a disk is derived from the size of a sector on magnetic disks. The industry has settled on a de facto standard block size of 512 bytes; throughout the chapter, we will assume 512-byte blocks.†18.4 Block Transfer And High–level I/O FunctionsBecause the hardware only provides block transfer, it makes sense to design an in-terface in which read and write operations transfer an entire block. The question be-comes how to include a block specification in the existing high-level I/O operations.We might require a programmer to call seek to move to a specific block before calling read or write to access data in the block. Unfortunately, requiring a user to call seek before each data transfer is clumsy and error prone. Therefore, to keep the interface simple, we will stretch the usual meaning of arguments to read and write: instead of in-terpreting the third argument as a buffer size, we will assume the buffer is large enough to hold a disk block, and use the third argument to specify a block number. For exam-ple, the call:read ( DISK0, buff, 5 )requests the driver to read block five from the disk into memory starting at locationbuff.†Although modern disks often use a larger underlying block size (e.g., 4K bytes), the hardware presentsan interface that uses 512-byte blocks.Sec. 18.4        Block Transfer And High–level I/O Functions 419Our driver will supply two basic operations: read, which copies a single block from the disk into memory, and write, which copies data from memory onto a specified disk block. In addition, our driver will supply control functions that can be used to erase a disk (i.e., destroy all saved data) and to synchronize write requests (i.e., ensure that all cached data is written to the disk). The concept of caching and its importance for efficient disk access is discussed later in the chapter.18.5 A Remote Disk ParadigmUnlike a traditional computer that has a local disk, cloud computing follows a broader notion in which disk storage is separated from processors. Separation allows a physical disk to be accessed from multiple processors, and supports virtual machine mi-gration. Many modern embedded systems follow the cloud approach. To see how disk storage can be separated from processing, we will examine a remote disk paradigm. Our remote disk system will provide the same abstraction as a local disk by allowing processes to read and write disk blocks. Instead of using disk hardware, however, our system will send requests over a network to a remote disk server that runs on another computer.The driver software for the remote disk is surprisingly similar to driver software for a local disk. Overall, both local and remote disk drivers follow the same general or-ganization. That is, the driver functions are partitioned into an upper half and a lower half that communicate through a shared data structure. The main difference arises in the way the lower half operates. Instead of using DMA hardware and interrupts in the lower half, our remote disk driver uses a high-priority communication process. The communication process sends requests over a network to a remote server, and receives responses from the server. Figure 18.1 illustrates the organization.upper-half functionsshareddata structureswriteread
network communication with remote serverprocess that provides lower-half functionalityFigure 18.1  Organization of a remote disk driver.420 A Remote Disk Driver Chap. 1818.6 The Important Concept Of CachingThree key facts help operating system designers optimize disk drivers. First, the underlying disk hardware can only transfer complete blocks. Second, as we will see in the next chapter, a file system allows an application to read and write arbitrary amounts of data. Third, disk hardware is much slower than processor hardware. The conse-quence of the above three facts should be clear: if a driver attempts to transfer data each time an application reads or writes a few bytes, disk access will become a bottleneck in the system.To make disk accesses efficient, a driver must use caching. That is, when a block is accessed, the driver places a copy of the block in a cache in memory. Subsequent read and write operations manipulate the cached copy without waiting for I/O opera-tions to access the underlying disk. Eventually, of course, changes must be written back to the disk. Without caching, disk access is intolerably slow, but caching can make the effective performance of a disk system fast enough to accommodate most needs. We can summarize:Because disk access is slow and file system functions often read orwrite partial blocks, a disk driver must cache copies of blocks to achieve high performance.Our example driver illustrates the idea. The shared data structure contains two keyitems.A cache of recently accessed blocksA list of pending requestsA cache of recently accessed blocks. Our cache stores recently accessed diskblocks. A block is cached whenever a read or write operation occurs. Furthermore,when it receives a subsequent operation for a block, the driver always searches thecache before requesting a transfer; the driver does not distinguish between read and write requests. Thus, if a file system first writes data to a given block and then reads data from the same block, the read operation will use the cached copy.A list of pending requests. Like a traditional driver, our remote disk system allows multiple processes to access a disk, and implements synchronous read operations and asynchronous write operations. That is, when it reads a block, a process must wait until the data has been fetched. When it writes a block, however, a process does not block — the driver places a copy of the outgoing disk block on a request list, and allows the process to continue execution. The lower-half process, which handles communication with the remote server, continually takes the next item off the request queue and per-forms the specified operation. Thus, at some time in the future, data will be written to the disk.Sec. 18.7        Semantics Of Disk Operations 42118.7 Semantics Of Disk OperationsAlthough it can employ optimizations such as caching and delayed write opera-tions, a disk driver must always preserve the appearance of a synchronous interface.That is, the driver must always return the data that was written most recently.If we envision the read and write operations on a given block, they form a se-quence:op1, op2, op3, ... opnIf opt is a read operation for block i, the driver must deliver the data that was written tothe block in opk, where k is the highest index of a write operation less than t (i.e., all the operations between opk  and opt  are read operations). To complete the definition, we as-sume an implicit write occurs at time zero before the system starts. Thus, if a system attempts to read a block before any calls to write the block, the driver returns whatever data was on the disk when the system booted.We use the term last-write semantics to capture the concept, and insist that:A disk driver can use techniques such as caching to optimize perfor-mance provided the driver guarantees last-write semantics.The example driver uses a FIFO queue to enforce last-write semantics:Items are inserted at the tail of the request queue; the lower-half process continually selects and performs the item at the head of the queue.Because items are always inserted at the tail, the driver handles requests in thesame order they were made. Thus, if process A reads block five and process B writesblock five later, the two requests will appear in the correct order in the queue. The read request will be serviced first, followed by the write request. We will see that the queue discipline is extended to the cache: driver functions always start at the head when searching the cache. Our code relies on the queue discipline to ensure that a process re-ceives data according to last-write semantics.18.8 Definition Of Driver Data StructuresFile rdisksys.h defines the constants and data structures used by the remote disk system. The file defines the format of a disk buffer. Each buffer includes a header that specifies the number of the disk block stored in the buffer and fields that are used to link the buffer onto the request list, cache, or free list. In addition, the file defines the contents of the device control block and the format of messages sent to the remote server.422 A Remote Disk Driver Chap. 18//**rrddiisskkssyyss..hh--ddeeffiinniittiioonnssffoorrrreemmootteeddiisskkssyysstteemmppsseeuuddoo--ddeevviicceess**//##iiffnnddeeffNNrrddss##ddeeffiinneeNNrrddss11##eennddiiff//**RReemmootteeddiisskkbblloocckkssiizzee**//##ddeeffiinneeRRDD__BBLLKKSSIIZZ551122//**GGlloobbaallddaattaaffoorrtthheerreemmootteeddiisskksseerrvveerr**//##iiffnnddeeffRRDD__SSEERRVVEERR__IIPP##ddeeffiinneeRRDD__SSEERRVVEERR__IIPP""225555..225555..225555..225555""##eennddiiff##iiffnnddeeffRRDD__SSEERRVVEERR__PPOORRTT##ddeeffiinneeRRDD__SSEERRVVEERR__PPOORRTT3333112244##eennddiiff##iiffnnddeeffRRDD__LLOOCC__PPOORRTT##ddeeffiinneeRRDD__LLOOCC__PPOORRTT3333112244//**BBaasseeppoorrttnnuummbbeerr--mmiinnoorrddeevv**////**nnuummbbeerriissaaddddeeddttooiinnssuurree**////**tthhaatteeaacchhddeevviicceeiissuunniiqquuee**//##eennddiiff//**CCoonnttrroollbblloocckkffoorrrreemmootteeddiisskkddeevviiccee**//##ddeeffiinneeRRDD__IIDDLLEENN6644//**SSiizzeeooffaarreemmootteeddiisskkIIDD**//##ddeeffiinneeRRDD__BBUUFFFFSS6644//**NNuummbbeerrooffddiisskkbbuuffffeerrss**//##ddeeffiinneeRRDD__SSTTAACCKK1166338844//**SSttaacckkssiizzeeffoorrccoommmm..pprroocceessss**//##ddeeffiinneeRRDD__PPRRIIOO220000//**PPrriioorrttyyooffccoommmm..pprroocceessss**////**CCoonnssttaannttssffoorrssttaatteeoofftthheeddeevviiccee**//##ddeeffiinneeRRDD__FFRREEEE00//**DDeevviicceeiissaavvaaiillaabbllee**//##ddeeffiinneeRRDD__OOPPEENN11//**DDeevviicceeiissooppeenn((iinnuussee))**//##ddeeffiinneeRRDD__PPEENNDD22//**OOppeenniissppeennddiinngg**////**OOppeerraattiioonnssffoorrrreeqquueessttqquueeuuee**//##ddeeffiinneeRRDD__OOPP__RREEAADD11//**RReeaaddooppeerraattiioonnoonnrreeqq..lliisstt**//##ddeeffiinneeRRDD__OOPP__WWRRIITTEE22//**WWrriitteeooppeerraattiioonnoonnrreeqq..lliisstt**//##ddeeffiinneeRRDD__OOPP__SSYYNNCC33//**SSyynnccooppeerraattiioonnoonnrreeqq..lliisstt**////**SSttaattuussvvaalluueessffoorraabbuuffffeerr**//Sec. 18.8        Definition Of Driver Data Structures 423##ddeeffiinneeRRDD__VVAALLIIDD00//**BBuuffffeerrccoonnttaaiinnssvvaalliiddddaattaa**//##ddeeffiinneeRRDD__IINNVVAALLIIDD11//**BBuuffffeerrddooeessnnoottccoonnttaaiinnddaattaa**////**DDeeffiinniittiioonnooffaabbuuffffeerrwwiitthhaahheeaaddeerrtthhaattaalllloowwsstthheessaammeennooddeettoobbee**////**uusseeddaassaarreeqquueessttoonntthheerreeqquueessttqquueeuuee,,aanniitteemmiinntthheeccaacchhee,,oorraa**////**nnooddeeoonntthheeffrreeeelliissttooffbbuuffffeerrss**//ssttrruuccttrrddbbuuffff{{//**RReeqquueessttlliissttnnooddee**//ssttrruuccttrrddbbuuffff**rrdd__nneexxtt;;//**PPttrrttoonneexxttnnooddeeoonnaalliisstt**//ssttrruuccttrrddbbuuffff**rrdd__pprreevv;;//**PPttrrttoopprreevvnnooddeeoonnaalliisstt**//iinntt3322rrdd__oopp;;//**OOppeerraattiioonn--rreeaadd//wwrriittee//ssyynncc**//iinntt3322rrdd__rreeffccnntt;;//**RReeffeerreenncceeccoouunnttooffpprroocceesssseess**////**rreeaaddiinnggtthheebblloocckk**//uuiinntt3322rrdd__bbllkknnuumm;;//**BBlloocckknnuummbbeerroofftthhiissbblloocckk**//iinntt3322rrdd__ssttaattuuss;;//**IIssbbuuffffeerrccuurrrreennttllyyvvaalliidd??**//ppiidd3322rrdd__ppiidd;;//**PPrroocceesssstthhaattiinniittiiaatteeddaa**////**rreeaaddrreeqquueessttffoorrtthheebblloocckk**//cchhaarrrrdd__bblloocckk[[RRDD__BBLLKKSSIIZZ]];;//**SSppaacceettoohhoollddoonneeddiisskkbblloocckk**//}};;ssttrruuccttrrddssccbbllkk{{iinntt3322rrdd__ssttaattee;;//**SSttaatteeooffddeevviiccee**//cchhaarrrrdd__iidd[[RRDD__IIDDLLEENN]];;//**DDiisskkIIDDccuurrrreennttllyybbeeiinngguusseedd**//iinntt3322rrdd__sseeqq;;//**NNeexxttsseeqquueenncceennuummbbeerrttoouussee**////**RReeqquueessttqquueeuueehheeaaddaannddttaaiill**//ssttrruuccttrrddbbuuffff**rrdd__rrhhnneexxtt;;//**HHeeaaddooffrreeqquueessttqquueeuuee::nneexxtt**//ssttrruuccttrrddbbuuffff**rrdd__rrhhpprreevv;;//**aannddpprreevviioouuss**//ssttrruuccttrrddbbuuffff**rrdd__rrttnneexxtt;;//**TTaaiillooffrreeqquueessttqquueeuuee::nneexxtt**//ssttrruuccttrrddbbuuffff**rrdd__rrttpprreevv;;//**((nnuullll))aannddpprreevviioouuss**////**CCaacchheehheeaaddaannddttaaiill**//ssttrruuccttrrddbbuuffff**rrdd__cchhnneexxtt;;//**HHeeaaddooffccaacchhee::nneexxttaanndd**//ssttrruuccttrrddbbuuffff**rrdd__cchhpprreevv;;//**pprreevviioouuss**//ssttrruuccttrrddbbuuffff**rrdd__ccttnneexxtt;;//**TTaaiillooffccaacchhee::nneexxtt((nnuullll))**//ssttrruuccttrrddbbuuffff**rrdd__ccttpprreevv;;//**aannddpprreevviioouuss**////**FFrreeeelliisstthheeaadd((ssiinnggllyy--lliinnkkeedd))**//ssttrruuccttrrddbbuuffff**rrdd__ffrreeee;;//**PPooiinntteerrttooffrreeeelliisstt**//ppiidd3322rrdd__ccoommpprroocc;;//**PPrroocceessssIIDDooffccoommmm..pprroocceessss**//bbooooll88rrdd__ccoommrruunnss;;//**HHaassccoommmm..pprroocceessssssttaarrtteedd??**//ssiidd3322rrdd__aavvaaiillsseemm;;//**SSeemmaapphhoorreeIIDDffoorraavvaaiillbbuuffffss**//ssiidd3322rrdd__rreeqqsseemm;;//**SSeemmaapphhoorreeIIDDffoorrrreeqquueessttss**//424 A Remote Disk Driver Chap. 18uuiinntt3322rrdd__sseerr__iipp;;//**SSeerrvveerrIIPPaaddddrreessss**//uuiinntt1166rrdd__sseerr__ppoorrtt;;//**SSeerrvveerrUUDDPPppoorrtt**//uuiinntt1166rrdd__lloocc__ppoorrtt;;//**LLooccaall((cclliieenntt))UUPPDDppoorrtt**//bbooooll88rrdd__rreeggiisstteerreedd;;//**HHaassUUDDPPppoorrttbbeeeennrreeggiisstteerreedd??**//iinntt3322rrdd__uuddppsslloott;;//**RReeggiisstteerreeddUUDDPPsslloott**//}};;eexxtteerrnnssttrruuccttrrddssccbbllkkrrddssttaabb[[]];;//**RReemmootteeddiisskkccoonnttrroollbblloocckk**////**DDeeffiinniittiioonnssooffppaarraammeetteerrssuusseedddduurriinnggsseerrvveerraacccceessss**//##ddeeffiinneeRRDD__RREETTRRIIEESS33//**TTiimmeessttoorreettrryysseennddiinnggaammssgg**//##ddeeffiinneeRRDD__TTIIMMEEOOUUTT22000000//**TTiimmeeoouuttffoorrrreeppllyy((22sseeccoonnddss))**////**CCoonnttrroollffuunnccttiioonnssffoorraarreemmootteeffiilleeppsseeuuddooddeevviiccee**//##ddeeffiinneeRRDDSS__CCTTLL__DDEELL11//**DDeelleettee((eerraassee))aanneennttiirreeddiisskk**//##ddeeffiinneeRRDDSS__CCTTLL__SSYYNNCC22//**WWrriitteeaallllppeennddiinnggbblloocckkss**////************************************************************************************************************************************************////**DDeeffiinniittiioonnooffmmeessssaaggeesseexxcchhaannggeeddwwiitthhtthheerreemmootteeddiisskksseerrvveerr**////************************************************************************************************************************************************////**VVaalluueessffoorrtthheettyyppeeffiieellddiinnmmeessssaaggeess**//##ddeeffiinneeRRDD__MMSSGG__RREESSPPOONNSSEE00xx00110000//**BBiitttthhaattiinnddiiccaatteessrreessppoonnssee**//##ddeeffiinneeRRDD__MMSSGG__RRRREEQQ00xx00001100//**RReeaaddrreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRDD__MMSSGG__RRRREESS((RRDD__MMSSGG__RRRREEQQ||RRDD__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRDD__MMSSGG__WWRREEQQ00xx00002200//**WWrriitteerreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRDD__MMSSGG__WWRREESS((RRDD__MMSSGG__WWRREEQQ||RRDD__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRDD__MMSSGG__OORREEQQ00xx00003300//**OOppeennrreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRDD__MMSSGG__OORREESS((RRDD__MMSSGG__OORREEQQ||RRDD__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRDD__MMSSGG__CCRREEQQ00xx00004400//**CClloosseerreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRDD__MMSSGG__CCRREESS((RRDD__MMSSGG__CCRREEQQ||RRDD__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRDD__MMSSGG__DDRREEQQ00xx00005500//**DDeelleetteerreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRDD__MMSSGG__DDRREESS((RRDD__MMSSGG__DDRREEQQ||RRDD__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRDD__MMIINN__RREEQQRRDD__MMSSGG__RRRREEQQ//**MMiinniimmuummrreeqquueessttttyyppee**//##ddeeffiinneeRRDD__MMAAXX__RREEQQRRDD__MMSSGG__DDRREEQQ//**MMaaxxiimmuummrreeqquueessttttyyppee**//Sec. 18.8        Definition Of Driver Data Structures 425//**MMeessssaaggeehheeaaddeerrffiieellddsspprreesseennttiinneeaacchhmmeessssaaggee**//##ddeeffiinneeRRDD__MMSSGG__HHDDRR//**CCoommmmoonnmmeessssaaggeeffiieellddss**//\\uuiinntt1166rrdd__ttyyppee;;//**MMeessssaaggeettyyppee**//\\uuiinntt1166rrdd__ssttaattuuss;;//**00iinnrreeqq,,ssttaattuussiinnrreessppoonnssee**//\\uuiinntt3322rrdd__sseeqq;;//**MMeessssaaggeesseeqquueenncceennuummbbeerr**//\\cchhaarrrrdd__iidd[[RRDD__IIDDLLEENN]];;//**NNuullll--tteerrmmiinnaatteeddddiisskkIIDD**////************************************************************************************************************************************************////**HHeeaaddeerr**////************************************************************************************************************************************************////**TThheessttaannddaarrddhheeaaddeerrpprreesseennttiinnaallllmmeessssaaggeesswwiitthhnnooeexxttrraaffiieellddss**//##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__hhddrr{{//**HHeeaaddeerrffiieellddsspprreesseennttiinneeaacchh**//RRDD__MMSSGG__HHDDRR//**rreemmootteeffiilleessyysstteemmmmeessssaaggee**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////**RReeaadd**////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__rrrreeqq{{//**RReemmootteeffiilleerreeaaddrreeqquueesstt**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrdd__bbllkk;;//**BBlloocckknnuummbbeerrttoorreeaadd**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__rrrreess{{//**RReemmootteeffiilleerreeaaddrreeppllyy**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrdd__bbllkk;;//**BBlloocckknnuummbbeerrtthhaattwwaassrreeaadd**//cchhaarrrrdd__ddaattaa[[RRDD__BBLLKKSSIIZZ]];;//**AArrrraayyccoonnttaaiinniinnggoonneebblloocckk**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////**WWrriittee**////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__wwrreeqq{{//**RReemmootteeffiilleewwrriitteerreeqquueesstt**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrdd__bbllkk;;//**BBlloocckknnuummbbeerrttoowwrriittee**//cchhaarrrrdd__ddaattaa[[RRDD__BBLLKKSSIIZZ]];;//**AArrrraayyccoonnttaaiinniinnggoonneebblloocckk**//}};;##pprraaggmmaappaacckk(())426 A Remote Disk Driver Chap. 18##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__wwrreess{{//**RReemmootteeffiilleewwrriitteerreessppoonnssee**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrdd__bbllkk;;//**BBlloocckknnuummbbeerrtthhaattwwaasswwrriitttteenn**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////**OOppeenn**////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__oorreeqq{{//**RReemmootteeffiilleeooppeennrreeqquueesstt**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__oorreess{{//**RReemmootteeffiilleeooppeennrreessppoonnssee**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////**CClloossee**////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__ccrreeqq{{//**RReemmootteeffiilleecclloosseerreeqquueesstt**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__ccrreess{{//**RReemmootteeffiilleecclloosseerreessppoonnssee**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////**DDeelleettee**////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__ddrreeqq{{//**RReemmootteeffiilleeddeelleetteerreeqquueesstt**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())Sec. 18.8        Definition Of Driver Data Structures 427##pprraaggmmaappaacckk((22))ssttrruuccttrrdd__mmssgg__ddrreess{{//**RReemmootteeffiilleeddeelleetteerreessppoonnssee**//RRDD__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())18.9 Driver Initialization (rdsinit)Although initialization is completed after the other pieces of the driver have been designed, we have chosen to examine the initialization function now because it will help us understand the shared data structures. File rdsinit.c contains the driver initialization code://**rrddssiinniitt..cc--rrddssiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttrrddssccbbllkkrrddssttaabb[[NNrrddss]];;//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddssiinniitt--IInniittiiaalliizzeetthheerreemmootteeddiisskkssyysstteemmddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrddssiinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttrrddssccbbllkk**rrddppttrr;;//**PPttrrttooddeevviicceeccoonnttoollbblloocckk**//ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPttrrttoobbuuffffeerriinnmmeemmoorryy**////**uusseeddttooffoorrmmlliinnkkeeddlliisstt**//ssttrruuccttrrddbbuuffff**ppppttrr;;//**PPttrrttoopprreevviioouussbbuuffffoonnlliisstt**//ssttrruuccttrrddbbuuffff**bbuuffffeenndd;;//**LLaassttaaddddrreessssiinnbbuuffffeerrmmeemmoorryy**//uuiinntt3322ssiizzee;;//**TToottaallssiizzeeooffmmeemmoorryynneeeeddeedd**////**bbuuffffeerrss**////**OObbttaaiinnaaddddrreessssooffccoonnttrroollbblloocckk**//rrddppttrr==&&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**SSeettccoonnttrroollbblloocckkttoouunnuusseedd**//rrddppttrr-->>rrdd__ssttaattee==RRDD__FFRREEEE;;rrddppttrr-->>rrdd__iidd[[00]]==NNUULLLLCCHH;;428 A Remote Disk Driver Chap. 18//**SSeettiinniittiiaallmmeessssaaggeesseeqquueenncceennuummbbeerr**//rrddppttrr-->>rrdd__sseeqq==11;;//**IInniittiiaalliizzeerreeqquueessttqquueeuueeaannddccaacchheettooeemmppttyy**//rrddppttrr-->>rrdd__rrhhnneexxtt==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__rrttnneexxtt;;rrddppttrr-->>rrdd__rrhhpprreevv==((ssttrruuccttrrddbbuuffff**))NNUULLLL;;rrddppttrr-->>rrdd__rrttnneexxtt==((ssttrruuccttrrddbbuuffff**))NNUULLLL;;rrddppttrr-->>rrdd__rrttpprreevv==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__rrhhnneexxtt;;rrddppttrr-->>rrdd__cchhnneexxtt==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__ccttnneexxtt;;rrddppttrr-->>rrdd__cchhpprreevv==((ssttrruuccttrrddbbuuffff**))NNUULLLL;;rrddppttrr-->>rrdd__ccttnneexxtt==((ssttrruuccttrrddbbuuffff**))NNUULLLL;;rrddppttrr-->>rrdd__ccttpprreevv==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__cchhnneexxtt;;//**AAllllooccaatteemmeemmoorryyffoorraasseettooffbbuuffffeerrss((aaccttuuaallllyyrreeqquueesstt**////**bblloocckkssaannddlliinnkktthheemmttooffoorrmmtthheeiinniittiiaallffrreeeelliisstt**//ssiizzee==ssiizzeeooff((ssttrruuccttrrddbbuuffff))**RRDD__BBUUFFFFSS;;bbppttrr==((ssttrruuccttrrddbbuuffff**))ggeettmmeemm((ssiizzee));;rrddppttrr-->>rrdd__ffrreeee==bbppttrr;;iiff((((iinntt3322))bbppttrr====SSYYSSEERRRR)){{ppaanniicc((""CCaannnnoottaallllooccaatteemmeemmoorryyffoorrrreemmootteeddiisskkbbuuffffeerrss""));;}} bbuuffffeenndd==((ssttrruuccttrrddbbuuffff**))((((cchhaarr**))bbppttrr++ssiizzee));;wwhhiillee((bbppttrr<<bbuuffffeenndd)){{//**wwaallkktthhrroouugghhmmeemmoorryy**//ppppttrr==bbppttrr;;bbppttrr==((ssttrruuccttrrddbbuuffff**))((ssiizzeeooff((ssttrruuccttrrddbbuuffff))++((cchhaarr**))bbppttrr));;ppppttrr-->>rrdd__ssttaattuuss==RRDD__IINNVVAALLIIDD;;//**BBuuffffeerriisseemmppttyy**//ppppttrr-->>rrdd__nneexxtt==bbppttrr;;//**PPooiinnttttoonneexxttbbuuffffeerr**//}} ppppttrr-->>rrdd__nneexxtt==((ssttrruuccttrrddbbuuffff**))NNUULLLL;;//**LLaassttbbuuffffeerroonnlliisstt**////**CCrreeaatteetthheerreeqquueessttlliissttaannddaavvaaiillaabblleebbuuffffeerrsseemmaapphhoorreess**//rrddppttrr-->>rrdd__aavvaaiillsseemm==sseemmccrreeaattee((RRDD__BBUUFFFFSS));;rrddppttrr-->>rrdd__rreeqqsseemm==sseemmccrreeaattee((00));;Sec. 18.9        Driver Initialization (rdsinit) 429//**SSeetttthheesseerrvveerrIIPPaaddddrreessss,,sseerrvveerrppoorrtt,,aannddllooccaallppoorrtt**//iiff((ddoott22iipp((RRDD__SSEERRVVEERR__IIPP,,&&rrddppttrr-->>rrdd__sseerr__iipp))====SSYYSSEERRRR)){{ppaanniicc((""iinnvvaalliiddIIPPaaddddrreessssffoorrrreemmootteeddiisskksseerrvveerr""));;}} //**SSeetttthheeppoorrttnnuummbbeerrss**//rrddppttrr-->>rrdd__sseerr__ppoorrtt==RRDD__SSEERRVVEERR__PPOORRTT;;rrddppttrr-->>rrdd__lloocc__ppoorrtt==RRDD__LLOOCC__PPOORRTT++ddeevvppttrr-->>ddvvmmiinnoorr;;//**SSppeecciiffyytthhaatttthheesseerrvveerrppoorrttiissnnoottyyeettrreeggiisstteerreedd**//rrddppttrr-->>rrdd__rreeggiisstteerreedd==FFAALLSSEE;;//**CCrreeaatteeaaccoommmmuunniiccaattiioonnpprroocceessss**//rrddppttrr-->>rrdd__ccoommpprroocc==ccrreeaattee((rrddsspprroocceessss,,RRDD__SSTTAACCKK,,RRDD__PPRRIIOO,,""rrddsspprroocc"",,11,,rrddppttrr));;iiff((rrddppttrr-->>rrdd__ccoommpprroocc====SSYYSSEERRRR)){{ppaanniicc((""CCaannnnoottccrreeaatteerreemmootteeddiisskkpprroocceessss""));;}} rreessuummee((rrddppttrr-->>rrdd__ccoommpprroocc));;rreettuurrnnOOKK;;}}In addition to initializing data structures, rdsinit performs three important tasks. It allocates a set of disk buffers and links them onto the free list, it creates two sema-phores that control processing, and it creates the high-priority process that communi-cates with the server.One of the semaphores, rd_reqsem, guards the request list. The semaphore starts with count zero, and is signaled each time a new request is added to the request queue. The communication process waits on rd_reqsem before extracting an item from the list, which means the process will block if the list is empty. Because the semaphore starts with an initial count of zero, the communication process will block on the semaphore until a request has been deposited in the queue.The other semaphore, rd_availsem, counts the number of buffers that are availablefor use (i.e., free or in the cache). Initially, RD_BUFFS buffers are on the free list andrd_availsem has a count equal to RD_BUFFS. When a buffer is needed, a caller waitson the semaphore. The cache poses a special case because not all buffers in the cacheare available. Buffers for which operations have been completed can be taken from the cache at any time. However, buffers that correspond to pending operations (e.g., a430 A Remote Disk Driver Chap. 18process has requested a read operation but has not yet extracted the data) must remainin the cache. We will see how the cache and the semaphores are used later.18.10 The Upper–half Open Function (rdsopen)The remote disk server allows multiple clients to access the server simultaneously. Each client supplies a unique identification string which allows the server to distinguish among clients. Instead of using a hardware value (e.g., an Ethernet address) as the unique string, the example code allows a user to specify the ID string by calling open on the disk device. The chief advantage of separating the ID from the hardware is por-tability — the remote disk ID can be bound to the operating system image, which means that moving the image from one physical computer to another does not change the disk that the system is using.When a process calls open for a remote disk device, the second argument is inter-preted as an ID string. The string is copied into the device control block, and the sameID is used as long as the device remains open. It is possible to close the remote disk device and reopen it with a new ID (i.e., connect to a different remote disk). However, most systems are expected to open a remote disk device once and never close it. File rdsopen.c contains the code://**rrddssooppeenn..cc--rrddssooppeenn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddssooppeenn--OOppeennaarreemmootteeddiisskkddeevviicceeaannddssppeecciiffyyaannIIDDttoouussee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrddssooppeenn((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**ddiisskkiidd,,//**DDiisskkIIDDttoouussee**//cchhaarr**mmooddee//**UUnnuusseeddffoorraarreemmootteeddiisskk**//)){{ssttrruuccttrrddssccbbllkk**rrddppttrr;;//**PPttrrttooccoonnttrroollbblloocckkeennttrryy**//ssttrruuccttrrdd__mmssgg__oorreeqqmmssgg;;//**MMeessssaaggeettoobbeesseenntt**//ssttrruuccttrrdd__mmssgg__oorreessrreesspp;;//**BBuuffffeerrttoohhoollddrreessppoonnssee**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluueeffrroommrrddssccoommmm**//iinntt3322lleenn;;//**CCoouunnttsscchhaarrssiinnddiisskkiidd**//cchhaarr**iiddttoo;;//**PPttrrttooIIDDssttrriinnggccooppyy**//cchhaarr**iiddffrroomm;;//**PPooiinntteerriinnttooIIDDssttrriinngg**//Sec. 18.10        The Upper–half Open Function (rdsopen) 431rrddppttrr==&&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**RReejjeeccttiiffddeevviicceeiissaallrreeaaddyyooppeenn**//iiff((rrddppttrr-->>rrdd__ssttaattee!!==RRDD__FFRREEEE)){{rreettuurrnnSSYYSSEERRRR;;}} rrddppttrr-->>rrdd__ssttaattee==RRDD__PPEENNDD;;//**CCooppyyddiisskkIIDDiinnttooffrreeeettaabblleesslloott**//iiddttoo==rrddppttrr-->>rrdd__iidd;;iiddffrroomm==ddiisskkiidd;;lleenn==00;;wwhhiillee((((**iiddttoo++++==**iiddffrroomm++++))!!==NNUULLLLCCHH)){{lleenn++++;;iiff((lleenn>>==RRDD__IIDDLLEENN)){{//**IIDDssttrriinnggiissttoooolloonngg**//rreettuurrnnSSYYSSEERRRR;;}}}} //**VVeerriiffyytthhaattnnaammeeiissnnoonn--nnuullll**//iiff((lleenn====00)){{rreettuurrnnSSYYSSEERRRR;;}} //**HHaanndd--ccrraaffttaannooppeennrreeqquueessttmmeessssaaggeettoobbeesseennttttootthheesseerrvveerr**//mmssgg..rrdd__ttyyppee==hhttoonnss((RRDD__MMSSGG__OORREEQQ));;//**RReeqquueessttaannooppeenn**//mmssgg..rrdd__ssttaattuuss==hhttoonnss((00));;mmssgg..rrdd__sseeqq==00;;//**RRddssccoommmmffiillllssiinnaanneennttrryy**//iiddttoo==mmssgg..rrdd__iidd;;mmeemmsseett((iiddttoo,,NNUULLLLCCHH,,RRDD__IIDDLLEENN));;//**iinniittiiaalliizzeeIIDDttoozzeerroobbyytteess**//iiddffrroomm==ddiisskkiidd;;wwhhiillee((((**iiddttoo++++==**iiddffrroomm++++))!!==NNUULLLLCCHH)){{//**CCooppyyIIDDttoorreeqq..**//;;}} //**SSeennddmmeessssaaggeeaannddrreecceeiivveerreessppoonnssee**//rreettvvaall==rrddssccoommmm((((ssttrruuccttrrdd__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__oorreeqq)),,((ssttrruuccttrrdd__mmssgg__hhddrr**))&&rreesspp,,432 A Remote Disk Driver Chap. 18ssiizzeeooff((ssttrruuccttrrdd__mmssgg__oorreess)),,rrddppttrr));;//**CChheecckkrreessppoonnssee**//iiff((rreettvvaall====SSYYSSEERRRR)){{rrddppttrr-->>rrdd__ssttaattee==RRDD__FFRREEEE;;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((rreettvvaall====TTIIMMEEOOUUTT)){{kkpprriinnttff((""TTiimmeeoouuttdduurriinnggrreemmootteeffiilleeooppeenn\\nn\\rr""));;rrddppttrr-->>rrdd__ssttaattee==RRDD__FFRREEEE;;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnttoohhss((rreesspp..rrdd__ssttaattuuss))!!==00)){{rrddppttrr-->>rrdd__ssttaattee==RRDD__FFRREEEE;;rreettuurrnnSSYYSSEERRRR;;}} //**CChhaannggeessttaatteeooffddeevviicceettooiinnddiiccaatteeccuurrrreennttllyyooppeenn**//rrddppttrr-->>rrdd__ssttaattee==RRDD__OOPPEENN;;//**RReettuurrnnddeevviicceeddeessccrriippttoorr**//rreettuurrnnddeevvppttrr-->>ddvvnnuumm;;}}18.11 The Remote Communication Function (rdscomm)As one of the steps in opening the local remote disk device, rdsopen exchanges a message with the remote server. It places an open request message in local variable msg, and calls rdscomm to forward the message to the server. Rdscomm takes argu-ments that specify an outgoing message, a buffer for a reply, and the length of each. It sends the outgoing message to the server, and awaits a reply. If the reply is valid, rdscomm returns the length of the reply to the caller; otherwise, it returns SYSERR to in-dicate that an error occurred or TIMEOUT to indicate that no response was received. File rdscomm.c contains the code://**rrddssccoommmm..cc--rrddssccoommmm**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddssccoommmm--hhaannddlleeccoommmmuunniiccaattiioonnwwiitthhaarreemmootteeddiisskksseerrvveerr((sseennddaa**rreeqquueessttaannddrreecceeiivveeaarreeppllyy,,iinncclluuddiinnggsseeqquueenncciinnggaanndd**rreettrriieess))Sec. 18.11        The Remote Communication Function (rdscomm) 433**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussrrddssccoommmm((ssttrruuccttrrdd__mmssgg__hhddrr**mmssgg,,//**MMeessssaaggeettoosseenndd**//iinntt3322mmlleenn,,//**MMeessssaaggeelleennggtthh**//ssttrruuccttrrdd__mmssgg__hhddrr**rreeppllyy,,//**BBuuffffeerrffoorrrreeppllyy**//iinntt3322rrlleenn,,//**SSiizzeeooffrreeppllyybbuuffffeerr**//ssttrruuccttrrddssccbbllkk**rrddppttrr//**PPttrrttooddeevviicceeccoonnttrroollbblloocckk**//)){{iinntt3322ii;;//**CCoouunnttssrreettrriieess**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**//iinntt3322sseeqq;;//**SSeeqquueenncceeffoorrtthhiisseexxcchhaannggee**//uuiinntt3322llooccaalliipp;;//**LLooccaallIIPPaaddddrreessss**//iinntt1166rrttyyppee;;//**RReeppllyyttyyppeeiinnhhoossttbbyytteeoorrddeerr**//bbooooll88xxmmiitt;;//**SShhoouullddwweettrraannssmmiittaaggaaiinn??**//iinntt3322sslloott;;//**UUDDPPsslloott**////**FFoorrtthheeffiirrssttttiimmeeaafftteerrrreebboooott,,rreeggiisstteerrtthheesseerrvveerrppoorrtt**//iiff((!!rrddppttrr-->>rrdd__rreeggiisstteerreedd)){{sslloott==uuddpp__rreeggiisstteerr((00,,rrddppttrr-->>rrdd__sseerr__ppoorrtt,,rrddppttrr-->>rrdd__lloocc__ppoorrtt));;iiff((sslloott====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} rrddppttrr-->>rrdd__uuddppsslloott==sslloott;;rrddppttrr-->>rrdd__rreeggiisstteerreedd==TTRRUUEE;;}} iiff((NNeettDDaattaa..iippvvaalliidd====FFAALLSSEE)){{llooccaalliipp==ggeettllooccaalliipp(());;iiff((((iinntt3322))llooccaalliipp====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}}}} //**RReettrriieevveetthheessaavveeddUUDDPPsslloottnnuummbbeerr**//sslloott==rrddppttrr-->>rrdd__uuddppsslloott;;//**AAssssiiggnnmmeessssaaggeenneexxttsseeqquueenncceennuummbbeerr**//sseeqq==rrddppttrr-->>rrdd__sseeqq++++;;mmssgg-->>rrdd__sseeqq==hhttoonnll((sseeqq));;434 A Remote Disk Driver Chap. 18//**RReeppeeaattRRDD__RREETTRRIIEESSttiimmeess::sseennddmmeessssaaggeeaannddrreecceeiivveerreeppllyy**//xxmmiitt==TTRRUUEE;;ffoorr((ii==00;;ii<<RRDD__RREETTRRIIEESS;;ii++++)){{iiff((xxmmiitt)){{//**SSeennddaaccooppyyoofftthheemmeessssaaggee**//rreettvvaall==uuddpp__sseennddttoo((sslloott,,rrddppttrr-->>rrdd__sseerr__iipp,,rrddppttrr-->>rrdd__sseerr__ppoorrtt,,((cchhaarr**))mmssgg,,mmlleenn));;iiff((rreettvvaall====SSYYSSEERRRR)){{kkpprriinnttff((""CCaannnnoottsseennddttoorreemmootteeddiisskksseerrvveerr\\nn\\rr""));;rreettuurrnnSSYYSSEERRRR;;}}}}eellssee{{xxmmiitt==TTRRUUEE;;}} //**RReecceeiivveeaarreeppllyy**//rreettvvaall==uuddpp__rreeccvv((sslloott,,((cchhaarr**))rreeppllyy,,rrlleenn,,RRDD__TTIIMMEEOOUUTT));;iiff((rreettvvaall====TTIIMMEEOOUUTT)){{ccoonnttiinnuuee;;}}eellsseeiiff((rreettvvaall====SSYYSSEERRRR)){{kkpprriinnttff((""EErrrroorrrreeaaddiinnggrreemmootteeddiisskkrreeppllyy\\nn\\rr""));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyytthhaattsseeqquueenncceeiinnrreeppllyymmaattcchheessrreeqquueesstt**//iiff((nnttoohhll((rreeppllyy-->>rrdd__sseeqq))<<sseeqq)){{xxmmiitt==FFAALLSSEE;;}}eellsseeiiff((nnttoohhll((rreeppllyy-->>rrdd__sseeqq))!!==sseeqq)){{ccoonnttiinnuuee;;}} //**VVeerriiffyytthheettyyppeeiinntthheerreeppllyymmaattcchheesstthheerreeqquueesstt**//rrttyyppee==nnttoohhss((rreeppllyy-->>rrdd__ttyyppee));;iiff((rrttyyppee!!==((nnttoohhss((mmssgg-->>rrdd__ttyyppee))||RRDD__MMSSGG__RREESSPPOONNSSEE)))){{ccoonnttiinnuuee;;}}Sec. 18.11        The Remote Communication Function (rdscomm) 435//**CChheecckktthheessttaattuuss**//iiff((nnttoohhss((rreeppllyy-->>rrdd__ssttaattuuss))!!==00)){{rreettuurrnnSSYYSSEERRRR;;}} rreettuurrnnOOKK;;}} //**RReettrriieesseexxhhaauusstteeddwwiitthhoouuttssuucccceessss**//kkpprriinnttff((""TTiimmeeoouuttoonneexxcchhaannggeewwiitthhrreemmootteeddiisskksseerrvveerr\\nn\\rr""));;rreettuurrnnTTIIMMEEOOUUTT;;}}Rdscomm uses UDP for communication with the remote server.† The code takestwo steps related to the use of UDP. First, rdscomm checks to see whether the UDPport has already been registered, and calls udp_register if it has not. It may seem thatthe check is unnecessary because the port will not be registered until rdscomm runs. However, checking at runtime allows the remote disk system to be restarted. Second, rdscomm checks to see whether the computer has already obtained an IP address (which is required for Internet communication). If an address has not been assigned, rdscomm calls getlocalip to obtain an address. Once the two steps are complete, rdscomm is ready to communicate with the remote disk server.Rdscomm assigns the next sequence number to the message, and enters a loop that iterates RD_RETRIES times. On each iteration, rdscomm calls udp_sendto to transmit a copy of the message to the server, and calls udp_recv to receive a reply. If a reply ar-rives, rdscomm verifies that the sequence number of the reply matches the sequence number of the request that was sent, that the type of the reply matches the type of the request, and that the status value indicates success (i.e., is zero). If the reply is valid, rdscomm returns OK to the caller; otherwise, it returns an error indication.18.12 The Upper–half Write Function (rdswrite)Because the remote disk system provides asynchronous write operations, theupper-half write function is easiest to understand. The general idea is that a write re-quest must be created, the data to be written must be copied into the request, and the re-quest must be enqueued on the request queue. However, because our driver has both a queue of impending requests and a cache of recently-accessed blocks, the driver must handle the case where a request refers to a block that is already in memory on the re-quest queue or in the cache. File rdswrite.c contains the code:†A description of UDP is given in Chapter 17, starting on page 358.436 A Remote Disk Driver Chap. 18//**rrddsswwrriittee..cc--rrddsswwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddsswwrriittee--WWrriitteeaabblloocckkttooaarreemmootteeddiisskk**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrddsswwrriittee((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrtthhaatthhoollddssaaddiisskkbbllkk**//iinntt3322bbllkk//**BBlloocckknnuummbbeerrttoowwrriittee**//)){{ssttrruuccttrrddssccbbllkk**rrddppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**//ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPooiinntteerrttoobbuuffffeerroonnaalliisstt**//ssttrruuccttrrddbbuuffff**ppppttrr;;//**PPttrrttoopprreevviioouussbbuuffffoonnlliisstt**//ssttrruuccttrrddbbuuffff**nnppttrr;;//**PPttrrttoonneexxttbbuuffffeerroonnlliisstt**//bbooooll88ffoouunndd;;//**WWaassbbuuffffffoouunndddduurriinnggsseeaarrcchh??**////**IIffddeevviicceennoottccuurrrreennttllyyiinnuussee,,rreeppoorrttaanneerrrroorr**//rrddppttrr==&&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrddppttrr-->>rrdd__ssttaattee!!==RRDD__OOPPEENN)){{rreettuurrnnSSYYSSEERRRR;;}} //**IIffrreeqquueessttqquueeuueeaallrreeaaddyyccoonnttaaiinnssaawwrriitteerreeqquueesstt**////**ffoorrtthheebblloocckk,,rreeppllaacceetthheeccoonntteennttss**//bbppttrr==rrddppttrr-->>rrdd__rrhhnneexxtt;;wwhhiillee((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__rrttnneexxtt)){{iiff((((bbppttrr-->>rrdd__bbllkknnuumm====bbllkk))&&&&((bbppttrr-->>rrdd__oopp====RRDD__OOPP__WWRRIITTEE)))){{mmeemmccppyy((bbppttrr-->>rrdd__bblloocckk,,bbuuffff,,RRDD__BBLLKKSSIIZZ));;rreettuurrnnOOKK;;}} bbppttrr==bbppttrr-->>rrdd__nneexxtt;;}} //**SSeeaarrcchhccaacchheeffoorrccaacchheeddccooppyyooffbblloocckk**//bbppttrr==rrddppttrr-->>rrdd__cchhnneexxtt;;ffoouunndd==FFAALLSSEE;;Sec. 18.12        The Upper–half Write Function (rdswrite) 437wwhhiillee((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__ccttnneexxtt)){{iiff((bbppttrr-->>rrdd__bbllkknnuumm====bbllkk)){{iiff((bbppttrr-->>rrdd__rreeffccnntt<<==00)){{ppppttrr==bbppttrr-->>rrdd__pprreevv;;nnppttrr==bbppttrr-->>rrdd__nneexxtt;;//**UUnnlliinnkknnooddeeffrroommccaacchheelliissttaannddrreesseett**////**tthheeaavvaaiillaabblleesseemmaapphhoorreeaaccccoorrddiinnggllyy**//ppppttrr-->>rrdd__nneexxtt==bbppttrr-->>rrdd__nneexxtt;;nnppttrr-->>rrdd__pprreevv==bbppttrr-->>rrdd__pprreevv;;sseemmrreesseett((rrddppttrr-->>rrdd__aavvaaiillsseemm,,sseemmccoouunntt((rrddppttrr-->>rrdd__aavvaaiillsseemm))--11));;ffoouunndd==TTRRUUEE;;}} bbrreeaakk;;}} bbppttrr==bbppttrr-->>rrdd__nneexxtt;;}} iiff((!!ffoouunndd)){{bbppttrr==rrddssbbuuffaalllloocc((rrddppttrr));;}} //**CCrreeaatteeaawwrriitteerreeqquueesstt**//mmeemmccppyy((bbppttrr-->>rrdd__bblloocckk,,bbuuffff,,RRDD__BBLLKKSSIIZZ));;bbppttrr-->>rrdd__oopp==RRDD__OOPP__WWRRIITTEE;;bbppttrr-->>rrdd__rreeffccnntt==00;;bbppttrr-->>rrdd__bbllkknnuumm==bbllkk;;bbppttrr-->>rrdd__ssttaattuuss==RRDD__VVAALLIIDD;;bbppttrr-->>rrdd__ppiidd==ggeettppiidd(());;//**IInnsseerrttnneewwrreeqquueessttiinnttoolliissttjjuussttbbeeffoorreettaaiill**//ppppttrr==rrddppttrr-->>rrdd__rrttpprreevv;;rrddppttrr-->>rrdd__rrttpprreevv==bbppttrr;;bbppttrr-->>rrdd__nneexxtt==ppppttrr-->>rrdd__nneexxtt;;bbppttrr-->>rrdd__pprreevv==ppppttrr;;ppppttrr-->>rrdd__nneexxtt==bbppttrr;;//**SSiiggnnaallsseemmaapphhoorreettoossttaarrttccoommmmuunniiccaattiioonnpprroocceessss**//ssiiggnnaall((rrddppttrr-->>rrdd__rreeqqsseemm));;rreettuurrnnOOKK;;}}438 A Remote Disk Driver Chap. 18The code first considers the case where the request queue already contains a pend-ing write request for the same block. Note: there can only be one write request for a given block on the request queue at a time, which means the queue can be searched inany order. The code searches the queue from the head toward the tail. If it finds a write request for the block, rdswrite replaces the contents of the request with the new data, and returns.After searching the request queue, rdswrite checks the cache. If the specified block is in the cache, the cached copy must be invalidated. The code searches the cache sequentially. If it finds a match, rdswrite removes the buffer from the cache. Instead of moving the buffer to the free list, rdswrite uses the buffer to form a request. If no match is found, rdswrite calls rdsbufalloc to allocate a new buffer for the request.The final section of rdswrite creates a write request and inserts it at the tail of the request queue. To help with debugging, the code fills in all fields of the request, evenif they are not needed. For example, the process ID field is set to the ID of the calling process, even though the field is not used for a write operation.18.13 The Upper–half Read Function (rdsread)The second major upper-half function corresponds to the read operation. Reading is more complex than writing, because input is synchronous: a process that attempts to read from the disk must be blocked until the data is available. Synchronization of a waiting process uses send and receive. A node in the request queue contains a process ID field. When a process calls read, the driver code creates a read request that includes the caller’s process ID. It then inserts the request on the request queue, calls recvclr to remove pending messages, and calls receive to wait for a response. When the request reaches the head of the queue, the remote disk communication process sends a message to the server and receives a response that contains the specified block. The communica-tion process copies the block into the buffer that contains the original request, moves the buffer to the cache, and uses send to send a message to the waiting process with the buffer address. The waiting process receives the message, extracts a copy of the data, and returns to the function that called read.As described, the above scheme is insufficient because buffers are used dynamical-ly. To understand the problem, imagine that a low-priority process is blocked waitingto read block 5. Eventually, the communication process obtains block 5 from theserver, stores block 5 in the cache, and sends a message to the waiting process. How-ever, assume that while the request is on the request queue, higher-priority application processes begin to execute, meaning that the low-priority process will not run. Unfor-tunately, if the high-priority processes continue to use disk buffers, the buffer holding block 5 will be taken for another operation.The problem is exacerbated because the remote disk system permits concurrent ac-cess: while one process is waiting to read a block, another process can attempt to readthe same block. Thus, when the communication process finally retrieves a copy of the block from the server, multiple processes may need to be informed.Sec. 18.13        The Upper–half Read Function (rdsread) 439The example code uses a reference count technique to handle multiple requests for a block: the header with each buffer contains an integer that counts the number of processes currently reading the block. When a process finishes making a copy, the process decrements the reference count. The code in file rdsread.c shows how a proc-ess creates a request, enqueues it at the tail of the request list, waits for the request to be filled, and copies data from the request to each caller’s buffer; later in the chapter, we will see how the reference count is managed.//**rrddssrreeaadd..cc--rrddssrreeaadd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddssrreeaadd--RReeaaddaabblloocckkffrroommaarreemmootteeddiisskk**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrddssrreeaadd((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrttoohhoollddddiisskkbblloocckk**//iinntt3322bbllkk//**BBlloocckknnuummbbeerrooffbblloocckkttoorreeaadd**//)){{ssttrruuccttrrddssccbbllkk**rrddppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**//ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPooiinntteerrttoobbuuffffeerrppoossssiibbllyy**////**iinntthheerreeqquueessttlliisstt**//ssttrruuccttrrddbbuuffff**nnppttrr;;//**PPooiinntteerrttoo""nneexxtt""nnooddeeoonnaa**////**lliisstt**//ssttrruuccttrrddbbuuffff**ppppttrr;;//**PPooiinntteerrttoo""pprreevviioouuss""nnooddee**////**oonnaalliisstt**//ssttrruuccttrrddbbuuffff**ccppttrr;;//**PPooiinntteerrtthhaattwwaallkksstthheeccaacchhee**////**IIffddeevviicceennoottccuurrrreennttllyyiinnuussee,,rreeppoorrttaanneerrrroorr**//rrddppttrr==&&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrddppttrr-->>rrdd__ssttaattee!!==RRDD__OOPPEENN)){{rreettuurrnnSSYYSSEERRRR;;}} //**SSeeaarrcchhtthheeccaacchheeffoorrssppeecciiffiieeddbblloocckk**//bbppttrr==rrddppttrr-->>rrdd__cchhnneexxtt;;wwhhiillee((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__ccttnneexxtt)){{iiff((bbppttrr-->>rrdd__bbllkknnuumm====bbllkk)){{iiff((bbppttrr-->>rrdd__ssttaattuuss====RRDD__IINNVVAALLIIDD)){{bbrreeaakk;;}}440 A Remote Disk Driver Chap. 18mmeemmccppyy((bbuuffff,,bbppttrr-->>rrdd__bblloocckk,,RRDD__BBLLKKSSIIZZ));;rreettuurrnnOOKK;;}} bbppttrr==bbppttrr-->>rrdd__nneexxtt;;}} //**SSeeaarrcchhtthheerreeqquueessttlliissttffoorrmmoossttrreecceennttooccccuurrrreenncceeooffbblloocckk**//bbppttrr==rrddppttrr-->>rrdd__rrttpprreevv;;//**SSttaarrttaattttaaiilloofflliisstt**//wwhhiillee((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__rrhhnneexxtt)){{iiff((bbppttrr-->>rrdd__bbllkknnuumm====bbllkk)){{//**IIffmmoossttrreecceennttrreeqquueessttffoorrbblloocckkiisswwrriittee,,ccooppyyddaattaa**//iiff((bbppttrr-->>rrdd__oopp====RRDD__OOPP__WWRRIITTEE)){{mmeemmccppyy((bbuuffff,,bbppttrr-->>rrdd__bblloocckk,,RRDD__BBLLKKSSIIZZ));;rreettuurrnnOOKK;;}} bbrreeaakk;;}} bbppttrr==bbppttrr-->>rrdd__pprreevv;;}} //**AAllllooccaatteeaabbuuffffeerraannddaaddddrreeaaddrreeqquueessttttoottaaiillooffrreeqq..qquueeuuee**//bbppttrr==rrddssbbuuffaalllloocc((rrddppttrr));;bbppttrr-->>rrdd__oopp==RRDD__OOPP__RREEAADD;;bbppttrr-->>rrdd__rreeffccnntt==11;;bbppttrr-->>rrdd__bbllkknnuumm==bbllkk;;bbppttrr-->>rrdd__ssttaattuuss==RRDD__IINNVVAALLIIDD;;bbppttrr-->>rrdd__ppiidd==ggeettppiidd(());;//**IInnsseerrttnneewwrreeqquueessttiinnttoolliissttjjuussttbbeeffoorreettaaiill**//ppppttrr==rrddppttrr-->>rrdd__rrttpprreevv;;rrddppttrr-->>rrdd__rrttpprreevv==bbppttrr;;bbppttrr-->>rrdd__nneexxtt==ppppttrr-->>rrdd__nneexxtt;;bbppttrr-->>rrdd__pprreevv==ppppttrr;;ppppttrr-->>rrdd__nneexxtt==bbppttrr;;//**PPrreeppaarreettoorreecceeiivveemmeessssaaggeewwhheennrreeaaddccoommpplleetteess**//rreeccvvccllrr(());;Sec. 18.13        The Upper–half Read Function (rdsread) 441//**SSiiggnnaallsseemmaapphhoorreettoossttaarrttccoommmmuunniiccaattiioonnpprroocceessss**//ssiiggnnaall((rrddppttrr-->>rrdd__rreeqqsseemm));;//**BBlloocckkttoowwaaiittffoorrmmeessssaaggee**//bbppttrr==((ssttrruuccttrrddbbuuffff**))rreecceeiivvee(());;iiff((bbppttrr====((ssttrruuccttrrddbbuuffff**))SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} mmeemmccppyy((bbuuffff,,bbppttrr-->>rrdd__bblloocckk,,RRDD__BBLLKKSSIIZZ));;bbppttrr-->>rrdd__rreeffccnntt----;;iiff((bbppttrr-->>rrdd__rreeffccnntt<<==00)){{//**LLooookkffoorrpprreevviioouussiitteemmiinnccaacchheewwiitthhtthheessaammeebblloocckk**////**nnuummbbeerrttoosseeeeiifftthhiissiitteemmwwaassoonnllyybbeeiinnggkkeepptt**////**uunnttiillppeennddiinnggrreeaaddccoommpplleetteedd**//ccppttrr==rrddppttrr-->>rrdd__cchhnneexxtt;;wwhhiillee((ccppttrr!!==bbppttrr)){{iiff((ccppttrr-->>rrdd__bbllkknnuumm====bbllkk)){{//**UUnnlliinnkkffrroommccaacchhee**//ppppttrr==bbppttrr-->>rrdd__pprreevv;;nnppttrr==bbppttrr-->>rrdd__nneexxtt;;ppppttrr-->>rrdd__nneexxtt==nnppttrr;;nnppttrr-->>rrdd__pprreevv==ppppttrr;;//**AAddddttootthheeffrreeeelliisstt**//bbppttrr-->>rrdd__nneexxtt==rrddppttrr-->>rrdd__ffrreeee;;rrddppttrr-->>rrdd__ffrreeee==bbppttrr;;}}}}}} rreettuurrnnOOKK;;}}Rdsread begins by handling two special cases. First, if the requested block isfound in the cache, rdsread extracts a copy of the data and returns. Second, if the re-quest list contains a request to write the specified block, rdsread extracts a copy of thedata from the buffer and returns. Finally, rdsread creates a read request, enqueues the request at the tail of the request queue, and waits for a message from the communica-tion process as described above.442 A Remote Disk Driver Chap. 18The code handles one more detail: the case where the reference count reaches zeroand a subsequent read for the same block has placed a more recent buffer in the cache.If this happens, the more recent version will be used for subsequent reads. Therefore, rdsreadmust extract the old buffer from the cache and move it to the free list.18.14 Flushing Pending RequestsBecause write does not wait for data transfer, the driver does not inform a process when a write operation completes. However, it may be important for the software toknow when data is safely stored. For example, an operating system usually ensures that write operations are completed before shutdown.To allow a process to guarantee that all disk transfers have occurred, the driver in-cludes a primitive that will block the calling process until existing requests have been performed. Because “synchronizing” the disk is not a data transfer operation, we use the high-level operation control. To flush pending requests, a process calls:control ( disk_device, RD_SYNC )The driver suspends the calling process until existing requests have been satisfied on the specified device. Once pending operations complete, the call returns.18.15 The Upper–half Control Function (rdscontrol)As discussed above, the example driver offers two control functions: one to erasean entire disk and one to synchronize data to the disk (i.e., forcing all write operationsto complete). File rdscontrol.c contains the code://**rrddssccoonnttrrooll..cc--rrddssccoonnttrrooll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddssccoonnttrrooll--PPrroovviiddeeccoonnttrroollffuunnccttiioonnssffoorrtthheerreemmootteeddiisskk**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrddssccoonnttrrooll((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322ffuunncc,,//**TThheeccoonnttrroollffuunnccttiioonnttoouussee**//iinntt3322aarrgg11,,//**AArrgguummeenntt##11**//iinntt3322aarrgg22//**AArrgguummeenntt##22**//)){{Sec. 18.15        The Upper–half Control Function (rdscontrol) 443ssttrruuccttrrddssccbbllkk**rrddppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**//ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPttrrttoobbuuffffeerrtthhaattwwiillllbbee**////**ppllaacceeddoonntthheerreeqq..qquueeuuee**//ssttrruuccttrrddbbuuffff**ppppttrr;;//**PPttrrttoo""pprreevviioouuss""nnooddeeoonn**////**aalliisstt**//ssttrruuccttrrdd__mmssgg__ddrreeqqmmssgg;;//**BBuuffffeerrffoorrddeelleetteerreeqquueesstt**//ssttrruuccttrrdd__mmssgg__ddrreessrreesspp;;//**BBuuffffeerrffoorrddeelleetteerreessppoonnssee**//cchhaarr**ttoo,,**ffrroomm;;//**UUsseedddduurriinnggnnaammeeccooppyy**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**////**VVeerriiffyytthhaattddeevviicceeiissccuurrrreennttllyyooppeenn**//rrddppttrr==&&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrddppttrr-->>rrdd__ssttaattee!!==RRDD__OOPPEENN)){{rreettuurrnnSSYYSSEERRRR;;}} sswwiittcchh((ffuunncc)){{//**SSyynncchhrroonniizzeewwrriitteess**//ccaasseeRRDDSS__CCTTLL__SSYYNNCC:://**AAllllooccaatteeaabbuuffffeerrttoouusseeffoorrtthheerreeqquueessttlliisstt**//bbppttrr==rrddssbbuuffaalllloocc((rrddppttrr));;iiff((bbppttrr====((ssttrruuccttrrddbbuuffff**))SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**FFoorrmmaassyynnccrreeqquueesstt**//bbppttrr-->>rrdd__oopp==RRDD__OOPP__SSYYNNCC;;bbppttrr-->>rrdd__rreeffccnntt==11;;bbppttrr-->>rrdd__bbllkknnuumm==00;;//**UUnnuusseedd**//bbppttrr-->>rrdd__ssttaattuuss==RRDD__IINNVVAALLIIDD;;bbppttrr-->>rrdd__ppiidd==ggeettppiidd(());;//**IInnsseerrttnneewwrreeqquueessttiinnttoolliissttjjuussttbbeeffoorreettaaiill**//ppppttrr==rrddppttrr-->>rrdd__rrttpprreevv;;rrddppttrr-->>rrdd__rrttpprreevv==bbppttrr;;bbppttrr-->>rrdd__nneexxtt==ppppttrr-->>rrdd__nneexxtt;;bbppttrr-->>rrdd__pprreevv==ppppttrr;;ppppttrr-->>rrdd__nneexxtt==bbppttrr;;444 A Remote Disk Driver Chap. 18//**PPrreeppaarreettoowwaaiittuunnttiilliitteemmiisspprroocceesssseedd**//rreeccvvccllrr(());;rreessuummee((rrddppttrr-->>rrdd__ccoommpprroocc));;//**BBlloocckkttoowwaaiittffoorrmmeessssaaggee**//bbppttrr==((ssttrruuccttrrddbbuuffff**))rreecceeiivvee(());;bbrreeaakk;;//**DDeelleetteetthheerreemmootteeddiisskk((eennttiirreellyyrreemmoovveeiitt))**//ccaasseeRRDDSS__CCTTLL__DDEELL:://**HHaannddccrraaffttaammeessssaaggeeffoorrtthheesseerrvveerrtthhaattrreeqquueessttss**////**ddeelleettiinnggtthheeddiisskkwwiitthhtthheessppeecciiffiieeddIIDD**//mmssgg..rrdd__ttyyppee==hhttoonnss((RRDD__MMSSGG__DDRREEQQ));;//**RReeqquueessttddeelleettiioonn**//mmssgg..rrdd__ssttaattuuss==hhttoonnss((00));;mmssgg..rrdd__sseeqq==00;;//**rrddssccoommmmwwiilllliinnsseerrttsseeqquueennccee##llaatteerr**//ttoo==mmssgg..rrdd__iidd;;mmeemmsseett((ttoo,,NNUULLLLCCHH,,RRDD__IIDDLLEENN));;//**IInniittiiaalliizzeettoozzeerrooeess**//ffrroomm==rrddppttrr-->>rrdd__iidd;;wwhhiillee((((**ttoo++++==**ffrroomm++++))!!==NNUULLLLCCHH)){{//**ccooppyyIIDD**//;;}} //**SSeennddmmeessssaaggeeaannddrreecceeiivveerreessppoonnssee**//rreettvvaall==rrddssccoommmm((((ssttrruuccttrrdd__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__ddrreeqq)),,((ssttrruuccttrrdd__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__ddrreess)),,rrddppttrr));;//**CChheecckkrreessppoonnssee**//iiff((rreettvvaall====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((rreettvvaall====TTIIMMEEOOUUTT)){{kkpprriinnttff((""TTiimmeeoouuttdduurriinnggrreemmootteeffiilleeddeelleettee\\nn\\rr""));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnttoohhss((rreesspp..rrdd__ssttaattuuss))!!==00)){{rreettuurrnnSSYYSSEERRRR;;}}Sec. 18.15        The Upper–half Control Function (rdscontrol) 445//**CClloosseellooccaallddeevviiccee**//rreettuurrnnrrddsscclloossee((ddeevvppttrr));;ddeeffaauulltt::kkpprriinnttff((""rrffssCCoonnttrrooll::ffuunnccttiioonn%%ddnnoottvvaalliidd\\nn\\rr"",,ffuunncc));;rreettuurrnnSSYYSSEERRRR;;}} rreettuurrnnOOKK;;}}The code for each control function should seem familiar. The code to delete an en-tire disk is similar to the code in rdsopen— it creates a message for the server and uses rdscomm to send the message. The code to synchronize disk writes is similar to the code in rdsread — it creates a request, enqueues the request, calls recvclr to remove pending messages, and calls receive to wait for a response. Once the response arrives, rdscontrol invokes rdsclose to close the local device, and returns to its caller.18.16 Allocating A Disk Buffer (rdsbufalloc)As we have seen, driver functions call rdsbufalloc when they need to allocate abuffer. To understand how rdsbufalloc operates, recall that a semaphore counts avail-able buffers either on the free list or in the cache with a reference count of zero. After waiting on the semaphore, rdsbufalloc knows that a buffer will exist in one of the two places. It checks the free list first. If the free list is not empty, rdsbufalloc extracts the first buffer and returns it. If the free list is empty, rdsbufalloc searches the cache for an available buffer, extracts the buffer, and returns it to the caller. If the search completes without finding an available buffer, the count of the semaphore is incorrect, and rdsbufalloc calls panic to halt the system.File rdsbufalloc.c contains the code:446 A Remote Disk Driver Chap. 18//**rrddssbbuuffaalllloocc..cc--rrddssbbuuffaalllloocc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddssbbuuffaalllloocc--AAllllooccaatteeaabbuuffffeerrffrroommtthheeffrreeeelliissttoorrtthheeccaacchhee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttrruuccttrrddbbuuffff**rrddssbbuuffaalllloocc((ssttrruuccttrrddssccbbllkk**rrddppttrr//**PPttrrttooddeevviicceeccoonnttrroollbblloocckk**//)){{ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPooiinntteerrttooaabbuuffffeerr**//ssttrruuccttrrddbbuuffff**ppppttrr;;//**PPooiinntteerrttoopprreevviioouussbbuuffffeerr**//ssttrruuccttrrddbbuuffff**nnppttrr;;//**PPooiinntteerrttoonneexxttbbuuffffeerr**////**WWaaiittffoorraannaavvaaiillaabblleebbuuffffeerr**//wwaaiitt((rrddppttrr-->>rrdd__aavvaaiillsseemm));;//**IIffffrreeeelliissttccoonnttaaiinnssaabbuuffffeerr,,eexxttrraaccttiitt**//bbppttrr==rrddppttrr-->>rrdd__ffrreeee;;iiff((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))NNUULLLL)){{rrddppttrr-->>rrdd__ffrreeee==bbppttrr-->>rrdd__nneexxtt;;rreettuurrnnbbppttrr;;}} //**EExxttrraaccttoollddeessttiitteemmiinnccaacchheetthhaatthhaassrreeffccoouunnttzzeerroo((aatt**////**lleeaassttoonneessuucchheennttrryymmuusstteexxiissttbbeeccaauusseetthheesseemmaapphhoorree**////**hhaaddaannoonnzzeerrooccoouunntt))**//bbppttrr==rrddppttrr-->>rrdd__ccttpprreevv;;wwhhiillee((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__cchhnneexxtt)){{iiff((bbppttrr-->>rrdd__rreeffccnntt<<==00)){{//**RReemmoovveeffrroommccaacchheeaannddrreettuurrnnttooccaalllleerr**//ppppttrr==bbppttrr-->>rrdd__pprreevv;;nnppttrr==bbppttrr-->>rrdd__nneexxtt;;ppppttrr-->>rrdd__nneexxtt==nnppttrr;;nnppttrr-->>rrdd__pprreevv==ppppttrr;;rreettuurrnnbbppttrr;;}}Sec. 18.16        Allocating A Disk Buffer (rdsbufalloc) 447bbppttrr==bbppttrr-->>rrdd__pprreevv;;}} ppaanniicc((""RReemmootteeddiisskkccaannnnoottffiinnddaannaavvaaiillaabblleebbuuffffeerr""));;rreettuurrnn((ssttrruuccttrrddbbuuffff**))SSYYSSEERRRR;;}}18.17 The Upper–half Close Function (rdsclose)A process invokes close to close the remote disk device and stop all communica-tion. To close a remote disk device, all buffers must be moved back to the free list (re-creating the conditions immediately following initialization) and the state field in the control block must be assigned RD_FREE. Our implementation removes buffers from the cache, but does not handle the request list. Instead, we require a user to wait until all requests have been satisfied and the request list is empty before calling rdsclose. The synchronization function, RDS_CTL_SYNC,† provides a way to wait for the request queue to drain. File rdsclose.c contains the code://**rrddsscclloossee..cc--rrddsscclloossee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddsscclloossee--CClloosseeaarreemmootteeddiisskkddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrddsscclloossee((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttrrddssccbbllkk**rrddppttrr;;//**PPttrrttooccoonnttrroollbblloocckkeennttrryy**//ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPttrrttoobbuuffffeerroonnaalliisstt**//ssttrruuccttrrddbbuuffff**nnppttrr;;//**PPttrrttoonneexxttbbuuffffoonntthheelliisstt**//iinntt3322nnmmoovveedd;;//**NNuummbbeerrooffbbuuffffeerrssmmoovveedd**////**DDeevviicceemmuussttbbeeooppeenn**//rrddppttrr==&&rrddssttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrddppttrr-->>rrdd__ssttaattee!!==RRDD__OOPPEENN)){{rreettuurrnnSSYYSSEERRRR;;}} //**RReeqquueessttqquueeuueemmuussttbbeeeemmppttyy**//†The synchronization code is found in file rdscontrol.c on page 442.448 A Remote Disk Driver Chap. 18iiff((rrddppttrr-->>rrdd__rrhhnneexxtt!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__rrttnneexxtt)){{rreettuurrnnSSYYSSEERRRR;;}} //**MMoovveeaallllbbuuffffeerrssffrroommtthheeccaacchheettootthheeffrreeeelliisstt**//bbppttrr==rrddppttrr-->>rrdd__cchhnneexxtt;;nnmmoovveedd==00;;wwhhiillee((bbppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__ccttnneexxtt)){{nnmmoovveedd++++;;//**UUnnlliinnkkbbuuffffeerrffrroommccaacchhee**//nnppttrr==bbppttrr-->>rrdd__nneexxtt;;((bbppttrr-->>rrdd__pprreevv))-->>rrdd__nneexxtt==nnppttrr;;nnppttrr-->>rrdd__pprreevv==bbppttrr-->>rrdd__pprreevv;;//**IInnsseerrttbbuuffffeerriinnttooffrreeeelliisstt**//bbppttrr-->>rrdd__nneexxtt==rrddppttrr-->>rrdd__ffrreeee;;rrddppttrr-->>rrdd__ffrreeee==bbppttrr;;bbppttrr-->>rrdd__ssttaattuuss==RRDD__IINNVVAALLIIDD;;//**MMoovveettoonneexxttbbuuffffeerriinntthheeccaacchhee**//bbppttrr==nnppttrr;;}} //**SSeetttthheessttaatteettooiinnddiiccaatteetthheeddeevviicceeiisscclloosseedd**//rrddppttrr-->>rrdd__ssttaattee==RRDD__FFRREEEE;;rreettuurrnnOOKK;;}}18.18 The Lower–half Communication Process (rdsprocess)In the example implementation, each remote disk device has its own control block, its own set of disk buffers, and its own remote communication process. Thus, a given remote disk process only needs to handle requests from a single queue. Although the code may seem long and filled with details, the general algorithm is straightforward: re-peatedly wait on the request semaphore, examine the type of the request at the head of the queue, and either perform a read,awrite, or asynchronization operation. File rdsprocess.c contains the code:Sec. 18.18        The Lower–half Communication Process (rdsprocess) 449//**rrddsspprroocceessss..cc--rrddsspprroocceessss**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrddsspprroocceessss--HHiigghh--pprriioorriittyybbaacckkggrroouunnddpprroocceessssttoorreeppeeaatteeddllyyeexxttrraacctt**aanniitteemmffrroommtthheerreeqquueessttqquueeuueeaannddsseennddtthheerreeqquueessttttoo**tthheerreemmootteeddiisskksseerrvveerr**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddrrddsspprroocceessss((ssttrruuccttrrddssccbbllkk**rrddppttrr//**PPttrrttooddeevviicceeccoonnttrroollbblloocckk**//)){{ssttrruuccttrrdd__mmssgg__wwrreeqqmmssgg;;//**MMeessssaaggeettoobbeesseenntt**////**((iinncclluuddeessddaattaaaarreeaa))**//ssttrruuccttrrdd__mmssgg__rrrreessrreesspp;;//**BBuuffffeerrttoohhoollddrreessppoonnssee**////**((iinncclluuddeessddaattaaaarreeaa))**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluueeffrroommrrddssccoommmm**//cchhaarr**iiddttoo;;//**PPttrrttooIIDDssttrriinnggccooppyy**//cchhaarr**iiddffrroomm;;//**PPttrriinnttooIIDDssttrriinngg**//ssttrruuccttrrddbbuuffff**bbppttrr;;//**PPttrrttoobbuuffffeerraatttthheehheeaaddooff**////**tthheerreeqquueessttqquueeuuee**//ssttrruuccttrrddbbuuffff**nnppttrr;;//**PPttrrttoonneexxttbbuuffffeerroonntthhee**////**rreeqquueessttqquueeuuee**//ssttrruuccttrrddbbuuffff**ppppttrr;;//**PPttrrttoopprreevviioouussbbuuffffeerr**//ssttrruuccttrrddbbuuffff**qqppttrr;;//**PPttrrtthhaattrruunnssaalloonnggtthhee**////**rreeqquueessttqquueeuuee**//iinntt3322ii;;//**LLooooppiinnddeexx**//wwhhiillee((TTRRUUEE)){{//**DDooffoorreevveerr**////**WWaaiittuunnttiilltthheerreeqquueessttqquueeuueeccoonnttaaiinnssaannooddee**//wwaaiitt((rrddppttrr-->>rrdd__rreeqqsseemm));;bbppttrr==rrddppttrr-->>rrdd__rrhhnneexxtt;;//**UUsseeooppeerraattiioonniinnrreeqquueessttttooddeetteerrmmiinneeaaccttiioonn**//sswwiittcchh((bbppttrr-->>rrdd__oopp)){{ccaasseeRRDD__OOPP__RREEAADD:://**BBuuiillddaarreeaaddrreeqquueessttmmeessssaaggeeffoorrtthheesseerrvveerr**//mmssgg..rrdd__ttyyppee==hhttoonnss((RRDD__MMSSGG__RRRREEQQ));;//**RReeaaddrreeqquueesstt**//mmssgg..rrdd__ssttaattuuss==hhttoonnss((00));;450 A Remote Disk Driver Chap. 18mmssgg..rrdd__sseeqq==00;;//**RRddssccoommmmffiillllssiinnaanneennttrryy**//iiddttoo==mmssgg..rrdd__iidd;;mmeemmsseett((iiddttoo,,NNUULLLLCCHH,,RRDD__IIDDLLEENN));;//**IInniittiiaalliizzeeIIDDttoozzeerroo**//iiddffrroomm==rrddppttrr-->>rrdd__iidd;;wwhhiillee((((**iiddttoo++++==**iiddffrroomm++++))!!==NNUULLLLCCHH)){{//**CCooppyyIIDD**//;;}} //**SSeennddtthheemmeessssaaggeeaannddrreecceeiivveeaarreessppoonnssee**//rreettvvaall==rrddssccoommmm((((ssttrruuccttrrdd__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__rrrreeqq)),,((ssttrruuccttrrdd__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__rrrreess)),,rrddppttrr));;//**CChheecckkrreessppoonnssee**//iiff((((rreettvvaall====SSYYSSEERRRR))||||((rreettvvaall====TTIIMMEEOOUUTT))||||((nnttoohhss((rreesspp..rrdd__ssttaattuuss))!!==00)))){{ppaanniicc((""FFaaiilleeddttooccoonnttaaccttrreemmootteeddiisskksseerrvveerr""));;}} //**CCooppyyddaattaaffrroommtthheerreeppllyyiinnttootthheebbuuffffeerr**//ffoorr((ii==00;;ii<<RRDD__BBLLKKSSIIZZ;;ii++++)){{bbppttrr-->>rrdd__bblloocckk[[ii]]==rreesspp..rrdd__ddaattaa[[ii]];;}} //**UUnnlliinnkkbbuuffffeerrffrroommtthheerreeqquueessttqquueeuuee**//nnppttrr==bbppttrr-->>rrdd__nneexxtt;;ppppttrr==bbppttrr-->>rrdd__pprreevv;;nnppttrr-->>rrdd__pprreevv==bbppttrr-->>rrdd__pprreevv;;ppppttrr-->>rrdd__nneexxtt==bbppttrr-->>rrdd__nneexxtt;;//**IInnsseerrttbbuuffffeerriinntthheeccaacchhee**//ppppttrr==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__cchhnneexxtt;;nnppttrr==ppppttrr-->>rrdd__nneexxtt;;bbppttrr-->>rrdd__nneexxtt==nnppttrr;;bbppttrr-->>rrdd__pprreevv==ppppttrr;;ppppttrr-->>rrdd__nneexxtt==bbppttrr;;nnppttrr-->>rrdd__pprreevv==bbppttrr;;Sec. 18.18        The Lower–half Communication Process (rdsprocess) 451//**IInniittiiaalliizzeerreeffeerreenncceeccoouunntt**//bbppttrr-->>rrdd__rreeffccnntt==11;;//**SSiiggnnaalltthheeaavvaaiillaabblleesseemmaapphhoorree**//ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;//**SSeennddaammeessssaaggeettoowwaaiittiinnggpprroocceessss**//sseenndd((bbppttrr-->>rrdd__ppiidd,,((uuiinntt3322))bbppttrr));;//**IIffootthheerrpprroocceesssseessaarreewwaaiittiinnggttoorreeaaddtthhee**////**bblloocckk,,nnoottiiffyytthheemmaannddrreemmoovveetthheerreeqquueesstt**//qqppttrr==rrddppttrr-->>rrdd__rrhhnneexxtt;;wwhhiillee((qqppttrr!!==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__rrttnneexxtt)){{iiff((qqppttrr-->>rrdd__bbllkknnuumm====bbppttrr-->>rrdd__bbllkknnuumm)){{bbppttrr-->>rrdd__rreeffccnntt++++;;sseenndd((qqppttrr-->>rrdd__ppiidd,,((uuiinntt3322))bbppttrr));;//**UUnnlliinnkkrreeqquueessttffrroommqquueeuuee**//ppppttrr==qqppttrr-->>rrdd__pprreevv;;nnppttrr==qqppttrr-->>rrdd__nneexxtt;;ppppttrr-->>rrdd__nneexxtt==bbppttrr-->>rrdd__nneexxtt;;nnppttrr-->>rrdd__pprreevv==bbppttrr-->>rrdd__pprreevv;;//**MMoovveebbuuffffeerrttootthheeffrreeeelliisstt**//qqppttrr-->>rrdd__nneexxtt==rrddppttrr-->>rrdd__ffrreeee;;rrddppttrr-->>rrdd__ffrreeee==qqppttrr;;ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;bbrreeaakk;;}} qqppttrr==qqppttrr-->>rrdd__nneexxtt;;}} bbrreeaakk;;ccaasseeRRDD__OOPP__WWRRIITTEE:://**BBuuiillddaawwrriitteerreeqquueessttmmeessssaaggeeffoorrtthheesseerrvveerr**//mmssgg..rrdd__ttyyppee==hhttoonnss((RRDD__MMSSGG__WWRREEQQ));;//**WWrriitteerreeqquueesstt**//mmssgg..rrdd__bbllkk==bbppttrr-->>rrdd__bbllkknnuumm;;452 A Remote Disk Driver Chap. 18mmssgg..rrdd__ssttaattuuss==hhttoonnss((00));;mmssgg..rrdd__sseeqq==00;;//**RRddssccoommbbffiillllssiinnaanneennttrryy**//iiddttoo==mmssgg..rrdd__iidd;;mmeemmsseett((iiddttoo,,NNUULLLLCCHH,,RRDD__IIDDLLEENN));;//**IInniittiiaalliizzeeIIDDttoozzeerroo**//iiddffrroomm==rrddppttrr-->>rrdd__iidd;;wwhhiillee((((**iiddttoo++++==**iiddffrroomm++++))!!==NNUULLLLCCHH)){{//**CCooppyyIIDD**//;;}} ffoorr((ii==00;;ii<<RRDD__BBLLKKSSIIZZ;;ii++++)){{mmssgg..rrdd__ddaattaa[[ii]]==bbppttrr-->>rrdd__bblloocckk[[ii]];;}} //**UUnnlliinnkkbbuuffffeerrffrroommrreeqquueessttqquueeuuee**//nnppttrr==bbppttrr-->>rrdd__nneexxtt;;ppppttrr==bbppttrr-->>rrdd__pprreevv;;ppppttrr-->>rrdd__nneexxtt==nnppttrr;;nnppttrr-->>rrdd__pprreevv==ppppttrr;;//**IInnsseerrttbbuuffffeerriinntthheeccaacchhee**//ppppttrr==((ssttrruuccttrrddbbuuffff**))&&rrddppttrr-->>rrdd__cchhnneexxtt;;nnppttrr==ppppttrr-->>rrdd__nneexxtt;;bbppttrr-->>rrdd__nneexxtt==nnppttrr;;bbppttrr-->>rrdd__pprreevv==ppppttrr;;ppppttrr-->>rrdd__nneexxtt==bbppttrr;;nnppttrr-->>rrdd__pprreevv==bbppttrr;;//**DDeeccllaarreetthhaattbbuuffffeerriisseelliiggiibblleeffoorrrreeuussee**//bbppttrr-->>rrdd__rreeffccnntt==00;;ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;//**SSeennddtthheemmeessssaaggeeaannddrreecceeiivveeaarreessppoonnssee**//rreettvvaall==rrddssccoommmm((((ssttrruuccttrrdd__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__wwrreeqq)),,((ssttrruuccttrrdd__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrdd__mmssgg__wwrreess)),,rrddppttrr));;//**CChheecckkrreessppoonnssee**//iiff((((rreettvvaall====SSYYSSEERRRR))||||((rreettvvaall====TTIIMMEEOOUUTT))||||((nnttoohhss((rreesspp..rrdd__ssttaattuuss))!!==00)))){{Sec. 18.18        The Lower–half Communication Process (rdsprocess) 453ppaanniicc((""ffaaiilleeddttooccoonnttaaccttrreemmootteeddiisskksseerrvveerr""));;}} bbrreeaakk;;ccaasseeRRDD__OOPP__SSYYNNCC:://**SSeennddaammeessssaaggeettootthheewwaaiittiinnggpprroocceessss**//sseenndd((bbppttrr-->>rrdd__ppiidd,,OOKK));;//**UUnnlliinnkkbbuuffffeerrffrroommtthheerreeqquueessttqquueeuuee**//nnppttrr==bbppttrr-->>rrdd__nneexxtt;;ppppttrr==bbppttrr-->>rrdd__pprreevv;;nnppttrr-->>rrdd__pprreevv==bbppttrr-->>rrdd__pprreevv;;ppppttrr-->>rrdd__nneexxtt==bbppttrr-->>rrdd__nneexxtt;;//**IInnsseerrttbbuuffffeerriinnttootthheeffrreeeelliisstt**//bbppttrr-->>rrdd__nneexxtt==rrddppttrr-->>rrdd__ffrreeee;;rrddppttrr-->>rrdd__ffrreeee==bbppttrr;;ssiiggnnaall((rrddppttrr-->>rrdd__aavvaaiillsseemm));;bbrreeaakk;;}}}}}}When examining the code, remember that the remote disk process has higher prior-ity than any application process. Thus, the code does not need to disable interrupts oruse a mutual exclusion semaphore when accessing the request queue, cache, or free list. However, rdsprocess must leave all data structures in a valid state before using rdscomm to exchange messages with the server, because message reception blocks the calling process (which means other processes can run). In the case of a read operation, rdsprocess leaves the buffer on the request queue until the request can be satisfied. In the case of a write operation, rdsprocess extracts a copy of the data and moves the buffer to the cache before calling rdscomm.18.19 PerspectiveConceptually, a remote disk system only needs to provide two basic operations: read a block and write a block. In practice, however, the issues of synchrony, caching, and sharing dominate the design. Our example simplifies most design decisions be-cause we assume a single Xinu system acts as a client. Thus, the client code manages454 A Remote Disk Driver Chap. 18its local cache, and does not need to coordinate with other Xinu systems. Similarly, the lack of sharing simplifies the question of synchrony: the client only needs local infor-mation to enforcelast-write semantics.If the system is extended to permit multiple Xinu systems to share a disk, the en-tire design must change. A given client cannot cache blocks unless the client coordi-nates with the server. Furthermore, last-write semantics must be enforced across all systems, which means read operations need a centralized mechanism to ensure that they occur in order. A tradeoff arises between sharing and efficiency because communica-tion is expensive. Relying on a centralized server to coordinate sharing eliminates cach-ing and imposes a much higher communication overhead. The point is:Extending the remote disk system to include sharing across multiple Xinu systems will result in significant changes to the structure of the system and a significant decrease in performance, especially during periods of simultaneous access.18.20 SummaryWe considered the design of a remote disk system in which an application can read and write disk blocks, and the driver uses a network to communicate with a remote server that performs the operation. The driver views a disk as an array of randomly ac-cessible data blocks, and does not provide files, directories, or any index techniques to speed searching. Reading consists of copying data from a specified block on disk into memory; writing consists of copying data from memory onto a specified disk block.Driver code is divided into upper-half functions that are called by application processes and a lower half that executes as a separate process. Input is synchronous; a process blocks until a request can be satisfied. Output is asynchronous; the driver ac-cepts an outgoing data block, enqueues the request, and returns to the caller immediate-ly without blocking. A process can use the control function to flush previous writes to disk.The driver uses three main data structures: a queue of requests, a cache of recently used blocks, and a free list. Although it relies on caching to make access efficient, our driver guarantees last-write semantics.EXERCISES18.1 Redesign the implementation to keep the buffers separate from the nodes used on the re-quest list and the cache (i.e., define nodes for each list and arrange for each node to havea pointer to a buffer). What are the advantages and disadvantages of each approach?Exercises45518.2 Redesign the remote disk system to use a “buffer exchange” paradigm in which applica-tions and driver functions share a single buffer pool. To write a disk block, arrange foran application to allocate a buffer, fill the buffer, and pass the buffer when calling write. Have read return a buffer pointer which the application must free once the data has been extracted.18.3     It is possible to configure a system with multiple remote disk devices. Modify the codein rdsopen to check each open remote disk device to ensure that a disk ID is unique.18.4 Build a version of a remote disk system that does not use a cache, and measure thedifference in performance of the two versions.18.5 Should requests from high-priority processes take precedence over requests from low-priority processes? Explain why or why not.18.6 Investigate other algorithms like the “elevator” algorithm that can be used to order diskrequests for an electro-mechanical disk.18.7 Verify that a request to “synchronize” will not return until all pending requests havebeen satisfied. Is there a bound on the time it can be delayed?18.8  Redesign the system to use two servers for redundancy. Copy each transaction to bothservers. How much overhead does the redundant implementation add?18.9 Build a remote disk server that allows simultaneous access by multiple client computersand multiple concurrent processes on each client. Plot performance as the number of simultaneous users increases.18.10    Some operating systems allow a disk to be divided into multiple partitions, where eachpartition has blocks numbered 0 through N–1 for some N. What is the advantage of par-titioning disks? Hint: consider the previous exercise.Chapter Contents19.1 What Is A File System?, 45919.2 An Example Set Of File Operations, 46019.3 Design Of A Local File System, 46119.4 Data Structures For The Xinu File System, 46119.5 Implementation Of The Index Manager, 46219.6 Clearing An Index Block (lfibclear), 46719.7 Retrieving An Index Block (lfibget), 46819.8 Storing An Index Block (lfibput), 46919.9 Allocating An Index Block From The Free List (lfiballoc), 47119.10 Allocating A Data Block From The Free List (lfdballoc), 472 19.11 Using The Device-Independent I/O Functions For Files, 474 19.12 File System Device Configuration And Function Names, 474 19.13 The Local File System Open Function (lfsopen), 47519.14 Closing A File Pseudo-Device (lflclose), 483 19.15 Flushing Data To Disk (lfflush), 48319.16 Bulk Transfer Functions For A File (lflwrite, lflread), 486 19.17 Seeking To A New Position In the File (lflseek), 48819.18 Extracting One Byte From A File (lflgetc), 489 19.19 Changing One Byte In A File (lflputc), 49019.20 Loading An Index Block And A Data Block (lfsetup), 492 19.21 Master File System Device Initialization (lfsinit), 49619.22 Pseudo-Device Initialization (lflinit), 497 19.23 File Truncation (lftruncate), 49919.24 Initial File System Creation (lfscreate), 501 19.25 Perspective, 50319.26 Summary, 50419File Systems
Filing is concerned with the past; anything youactually need to see again has to do with the future.— Katharine WhitehornThe previous chapter discusses a disk abstraction, and describes a hardware inter-face that allows the system to read and write individual blocks. Although disks havethe advantage of providing long-term, non-volatile storage, the block-oriented interfaceis cumbersome.This chapter introduces the file system abstraction. It shows how an operating sys-tem manages a set of dynamically changing file objects, and how the system maps files onto the underlying disk hardware.19.1 What Is A File System?A file system consists of software that manages permanent data objects whosevalues persist longer than the processes that create and use them. Permanent data iskept in files, which are stored on secondary storage devices, either solid state or elec-tromechanical disks. Files are organized into directories (also called folders). Concep-tually, each file consists of a sequence of data objects (e.g., a sequence of integers). The file system provides operations that create or delete a file, open a file given its name, read the next object from an open file, write an object onto an open file, or close a file. If a file system allows random access, the file interface also provides a way a process can seek to a specified location in a file.459460File Systems Chap. 19Many file systems offer more functionality than an interface that can access indivi-dual files on secondary storage — they provide an abstract namespace and high-level operations to manipulate objects in that space. The file namespace consists of the set of valid file names. A namespace can be as simple as “the set of strings formed from at least one but fewer than nine alphabetic characters,” or as complex as “the set of strings that form a valid encoding of the network, machine, user, subdirectory, and file identi-fiers in a specified syntax.” In some systems, the syntax of names in the abstract space conveys information about their type (e.g., text files end in “.txt”). In others, names give information about the organization of the file system (e.g., a file name that begins with the string “M1_d0:” might reside on disk 0 of machine 1). We will defer a discus-sion of file naming to Chapter 21, and concentrate on file access.19.2 An Example Set Of File OperationsOur example system uses a straightforward approach motivated by a desire to unify the interface between devices and files and to keep the file system software small. File semantics are taken from Unix according to the following principle:The file system considers each file to be a sequence of zero or more bytes; any further structure must be enforced by application programs that use the file.Treating a file as a sequence of bytes has several advantages. First, the file system does not impose a type on the file and does not need to distinguish among file types. Second, the code is small because a single set of file system functions suffices for all files. Third, the file semantics can be applied to devices and services as well as to con-ventional files. Fourth, application programs can choose an arbitrary structure for data without changing the underlying system. Finally, file contents are independent of the processor or memory (e.g., an application may need to distinguish among a 32-bit and 64-bit integer stored in a file, but the file system does not).Our system will use exactly the same high-level operations for files that are usedfor devices. Thus, the file system will support open, close, read, write, putc, getc, seek,init, and control functions. When applied to conventional files, the operations producethe following results.  Init initializes data structures at startup.  Opening a named file connects an executing process with the data on disk, and establishes a pointer to the first byte. Operations getc and read retrieve data from the file and advance the pointer; getc retrieves one byte, and read can retrieve multiple bytes. Operations putc and write change bytes in the file and move the pointer along, extending the file length if new data is written beyond the end; putc changes one byte, and write can change multiple bytes. The seek operation moves the pointer to a specified byte position in the file; the first byte is at position zero. Finally, close detaches the running process from the file, leaving the data in the file on permanent storage.Sec. 19.3        Design Of A Local File System 46119.3 Design Of A Local File SystemA file is said to be local to a given computer if the file resides on a storage device that is attached to the computer. The design of software that manages such files is non-trivial; it has been the subject of much research. Although the file operations may seem straightforward, complexity arises because files are dynamic. That is, a single disk can hold multiple files, and a given file can grow arbitrarily large (until disk space is ex-hausted). To permit dynamic file growth, a system cannot pre-allocate disk blocks for a file. Thus, dynamic data structures are needed.A second form of complexity arises from concurrency. To what extent should the system support concurrent file operations? Large systems usually allow arbitrary numbers of processes to read and write arbitrary numbers of files concurrently. Thechief difficulty with multiple access lies in specifying exactly what it means to have multiple processes writing and reading a file at the same time. When will data become available for reading? If two processes attempt to write to the same data byte in the file, which will be accepted? Can a process lock pieces of a file to avoid interference?The generality of allowing multiple processes to read and write a file is usually not necessary on small embedded systems. Thus, to limit the software complexity and make better use of disk space, small systems can constrain the ways in which files canbe accessed. They may limit the number of files that a given process can access simul-taneously, or limit the number of processes that can access a given file simultaneously.Our goal is to design efficient, compact file system software that allows processes to create and extend files dynamically without incurring unnecessary overhead. As a compromise between generality and efficiency, we will allow a process to open an arbi-trary number of files until resources are exhausted. However, the system limits a file to one active open. That is, if a file is open, successive requests to open the file (e.g., re-quests by other processes) will fail until the file has been closed. Each file has a mutual exclusion semaphore to guarantee that only one process at a time can attempt to write a byte to the file, read a byte from the file, or change the current file position. Further-more, the directory has a mutual exclusion semaphore to guarantee that only one proc-ess at a time can attempt to create a file or otherwise change a directory entry. Although concurrency requires attention to detail, the most significant consequence of our design arises from its support for dynamic file growth: data structures will be need-ed to allocate space on a disk dynamically. The next section explains the data struc-tures used.19.4 Data Structures For The Xinu File SystemTo support dynamic growth and random access, the Xinu file system allocates disk blocks dynamically and uses an index mechanism to locate the data in a given filequickly. The design partitions a disk into three separate areas as Figure 19.1 illustrates: a directory, anindex area, and a data area.462File Systems Chap. 19dir.indexdata areaFigure 19.1Illustration of a disk partitioned into three areas for the Xinu filesystem.The first sector of the disk holds a directory that contains a list of file names along with a pointer to the list of index blocks for the file. The directory also contains two other pointers: one to a list of free (unused) index blocks and another to a list of freedata blocks. The directory entry for a file also contains an integer that gives the current size of the file measured in bytes.Following the directory, the disk contains an index area that holds a set of index blocks, abbreviated i-blocks. Each file has its own index, which consists of a singly-linked list of index blocks. Initially, all index blocks are linked onto a free list from which the system allocates one as needed; index blocks are only returned to the free listif a file is truncated or deleted.Following the index area, remaining blocks of the disk comprise a data area. Each block in the data area is referred to as a data block, abbreviated d-block, because a block contains data that has been stored in a file. Once a data block has been allocated to a file, the block only can contain data. A data block does not contain pointers to oth-er data blocks, nor does it contain information that relates the block to the file of whichit is a part; all such information resides in the file’s index.Similar to index blocks, when a disk is initialized, the data blocks are linked onto afree list. The file system allocates data blocks from the free list as needed, and returnsdata blocks to the free list when a file is truncated or deleted.Figure 19.2 illustrates the conceptual data structure used for a Xinu file system. The figure is not drawn to scale: in practice a data block is much larger than an index block and occupies one physical disk block. The important idea is that the data struc-ture illustrated in the figure resides on disk. We will see that at any given time, only a few pieces of the structure are present in memory — the file system must create and maintain an index without reading the structure into memory.19.5 Implementation Of The Index ManagerConceptually index blocks form a randomly accessible array that is mapped onto a contiguous area of the disk. Thus, index blocks are numbered from zero through K, and the software uses the number to refer to a given index block. Because an index block is smaller than a physical disk block, the system stores seven index blocks into each phys-ical block, and the software handles the details of reading and writing an individual in-dex block.Sec. 19.5        Implementation Of The Index Manager 463...index block...index block...index block...index block...index block...index blockfilename 1 filename 2. . .directory
16 data blocksFigure 19.2Illustration of the Xinu file system, where each file consists of alinked list of index blocks that each contain pointers to data blocks.Because the underlying hardware can only transfer an entire disk block at a time, the file system cannot transfer an individual index block without transferring others that reside in the same physical disk block. Therefore, to write an index block, the software must read the entire physical disk block in which it resides, copy the new index block into the correct position, and write the resulting physical block back to disk. Similarly, to read an index block, the software must read the physical disk block in which it re-sides, and then extract the index block.Before we examine the code to handle index blocks, we need to understand basic definitions. File lfilesys.h defines constants and data structures used throughout the lo-cal file system, including struct lfiblk which defines the contents of an index block. Asthe file shows, each index block contains a pointer to the next index block, an offset that specifies the lowest position in the file indexed by the block, and an array of sixteen pointers to data blocks. That is, each entry in the array gives the physical disk sector number of a data block. Because a sector is 512 bytes long, a single index block indexes sixteen 512-byte blocks or 8192 bytes of data.How does the software know where to find an index block given its address? In-dex blocks are contiguous, and occupy contiguous disk sectors starting at sectorLF_AREA_IB. In our design, the directory occupies disk block zero, which means thatthe index area starts at sector one. Thus, index blocks zero through six lie in sectorone, seven through thirteen lie in sector two, and so on. Inline function ib2sect convertsan index block number into the correct sector number, and inline function ib2disp con-verts an index block number to a byte displacement within a physical disk block. Both functions can be found in file lfilesys.h.464File Systems Chap. 19//**llffiilleessyyss..hh--iibb22sseecctt,,iibb22ddiisspp**////************************************************************************************************************************************************////** **////**LLooccaallFFiilleeSSyysstteemmDDaattaaSSttrruuccttuurreess**////** **////**AAllooccaallffiilleessyysstteemmuusseessaarraannddoomm--aacccceessssddiisskkccoommppoosseeddooff551122--bbyyttee**////**sseeccttoorrssnnuummbbeerreedd00tthhrroouugghhNN--11..WWeeaassssuummeeddiisskkhhaarrddwwaarreeccaannrreeaaddoorr**////**wwrriitteeaannyysseeccttoorraattrraannddoomm,,bbuuttmmuussttttrraannssffeerraanneennttiirreesseeccttoorr..**////**TThhuuss,,ttoowwrriitteeaaffeewwbbyytteess,,tthheeffiilleessyysstteemmmmuussttrreeaaddtthheesseeccttoorr,,**////**rreeppllaacceetthheebbyytteess,,aannddtthheennwwrriitteetthheesseeccttoorrbbaacckkttooddiisskk..XXiinnuu’’ss**////**llooccaallffiilleessyysstteemmddiivviiddeesstthheeddiisskkaassffoolllloowwss::sseeccttoorr00iissaa**////**ddiirreeccttoorryy,,tthheenneexxttKKsseeccttoorrssccoonnssttiittuutteeaanniinnddeexxaarreeaa,,aannddtthhee**////**rreemmaaiinniinnggsseeccttoorrssccoommpprriisseeaaddaattaaaarreeaa..TThheeddaattaaaarreeaaiisseeaassiieessttttoo**////**uunnddeerrssttaanndd::eeaacchhsseeccttoorrhhoollddssoonneeddaattaabblloocckk((dd--bblloocckk))tthhaattssttoorreess**////**ccoonntteennttssffrroommoonneeoofftthheeffiilleess((oorriissoonnaaffrreeeelliissttooffuunnuusseeddddaattaa**////**bblloocckkss))..WWeetthhiinnkkoofftthheeiinnddeexxaarreeaaaasshhoollddiinnggaannaarrrraayyooffiinnddeexx**////**bblloocckkss((ii--bblloocckkss))nnuummbbeerreedd00tthhrroouugghhII--11..AAggiivveennsseeccttoorriinntthhee**////**iinnddeexxaarreeaahhoollddss77oofftthheeiinnddeexxbblloocckkss,,wwhhiicchhaarreeeeaacchh7722bbyytteess**////**lloonngg..GGiivveennaannii--bblloocckknnuummbbeerr,,tthheeffiilleessyysstteemmmmuussttccaallccuullaatteetthhee**////**ddiisskksseeccttoorriinnwwhhiicchhtthheeii--bblloocckkiissllooccaatteeddaannddtthheebbyytteeooffffsseett**////**wwiitthhiinntthheesseeccttoorraattwwhhiicchhtthheeii--bblloocckkrreessiiddeess..IInntteerrnnaallllyy,,aaffiillee**////**iisskknnoowwnnbbyytthheeii--bblloocckkiinnddeexxoofftthheeffiirrssttii--bblloocckkffoorrtthheeffiillee..**////**TThheeddiirreeccttoorryyccoonnttaaiinnssaalliissttooffffiilleennaammeessaannddtthheeii--bblloocckknnuummbbeerr**////**oofftthheeffiirrssttii--bblloocckkffoorrtthheeffiillee..TThheeddiirreeccttoorryyaallssoohhoollddsstthhee**////**ii--bblloocckknnuummbbeerrffoorraalliissttooffffrreeeeii--bblloocckkssaannddaaddaattaabblloocckknnuummbbeerr**////**oofftthheeffiirrssttddaattaabblloocckkoonnaalliissttooffffrreeeeddaattaabblloocckkss..**////** **////************************************************************************************************************************************************//##iiffnnddeeffNNllffll##ddeeffiinneeNNllffll11##eennddiiff//**UUsseetthheerreemmootteeddiisskkddeevviicceeiiffnnooddiisskkiissddeeffiinneedd((ffiilleessyysstteemm**////****aassssuummeess**tthheeuunnddeerrllyyiinnggddiisskkhhaassaabblloocckkssiizzeeooff551122bbyytteess))**//##iiffnnddeeffLLFF__DDIISSKK__DDEEVV##ddeeffiinneeLLFF__DDIISSKK__DDEEVVSSYYSSEERRRR##eennddiiff##ddeeffiinneeLLFF__MMOODDEE__RRFF__MMOODDEE__RR//**MMooddeebbiittffoorr""rreeaadd""**//##ddeeffiinneeLLFF__MMOODDEE__WWFF__MMOODDEE__WW//**MMooddeebbiittffoorr""wwrriittee""**//##ddeeffiinneeLLFF__MMOODDEE__RRWWFF__MMOODDEE__RRWW//**MMooddeebbiittssffoorr""rreeaaddoorrwwrriittee""**//Sec. 19.5        Implementation Of The Index Manager 465##ddeeffiinneeLLFF__MMOODDEE__OOFF__MMOODDEE__OO//**MMooddeebbiittffoorr""oolldd""**//##ddeeffiinneeLLFF__MMOODDEE__NNFF__MMOODDEE__NN//**MMooddeebbiittffoorr""nneeww""**//##ddeeffiinneeLLFF__BBLLKKSSIIZZ551122//**AAssssuummeess551122--bbyytteeddiisskkbblloocckkss**//##ddeeffiinneeLLFF__NNAAMMEE__LLEENN1166//**LLeennggtthhooffnnaammeepplluussnnuullll**//##ddeeffiinneeLLFF__NNUUMM__DDIIRR__EENNTT2200//**NNuumm..ooffffiilleessiinnaaddiirreeccttoorryy**//##ddeeffiinneeLLFF__FFRREEEE00//**SSllaavveeddeevviicceeiissaavvaaiillaabbllee**//##ddeeffiinneeLLFF__UUSSEEDD11//**SSllaavveeddeevviicceeiissiinnuussee**//##ddeeffiinneeLLFF__IINNUULLLL((iibbiidd3322))--11//**IInnddeexxbblloocckknnuullllppooiinntteerr**//##ddeeffiinneeLLFF__DDNNUULLLL((ddbbiidd3322))--11//**DDaattaabblloocckknnuullllppooiinntteerr**//##ddeeffiinneeLLFF__IIBBLLEENN1166//**DDaattaabblloocckkppttrrssppeerrii--bblloocckk**//##ddeeffiinneeLLFF__IIDDAATTAA88119922//**BByytteessooffddaattaaiinnddeexxeeddbbyyaa**////**ssiinngglleeiinnddeexxbblloocckk**//##ddeeffiinneeLLFF__IIMMAASSKK00xx0000000011ffffff//**MMaasskkffoorrtthheeddaattaaiinnddeexxeeddbbyy**////**oonneeiinnddeexxbblloocckk((ii..ee..,,**////**bbyytteess00tthhrroouugghh88119911))..**//##ddeeffiinneeLLFF__DDMMAASSKK00xx000000000011ffff//**MMaasskkffoorrtthheeddaattaaiinnaaddaattaa**////**bblloocckk((00tthhrroouugghh551111))**//##ddeeffiinneeLLFF__AARREEAA__IIBB11//**FFiirrssttsseeccttoorrooffii--bblloocckkss**//##ddeeffiinneeLLFF__AARREEAA__DDIIRR00//**FFiirrssttsseeccttoorrooffddiirreeccttoorryy**////**SSttrruuccttuurreeooffaanniinnddeexxbblloocckkoonnddiisskk**//ssttrruuccttllffiibbllkk{{//**FFoorrmmaattooffiinnddeexxbblloocckk**//iibbiidd3322iibb__nneexxtt;;//**AAddddrreessssooffnneexxttiinnddeexxbblloocckk**//uuiinntt3322iibb__ooffffsseett;;//**FFiirrssttddaattaabbyytteeoofftthheeffiillee**////**IInnddeexxeeddbbyytthhiissii--bblloocckk**//ddbbiidd3322iibb__ddbbaa[[LLFF__IIBBLLEENN]];;//**PPttrrssttooddaattaabblloocckkssiinnddeexxeedd**//}};;//**CCoonnvveerrssiioonnffuunnccttiioonnssbbeelloowwaassssuummee77iinnddeexxbblloocckkssppeerrddiisskkbblloocckk**////**CCoonnvveerrssiioonnbbeettwweeeenniinnddeexxbblloocckknnuummbbeerraannddddiisskksseeccttoorrnnuummbbeerr**//##ddeeffiinneeiibb22sseecctt((iibb))((((((iibb))//77))++LLFF__AARREEAA__IIBB))//**CCoonnvveerrssiioonnbbeettwweeeenniinnddeexxbblloocckknnuummbbeerraannddtthheerreellaattiivveeooffffsseettwwiitthhiinn**////**aaddiisskksseeccttoorr**//##ddeeffiinneeiibb22ddiisspp((iibb))((((((iibb))%%77))**ssiizzeeooff((ssttrruuccttllffiibbllkk))))466File Systems Chap. 19//**SSttrruuccttuurreeuusseeddiinneeaacchhddiirreeccttoorryyeennttrryyffoorrtthheellooccaallffiilleessyysstteemm**//ssttrruuccttllddeennttrryy{{//**DDeessccrriippttiioonnooffeennttrryyffoorroonnee**////**ffiilleeiinntthheeddiirreeccttoorryy**//uuiinntt3322lldd__ssiizzee;;//**CCuurrrr..ssiizzeeooffffiilleeiinnbbyytteess**//iibbiidd3322lldd__iilliisstt;;//**IIDDooffffiirrssttii--bblloocckkffoorrffiillee**////**oorrIIBB__NNUULLLLffoorreemmppttyyffiillee**//cchhaarrlldd__nnaammee[[LLFF__NNAAMMEE__LLEENN]];;//**NNuullll--tteerrmmiinnaatteeddffiilleennaammee**//}};;//**SSttrruuccttuurreeooffaaddaattaabblloocckkwwhheennoonntthheeffrreeeelliissttoonnddiisskk**//ssttrruuccttllffddbbffrreeee{{ddbbiidd3322llff__nneexxttddbb;;//**NNeexxttddaattaabblloocckkoonntthheelliisstt**//cchhaarrllff__uunnuusseedd[[LLFF__BBLLKKSSIIZZ--ssiizzeeooff((ddbbiidd3322))]];;}};;//**FFoorrmmaattoofftthheeffiilleessyysstteemmddiirreeccttoorryy,,eeiitthheerroonnddiisskkoorriinnmmeemmoorryy**//##pprraaggmmaappaacckk((22))ssttrruuccttllffddiirr{{//**EEnnttiirreeddiirreeccttoorryyoonnddiisskk**//ddbbiidd3322llffdd__ddffrreeee;;//**LLiissttooffffrreeeedd--bblloocckkssoonnddiisskk**//iibbiidd3322llffdd__iiffrreeee;;//**LLiissttooffffrreeeeii--bblloocckkssoonnddiisskk**//iinntt3322llffdd__nnffiilleess;;//**CCuurrrreennttnnuummbbeerrooffffiilleess**//ssttrruuccttllddeennttrryyllffdd__ffiilleess[[LLFF__NNUUMM__DDIIRR__EENNTT]];;//**SSeettooffffiilleess**//cchhaarrppaaddddiinngg[[2200]];;//**UUnnuusseeddcchhaarrssiinnddiirreeccttoorryybbllkk**//}};;##pprraaggmmaappaacckk(())//**GGlloobbaallddaattaauusseeddbbyyllooccaallffiilleessyysstteemm**//ssttrruuccttllffddaattaa{{//**LLooccaallffiilleessyysstteemmddaattaa**//ddiidd3322llff__ddsskkddeevv;;//**DDeevviicceeIIDDooffddiisskkttoouussee**//ssiidd3322llff__mmuutteexx;;//**MMuutteexxffoorrtthheeddiirreeccttoorryyaanndd**////**iinnddeexx//ddaattaaffrreeeelliissttss**//ssttrruuccttllffddiirrllff__ddiirr;;//**IInn--mmeemmoorryyccooppyyooffddiirreeccttoorryy**//bbooooll88llff__ddiirrpprreesseenntt;;//**TTrruueewwhheennddiirreeccttoorryyiissiinn**////**mmeemmoorryy((11ssttffiilleeiissooppeenn))**//bbooooll88llff__ddiirrddiirrttyy;;//**HHaasstthheeddiirreeccttoorryycchhaannggeedd??**//}};;//**CCoonnttrroollbblloocckkffoorrllooccaallffiilleeppsseeuuddoo--ddeevviiccee**//ssttrruuccttllffllccbbllkk{{//**LLooccaallffiilleeccoonnttrroollbblloocckk**////**((oonneeffoorreeaacchhooppeennffiillee))**//Sec. 19.5        Implementation Of The Index Manager 467bbyytteellffssttaattee;;//**IIsseennttrryyffrreeeeoorruusseedd**//ddiidd3322llffddeevv;;//**DDeevviicceeIIDDoofftthhiissddeevviiccee**//ssiidd3322llffmmuutteexx;;//**MMuutteexxffoorrtthhiissffiillee**//ssttrruuccttllddeennttrryy**llffddiirrppttrr;;//**PPttrrttooffiillee’’sseennttrryyiinntthhee**////**iinn--mmeemmoorryyddiirreeccttoorryy**//iinntt3322llffmmooddee;;//**MMooddee((rreeaadd//wwrriittee//bbootthh))**//uuiinntt3322llffppooss;;//**BByytteeppoossiittiioonnooffnneexxttbbyyttee**////**ttoorreeaaddoorrwwrriittee**//cchhaarrllffnnaammee[[LLFF__NNAAMMEE__LLEENN]];;//**NNaammeeoofftthheeffiillee**//iibbiidd3322llffiinnuumm;;//**IIDDooffccuurrrreennttiinnddeexxbblloocckkiinn**////**llffiibblloocckkoorrLLFF__IINNUULLLL**//ssttrruuccttllffiibbllkkllffiibblloocckk;;//**IInn--mmeemmccooppyyooffccuurrrreennttiinnddeexx**////**bblloocckk**//ddbbiidd3322llffddnnuumm;;//**NNuummbbeerrooffccuurrrreennttddaattaabblloocckk**////**iinnllffddbblloocckkoorrLLFF__DDNNUULLLL**//cchhaarrllffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;//**IInn--mmeemmccooppyyooffccuurrrreennttddaattaa**////**bblloocckk**//cchhaarr**llffbbyyttee;;//**PPttrrttoobbyytteeiinnllffddbblloocckkoorr**////**aaddddrreessssoonneebbeeyyoonnddllffddbblloocckk**////**iiffccuurrrreennttffiilleeppoosslliieess**////**oouuttssiiddeellffddbblloocckk**//bbooooll88llffiibbddiirrttyy;;//**HHaassllffiibblloocckkcchhaannggeedd??**//bbooooll88llffddbbddiirrttyy;;//**HHaassllffddbblloocckkcchhaannggeedd??**//}};;eexxtteerrnnssttrruuccttllffddaattaaLLff__ddaattaa;;eexxtteerrnnssttrruuccttllffllccbbllkkllffllttaabb[[]];;//**CCoonnttrroollffuunnccttiioonnss**//##ddeeffiinneeLLFF__CCTTLL__DDEELLFF__CCTTLL__DDEELL//**DDeelleetteeaaffiillee**//##ddeeffiinneeLLFF__CCTTLL__TTRRUUNNCCFF__CCTTLL__TTRRUUNNCC//**TTrruunnccaatteeaaffiillee**//##ddeeffiinneeLLFF__CCTTLL__SSIIZZEEFF__CCTTLL__SSIIZZEE//**OObbttaaiinntthheessiizzeeooffaaffiillee**//19.6 Clearing An Index Block (lfibclear)Whenever it allocates an index block from the free list, the file system must read the index block into memory and clear the block to remove old information. In particu-lar, all data block pointers must be set to a null value, so they will not be confused with valid pointers. Furthermore, the offset in the index block must be assigned the ap-propriate offset in the file. Function lfibclear clears an index block; file lfibclear.c con-tains the code.468File Systems Chap. 19//**llffiibbcclleeaarr..cc--llffiibbcclleeaarr**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffiibbcclleeaarr----CClleeaarraanniinn--ccoorreeccooppyyooffaanniinnddeexxbblloocckk**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddllffiibbcclleeaarr((ssttrruuccttllffiibbllkk**iibbppttrr,,//**AAddddrreessssooffii--bblloocckkiinnmmeemmoorryy**//iinntt3322ooffffsseett//**FFiilleeooffffsseettffoorrtthhiissii--bblloocckk**//)){{iinntt3322ii;;//**IInnddeexxffoorrddaattaabblloocckkaarrrraayy**//iibbppttrr-->>iibb__ooffffsseett==ooffffsseett;;//**AAssssiiggnnssppeecciiffiieeddffiilleeooffffsseett**//ffoorr((ii==00;;ii<<LLFF__IIBBLLEENN;;ii++++)){{//**CClleeaarreeaacchhddaattaabblloocckkppooiinntteerr**//iibbppttrr-->>iibb__ddbbaa[[ii]]==LLFF__DDNNUULLLL;;}} iibbppttrr-->>iibb__nneexxtt==LLFF__IINNUULLLL;;//**SSeettnneexxttppttrrttoonnuullll**//rreettuurrnn;;}}19.7 Retrieving An Index Block (lfibget)To read an index block into memory, the system must map the index block number to a physical disk block address, read the physical disk block, and copy the appropriate area from the physical block into the specified memory location. File lfibget.c contains the code, which uses inline function ib2sect to convert the index block number to a disk sector, and function ib2disp to compute the location of the index block within the disk sector.//**llffiibbggeett..cc--llffiibbggeett**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffiibbggeett--GGeettaanniinnddeexxbblloocckkffrroommddiisskkggiivveenniittssnnuummbbeerr((aassssuummeess**mmuutteexxiisshheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddllffiibbggeett((ddiidd3322ddiisskkddeevv,,//**DDeevviicceeIIDDooffddiisskkttoouussee**//Sec. 19.7        Retrieving An Index Block (lfibget) 469iibbiidd3322iinnuumm,,//**IIDDooffiinnddeexxbblloocckkttooffeettcchh**//ssttrruuccttllffiibbllkk**iibbuuffff//**BBuuffffeerrttoohhoollddiinnddeexxbblloocckk**//)){{cchhaarr**ffrroomm,,**ttoo;;//**PPooiinntteerrssuusseeddiinnccooppyyiinngg**//iinntt3322ii;;//**LLooooppiinnddeexxuusseedddduurriinnggccooppyy**//cchhaarrddbbuuffff[[LLFF__BBLLKKSSIIZZ]];;//**BBuuffffeerrttoohhoollddddiisskkbblloocckk**////**RReeaaddddiisskkbblloocckktthhaattccoonnttaaiinnsstthheessppeecciiffiieeddiinnddeexxbblloocckk**//rreeaadd((ddiisskkddeevv,,ddbbuuffff,,iibb22sseecctt((iinnuumm))));;//**CCooppyyssppeecciiffiieeddiinnddeexxbblloocckkttooccaalllleerr’’ssiibbuuffff**//ffrroomm==ddbbuuffff++iibb22ddiisspp((iinnuumm));;ttoo==((cchhaarr**))iibbuuffff;;ffoorr((ii==00;;ii<<ssiizzeeooff((ssttrruuccttllffiibbllkk));;ii++++))**ttoo++++==**ffrroomm++++;;rreettuurrnn;;}}19.8 Storing An Index Block (lfibput)Conceptually, we think of index blocks as occupying a giant array on disk. How-ever, changing an index block is much more complex than changing an element in an array for two reasons. First, because the file system does not keep a record of which items in an index block changed, the entire index block must be rewritten. Second, the disk abstraction only provides write capability for an entire sector at a time. However, an index block only occupies part of a sector.To write an index block without changing other items in the sector, the file system must read an entire disk sector from disk, copy bytes of the index block into the ap-propriate area, and then write the entire sector back to disk. File lfibput.c contains the code. Lfibput is given a disk device, an index block ID, and a buffer address as argu-ments. The code uses the same inline functions as lfibget to convert the index block ID to a disk sector and to find the byte displacement in the sector for the specified index block. It then calls read to read the appropriate disk block. It copies the index block from the caller’s buffer into the disk block, and calls write to write the entire disk block back to the disk.470File Systems Chap. 19//**llffiibbppuutt..cc--llffiibbppuutt**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffiibbppuutt--WWrriitteeaanniinnddeexxbblloocckkttooddiisskkggiivveenniittssIIDD((aassssuummeess**mmuutteexxiisshheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussllffiibbppuutt((ddiidd3322ddiisskkddeevv,,//**IIDDooffddiisskkddeevviiccee**//iibbiidd3322iinnuumm,,//**IIDDooffiinnddeexxbblloocckkttoowwrriittee**//ssttrruuccttllffiibbllkk**iibbuuffff//**BBuuffffeerrhhoollddiinnggtthheeiinnddeexxbbllkk**//)){{ddbbiidd3322ddiisskkbblloocckk;;//**IIDDooffddiisskksseeccttoorr((bblloocckk))**//cchhaarr**ffrroomm,,**ttoo;;//**PPooiinntteerrssuusseeddiinnccooppyyiinngg**//iinntt3322ii;;//**LLooooppiinnddeexxuusseedddduurriinnggccooppyy**//cchhaarrddbbuuffff[[LLFF__BBLLKKSSIIZZ]];;//**TTeemmpp..bbuuffffeerrttoohhoolldddd--bblloocckk**////**CCoommppuutteeddiisskkbblloocckknnuummbbeerraannddooffffsseettooffiinnddeexxbblloocckk**//ddiisskkbblloocckk==iibb22sseecctt((iinnuumm));;ttoo==ddbbuuffff++iibb22ddiisspp((iinnuumm));;ffrroomm==((cchhaarr**))iibbuuffff;;//**RReeaaddddiisskkbblloocckk**//iiff((rreeaadd((ddiisskkddeevv,,ddbbuuffff,,ddiisskkbblloocckk))====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**CCooppyyiinnddeexxbblloocckkiinnttooppllaaccee**//ffoorr((ii==00;;ii<<ssiizzeeooff((ssttrruuccttllffiibbllkk));;ii++++)){{**ttoo++++==**ffrroomm++++;;}} //**WWrriitteetthheebblloocckkbbaacckkttooddiisskk**//wwrriittee((ddiisskkddeevv,,ddbbuuffff,,ddiisskkbblloocckk));;rreettuurrnnOOKK;;}}Sec. 19.9        Allocating An Index Block From The Free List (lfiballoc) 47119.9 Allocating An Index Block From The Free List (lfiballoc)The file system allocates an index block from the free list whenever it needs to ex-tend the index for a file. Function lfiballoc obtains the next free index block for thedisk, and returns its identifier. The code, which is found in file lfiballoc.c, assumes thata copy of the directory for the file system has been read into memory and placed in glo-bal variable Lf_data.lf_dir. Once the index block has been unlinked from the free list, the directory is written back to disk.//**llffiibbaalllloocc..cc--llffiibbaalllloocc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffiibbaalllloocc--AAllllooccaatteeaanneewwiinnddeexxbblloocckkffrroommffrreeeelliissttoonnddiisskk**((aassssuummeessddiirreeccttoorryymmuutteexxhheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//iibbiidd3322llffiibbaalllloocc((vvooiidd)){{iibbiidd3322iibbnnuumm;;//**IIDDooffnneexxttbblloocckkoonntthheeffrreeeelliisstt**//ssttrruuccttllffiibbllkkiibblloocckk;;//**BBuuffffeerrttoohhoollddaanniinnddeexxbblloocckk**////**GGeettIIDDooffffiirrssttiinnddeexxbblloocckkoonnffrreeeelliisstt**//iibbnnuumm==LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee;;iiff((iibbnnuumm====LLFF__IINNUULLLL)){{//**RRaannoouuttooffffrreeeeiinnddeexxbblloocckkss**//ppaanniicc((""oouuttooffiinnddeexxbblloocckkss""));;}} llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,,iibbnnuumm,,&&iibblloocckk));;//**UUnnlliinnkkiinnddeexxbblloocckkffrroommtthheeddiirreeccttoorryyffrreeeelliisstt**//LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee==iibblloocckk..iibb__nneexxtt;;//**WWrriitteeaaccooppyyoofftthheeddiirreeccttoorryyttooddiisskkaafftteerrtthheecchhaannggee**//wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr**))&&LLff__ddaattaa..llff__ddiirr,,LLFF__AARREEAA__DDIIRR));;LLff__ddaattaa..llff__ddiirrddiirrttyy==FFAALLSSEE;;rreettuurrnniibbnnuumm;;}}472File Systems Chap. 1919.10 Allocating A Data Block From The Free List (lfdballoc)Because an index block contains a “next” pointer field, linking them into a free list is straightforward. For data blocks, however, the free list is less obvious because a data block does not usually contain a pointer field. The Xinu design uses a singly-linked free list, which means that only one pointer is needed. When a data block is on the free list, the system uses the first four bytes of the data block to store a pointer to the next block on the list. Structure lfdbfree, found in file lfilesys.h above, defines the format of a block on the free list. Whenever it extracts a data block from the free list, the file system uses the structure definition. Of course, once a block has been removed from the free list and allocated to a file, the block is treated as an array of bytes.Function lfdballoc, which allocates a data block from the free list and returns the block number, illustrates how the system uses struct lfdbfree. The code can be found in file lfdballoc.c.//**llffddbbaalllloocc..cc--llffddbbaalllloocc**//##iinncclluuddee<<xxiinnuu..hh>>##ddeeffiinneeDDFFIILLLL’’++’’//**cchhaarraacctteerruusseeddttooffiillllaaddiisskkbblloocckk**////**------------------------------------------------------------------------------------------------------------------------------------------------**llffddbbaalllloocc--AAllllooccaatteeaanneewwddaattaabblloocckkffrroommffrreeeelliissttoonnddiisskk**((aassssuummeessddiirreeccttoorryymmuutteexxhheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ddbbiidd3322llffddbbaalllloocc((ssttrruuccttllffddbbffrreeee**ddbbuuffff//**AAddddrr..ooffbbuuffffeerrttoohhoollddddaattaabblloocckk**//)){{ddbbiidd3322ddnnuumm;;//**IIDDooffnneexxttdd--bblloocckkoonntthheeffrreeeelliisstt**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**////**GGeetttthheeIIDDooffffiirrssttddaattaabblloocckkoonntthheeffrreeeelliisstt**//ddnnuumm==LLff__ddaattaa..llff__ddiirr..llffdd__ddffrreeee;;iiff((ddnnuumm====LLFF__DDNNUULLLL)){{//**RRaannoouuttooffffrreeeeddaattaabblloocckkss**//ppaanniicc((""oouuttooffddaattaabblloocckkss""));;}} rreettvvaall==rreeaadd((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr**))ddbbuuffff,,ddnnuumm));;iiff((rreettvvaall====SSYYSSEERRRR)){{ppaanniicc((""llffddbbaallllooccccaannnnoottrreeaaddddiisskkbblloocckk\\nn\\rr""));;}}Sec. 19.10        Allocating A Data Block From The Free List (lfdballoc) 473//**UUnnlliinnkkdd--bblloocckkffrroommiinn--mmeemmoorryyddiirreeccttoorryy**//LLff__ddaattaa..llff__ddiirr..llffdd__ddffrreeee==ddbbuuffff-->>llff__nneexxttddbb;;wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr**))&&LLff__ddaattaa..llff__ddiirr,,LLFF__AARREEAA__DDIIRR));;LLff__ddaattaa..llff__ddiirrddiirrttyy==FFAALLSSEE;;//**FFiillllddaattaabblloocckkttooeerraasseeoollddddaattaa**//mmeemmsseett((((cchhaarr**))ddbbuuffff,,DDFFIILLLL,,LLFF__BBLLKKSSIIZZ));;rreettuurrnnddnnuumm;;}}A corresponding function, lfdbfree, found in file lfdbfree.c, returns a block to the free list. The code inserts a pointer into the first four bytes of a block, pointing to the current free list. It then makes the free list pointer in the directory point to the block. Both the data block and the directory must be written to disk after they have been changed.//**llffddbbffrreeee..cc--llffddbbffrreeee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffddbbffrreeee--FFrreeeeaaddaattaabblloocckkggiivveenniittssbblloocckknnuummbbeerr((aassssuummeess**ddiirreeccttoorryymmuutteexxiisshheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussllffddbbffrreeee((ddiidd3322ddiisskkddeevv,,//**IIDDooffddiisskkddeevviicceettoouussee**//ddbbiidd3322ddnnuumm//**IIDDooffddaattaabblloocckkttooffrreeee**//)){{ssttrruuccttllffddiirr**ddiirrppttrr;;//**PPooiinntteerrttooddiirreeccttoorryy**//ssttrruuccttllffddbbffrreeeebbuuff;;//**BBuuffffeerrttoohhoollddddaattaabblloocckk**//ddiirrppttrr==&&LLff__ddaattaa..llff__ddiirr;;bbuuff..llff__nneexxttddbb==ddiirrppttrr-->>llffdd__ddffrreeee;;ddiirrppttrr-->>llffdd__ddffrreeee==ddnnuumm;;wwrriittee((ddiisskkddeevv,,((cchhaarr**))&&bbuuff,,ddnnuumm));;wwrriittee((ddiisskkddeevv,,((cchhaarr**))ddiirrppttrr,,LLFF__AARREEAA__DDIIRR));;rreettuurrnnOOKK;;}}474File Systems Chap. 1919.11 Using The Device-Independent I/O Functions For FilesThe file system software must establish connections between running processes anddisk files to allow operations like read and write to be mapped onto the correct file.Exactly how the system performs this mapping depends on both the size and generality needed. To keep our system small, we avoid introducing new functions by reusing the device switch mechanisms that are already in place.Imagine that a set of file pseudo-devices has been added to the device switch table such that each pseudo-device can be used to control an open file. As with conventional devices, a pseudo-device has a set of driver functions that perform read, write, getc, putc, seek, and close operations. When a process opens a disk file, the file system searches for a currently unused pseudo-device, sets up the control block for the pseudo-device, and returns the ID of the pseudo-device to the caller. After the file has been opened, the process uses the device ID with operations getc, read, putc, write, and seek. The device switch table maps each high-level operation to the appropriate driver func-tion for file pseudo-devices exactly as it maps high-level operations onto device drivers for physical devices. Finally, when it finishes using a file, a process calls close to break the connection and make the pseudo-device available for use with another file. The de-tails will become clear as we review the code.Designing a pseudo-device driver is not unlike designing a device driver for a con-ventional hardware device. Just like other drivers, the pseudo-device driver creates a control block for each pseudo-device. The control block for a file pseudo-device uses struct lflcblk, which is defined in file lfilesys.h.† Conceptually, the control block con-tains two types of items: fields that hold information about the pseudo-device and fields that hold information from the disk. Fields lfstate and lfmode are the former type: the state field specifies whether the device is currently in use, and the mode field specifies whether the file has been opened for reading, writing, or both. Fields lfiblock and lfdblock are of the latter type: when a file is being read or written they contain a copy of the index block and the data block for the current position in the file measured in bytes (which is given by field lfpos).When a file is opened, the position (field lfpos in the control block) is assigned zero. As processes read or write data, the position increases. A process can call seek to move to an arbitrary position in the file, and lfpos is updated.19.12 File System Device Configuration And Function NamesWhat interface should be used to open a file and allocate a pseudo-device for read-ing and writing? One possible design adds a new file abstraction to the operating sys-tem. For, example, we can imagine a function fileopen that takes three arguments (adisk device, file name, and mode) and returns the descriptor of a pseudo-device for the file:ffdd==ffiilleeooppeenn((ddeevviiccee,,ffiilleennaammee,,mmooddee));;†File lfilesys.h can be found on page 464.Sec. 19.12        File System Device Configuration And Function Names 475In contrast with Unix, Xinu takes a device approach:In Unix, everything is a file; in Xinu, everything is a device.That is, Xinu tends to map many functions into the device space. The local file system follows the pattern by defining a master local file device, LFILESYS. Calling open on the master device causes the system to allocate a pseudo-device and return the device ID of the pseudo-device. File pseudo-devices are named LFILE0, LFILE1, ..., but the names are used only in the configuration file — a process receives the device descriptor of a pseudo-device when it opens the master device, but no process should call open on a pseudo-device. Figure 19.3 shows the types used to configure both the master and the local file pseudo-devices.//**LLooccaallFFiilleeSSyysstteemmmmaasstteerrddeevviicceettyyppee**//llffss::oonnddiisskk--iillffssiinniitt--oollffssooppeenn--cciiooeerrrr--rriiooeerrrr--ggiiooeerrrr--ppiiooeerrrr--wwiiooeerrrr--ssiiooeerrrr--nnrrffssccoonnttrrooll--iinnttrrNNUULLLL//**LLooccaallffiilleeppsseeuuddoo--ddeevviicceettyyppee**//llffll::oonnllffss--iillfflliinniitt--ooiiooeerrrr--ccllffllcclloossee--rrllffllrreeaadd--ggllffllggeettcc--ppllffllppuuttcc--wwllffllwwrriittee--ssllffllsseeeekk--nniiooeerrrr--iinnttrrNNUULLLLFigure 19.3Configuration types for a local file system master device and lo-cal file pseudo-devices.As the figure shows, driver functions for the master file system device have names that begin with lfs, and driver functions for a file pseudo-device have names that begin with lfl. We will see that support functions used by either set of driver functions have names that begin with lf.19.13 The Local File System Open Function (lfsopen)Figure 19.4 shows the configuration of the local file system master device and aset of seven local file pseudo-devices. Because a pseudo-device is used for each openfile, the number of local file pseudo-devices provides a bound on the number of filesthat can be opened simultaneously.476File Systems Chap. 19//**LLooccaallffiilleessyysstteemmmmaasstteerrddeevviiccee((oonneeppeerrssyysstteemm))**//LLFFIILLEESSYYSSiissllffssoonnddiisskk//**LLooccaallffiilleeppsseeuuddoo--ddeevviicceess((mmaannyyppeerrssyysstteemm))**//LLFFIILLEE00iissllfflloonnllffssLLFFIILLEE11iissllfflloonnllffssLLFFIILLEE22iissllfflloonnllffssLLFFIILLEE33iissllfflloonnllffssLLFFIILLEE44iissllfflloonnllffssLLFFIILLEE55iissllfflloonnllffssLLFFIILLEE66iissllfflloonnllffssFigure 19.4Configuration of a local file system master device and a set oflocal file pseudo-devices.A process uses the master device to open a local file, and then uses the pseudo-device to access the file. For example, to open a local file named myfile for reading and writing, a programmer codes:ffdd==ooppeenn((LLFFIILLEESSYYSS,,""mmyyffiillee"",,""rrww""));;Assuming the open succeeds, descriptor fd can be used to write data to the file, asin the following:cchhaarrbbuuffffeerr[[11550000]];;......ccooddeettooffiillllbbuuffffeerr......ffdd==wwrriittee((ffdd,,bbuuffffeerr,,11550000));;Device LFILESYS is only used to open a file. Therefore, the master file system de-vice driver only needs functions for open and init; all other I/O operations map to ioerr. Function lfsopen performs the open operation; the code can be found in file lfsopen.c.//**llffssooppeenn..cc--llffssooppeenn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffssooppeenn--OOppeennaaffiilleeaannddaallllooccaatteeaallooccaallffiilleeppsseeuuddoo--ddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffssooppeenn((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**nnaammee,,//**NNaammeeooffffiilleettooooppeenn**//cchhaarr**mmooddee//**MMooddeecchhaarrss::’’rr’’’’ww’’’’oo’’’’nn’’**//))Sec. 19.13        The Local File System Open Function (lfsopen) 477{{ssttrruuccttllffddiirr**ddiirrppttrr;;//**PPttrrttooiinn--mmeemmoorryyddiirreeccttoorryy**//cchhaarr**ffrroomm,,**ttoo;;//**PPttrrssuusseedddduurriinnggccooppyy**//cchhaarr**nnaamm,,**ccmmpp;;//**PPttrrssuusseedddduurriinnggccoommppaarriissoonn**//iinntt3322ii;;//**GGeenneerraallllooooppiinnddeexx**//ddiidd3322llffnneexxtt;;//**MMiinnoorrnnuummbbeerrooffaannuunnuusseedd**////**ffiilleeppsseeuuddoo--ddeevviiccee**//ssttrruuccttllddeennttrryy**llddppttrr;;//**PPttrrttooaanneennttrryyiinnddiirreeccttoorryy**//ssttrruuccttllffllccbbllkk**llffppttrr;;//**PPttrrttooooppeennffiilleettaabblleeeennttrryy**//bbooooll88ffoouunndd;;//**WWaasstthheennaammeeffoouunndd??**//iinntt3322rreettvvaall;;//**VVaalluueerreettuurrnneeddffrroommffuunnccttiioonn**//iinntt3322mmbbiittss;;//**MMooddeebbiittss**////**CChheecckklleennggtthhooffnnaammeeffiillee((lleeaavviinnggssppaacceeffoorrNNUULLLLCCHH**//ffrroomm==nnaammee;;ffoorr((ii==00;;ii<<LLFF__NNAAMMEE__LLEENN;;ii++++)){{iiff((**ffrroomm++++====NNUULLLLCCHH)){{bbrreeaakk;;}}}} iiff((ii>>==LLFF__NNAAMMEE__LLEENN)){{//**NNaammeeiissttoooolloonngg**//rreettuurrnnSSYYSSEERRRR;;}} //**PPaarrsseemmooddeeaarrgguummeennttaannddccoonnvveerrttttoobbiinnaarryy**//mmbbiittss==llffggeettmmooddee((mmooddee));;iiff((mmbbiittss====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**IIffnnaammeeddffiilleeiissaallrreeaaddyyooppeenn,,rreettuurrnnSSYYSSEERRRR**//llffnneexxtt==SSYYSSEERRRR;;ffoorr((ii==00;;ii<<NNllffll;;ii++++)){{//**SSeeaarrcchhffiilleeppsseeuuddoo--ddeevviicceess**//llffppttrr==&&llffllttaabb[[ii]];;iiff((llffppttrr-->>llffssttaattee====LLFF__FFRREEEE)){{iiff((llffnneexxtt====SSYYSSEERRRR)){{llffnneexxtt==ii;;//**RReeccoorrddiinnddeexx**//}} ccoonnttiinnuuee;;}}478File Systems Chap. 19//**CCoommppaarreerreeqquueesstteeddnnaammeettoonnaammeeooffooppeennffiillee**//nnaamm==nnaammee;;ccmmpp==llffppttrr-->>llffnnaammee;;wwhhiillee((**nnaamm!!==NNUULLLLCCHH)){{iiff((**nnaamm!!==**ccmmpp)){{bbrreeaakk;;}} nnaamm++++;;ccmmpp++++;;}} //**SSeeeeiiffccoommppaarriissoonnssuucccceeeeddeedd**//iiff((((**nnaamm====NNUULLLLCCHH))&&&&((**ccmmpp====NNUULLLLCCHH)))){{rreettuurrnnSSYYSSEERRRR;;}}}} iiff((llffnneexxtt====SSYYSSEERRRR)){{//**NNoossllaavveeffiilleeddeevviicceessaarreeaavvaaiillaabbllee**//rreettuurrnnSSYYSSEERRRR;;}} //**OObbttaaiinnccooppyyooffddiirreeccttoorryyiiffnnoottaallrreeaaddyypprreesseennttiinnmmeemmoorryy**//ddiirrppttrr==&&LLff__ddaattaa..llff__ddiirr;;wwaaiitt((LLff__ddaattaa..llff__mmuutteexx));;iiff((!!LLff__ddaattaa..llff__ddiirrpprreesseenntt)){{rreettvvaall==rreeaadd((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr**))ddiirrppttrr,,LLFF__AARREEAA__DDIIRR));;iiff((rreettvvaall====SSYYSSEERRRR)){{ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} LLff__ddaattaa..llff__ddiirrpprreesseenntt==TTRRUUEE;;}} //**SSeeaarrcchhddiirreeccttoorryyttoosseeeeiiffffiilleeeexxiissttss**//ffoouunndd==FFAALLSSEE;;ffoorr((ii==00;;ii<<ddiirrppttrr-->>llffdd__nnffiilleess;;ii++++)){{llddppttrr==&&ddiirrppttrr-->>llffdd__ffiilleess[[ii]];;nnaamm==nnaammee;;ccmmpp==llddppttrr-->>lldd__nnaammee;;wwhhiillee((**nnaamm!!==NNUULLLLCCHH)){{iiff((**nnaamm!!==**ccmmpp)){{bbrreeaakk;;Sec. 19.13        The Local File System Open Function (lfsopen) 479}} nnaamm++++;;ccmmpp++++;;}} iiff((((**nnaamm====NNUULLLLCCHH))&&&&((**ccmmpp====NNUULLLLCCHH)))){{//**NNaammeeffoouunndd**//ffoouunndd==TTRRUUEE;;bbrreeaakk;;}}}} //**CCaassee##11--ffiilleeiissnnoottiinnddiirreeccttoorryy((ii..ee..,,ddooeessnnootteexxiisstt))**//iiff((!!ffoouunndd)){{iiff((mmbbiittss&&LLFF__MMOODDEE__OO)){{//**FFiillee**mmuusstt**eexxiisstt**//ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**TTaakkeesstteeppssttooccrreeaatteenneewwffiilleeaannddaaddddttooddiirreeccttoorryy**////**VVeerriiffyytthhaattssppaacceerreemmaaiinnssiinntthheeddiirreeccttoorryy**//iiff((ddiirrppttrr-->>llffdd__nnffiilleess>>==LLFF__NNUUMM__DDIIRR__EENNTT)){{ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**AAllllooccaatteenneexxttddiirr..eennttrryy&&iinniittiiaalliizzeettooeemmppttyyffiillee**//llddppttrr==&&ddiirrppttrr-->>llffdd__ffiilleess[[ddiirrppttrr-->>llffdd__nnffiilleess++++]];;llddppttrr-->>lldd__ssiizzee==00;;ffrroomm==nnaammee;;ttoo==llddppttrr-->>lldd__nnaammee;;wwhhiillee((((**ttoo++++==**ffrroomm++++))!!==NNUULLLLCCHH)){{;;}} llddppttrr-->>lldd__iilliisstt==LLFF__IINNUULLLL;;//**CCaassee##22--ffiilleeiissiinnddiirreeccttoorryy((ii..ee..,,aallrreeaaddyyeexxiissttss))**//}}eellsseeiiff((mmbbiittss&&LLFF__MMOODDEE__NN)){{//**FFiilleemmuussttnnootteexxiisstt**//ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}480File Systems Chap. 19//**IInniittiiaalliizzeetthheellooccaallffiilleeppsseeuuddoo--ddeevviiccee**//llffppttrr==&&llffllttaabb[[llffnneexxtt]];;llffppttrr-->>llffssttaattee==LLFF__UUSSEEDD;;llffppttrr-->>llffddiirrppttrr==llddppttrr;;//**PPooiinnttttooddiirreeccttoorryyeennttrryy**//llffppttrr-->>llffmmooddee==mmbbiittss&&LLFF__MMOODDEE__RRWW;;//**FFiilleessttaarrttssaattppoossiittiioonn00**//llffppttrr-->>llffppooss==00;;ttoo==llffppttrr-->>llffnnaammee;;ffrroomm==nnaammee;;wwhhiillee((((**ttoo++++==**ffrroomm++++))!!==NNUULLLLCCHH)){{;;}} //**NNeeiitthheerriinnddeexxbblloocckknnoorrddaattaabblloocckkaarreeiinniittiiaallllyyvvaalliidd**//llffppttrr-->>llffiinnuumm==LLFF__IINNUULLLL;;llffppttrr-->>llffddnnuumm==LLFF__DDNNUULLLL;;//**IInniittiiaalliizzeebbyytteeppooiinntteerrttooaaddddrreessssbbeeyyoonnddtthheeeennddoofftthhee**////**bbuuffffeerr((ii..ee..,,iinnvvaalliiddppooiinntteerrttrriiggggeerrsssseettuupp))**//llffppttrr-->>llffbbyyttee==&&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;llffppttrr-->>llffiibbddiirrttyy==FFAALLSSEE;;llffppttrr-->>llffddbbddiirrttyy==FFAALLSSEE;;ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;rreettuurrnnllffppttrr-->>llffddeevv;;}}After verifying that the length of the file name is valid, lfsopen calls lfgetmode toparse the mode argument and convert it to a set of bits. A mode argument consists of anull-terminated string that contains zero or more of the characters from Figure 19.5. Characters in the mode string may not be repeated, and the combination of “o” and “n”(i.e., file is both old and new) is considered illegal. Furthermore, if neither “r” nor “w”is present in the mode string, lfgetmode assumes a default mode that allows both read-ing and writing. After parsing the mode string, lfgetmode produces an integer with indi-vidual bits specifying the modes as defined in lfilesys.h.† File lfgetmode.c contains the code.†File lfilesys.h can be found on page 464.Sec. 19.13        The Local File System Open Function (lfsopen) 481Character Meaningr Open the file for readingw Open the file for writingo File must be “old” (i.e., must exist)n File must be “new” (i.e., must not exist)Figure 19.5  Characters permitted in a mode string and their meaning.//**llffggeettmmooddee..cc--llffggeettmmooddee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffggeettmmooddee--PPaarrsseemmooddeeaarrgguummeennttaannddggeenneerraatteeiinntteeggeerrooffmmooddeebbiittss**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322llffggeettmmooddee((cchhaarr**mmooddee//**SSttrriinnggooffmmooddeecchhaarraacctteerrss**//)){{iinntt3322mmbbiittss;;//**MMooddeebbiittssttoorreettuurrnn**//cchhaarrcchh;;//**NNeexxttcchhaarriinnmmooddeessttrriinngg**//mmbbiittss==00;;//**MMooddeessttrriinnggssppeecciiffiieess::**////**rr--rreeaadd**////**ww--wwrriittee**////**oo--oolldd((ffiilleemmuusstteexxiisstt))**////**nn--nneeww((ccrreeaatteeaanneewwffiillee))**//wwhhiillee((((cchh==**mmooddee++++))!!==NNUULLLLCCHH)){{sswwiittcchh((cchh)){{ccaassee’’rr’’::iiff((mmbbiittss&&LLFF__MMOODDEE__RR)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==LLFF__MMOODDEE__RR;;ccoonnttiinnuuee;;482File Systems Chap. 19ccaassee’’ww’’::iiff((mmbbiittss&&LLFF__MMOODDEE__WW)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==LLFF__MMOODDEE__WW;;ccoonnttiinnuuee;;ccaassee’’oo’’::iiff((mmbbiittss&&LLFF__MMOODDEE__OO||||mmbbiittss&&LLFF__MMOODDEE__NN)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==LLFF__MMOODDEE__OO;;bbrreeaakk;;ccaassee’’nn’’::iiff((mmbbiittss&&LLFF__MMOODDEE__OO||||mmbbiittss&&LLFF__MMOODDEE__NN)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==LLFF__MMOODDEE__NN;;bbrreeaakk;;ddeeffaauulltt::rreettuurrnnSSYYSSEERRRR;;}}}} //**IIffnneeiitthheerrrreeaaddnnoorrwwrriitteessppeecciiffiieedd,,aalllloowwbbootthh**//iiff((((mmbbiittss&&LLFF__MMOODDEE__RRWW))====00)){{mmbbiittss||==LLFF__MMOODDEE__RRWW;;}} rreettuurrnnmmbbiittss;;}}Once the mode argument has been parsed, lfsopen verifies that the file is not al-ready open, verifies that a file pseudo-device is available, and searches the file system directory to see if the file exists. If the file exists (and the mode allows opening an ex-isting file), lfsopen fills in the control block of a file pseudo-device. If the file does not exist (and the mode allows creating a new file), lfsopen allocates an entry in the file system directory, and then fills in the control block of a file pseudo-device. The initial file position is set to zero. Control block fields lfinum and lfdnum are set to the ap-propriate null value to indicate that neither the index block nor the data block are currently present. More important, field lfbyte is set to a value beyond the end of the data block buffer. We will see that setting lfbyte is important because the code uses the following invariant when accessing data:Sec. 19.13        The Local File System Open Function (lfsopen) 483When lfbyte contains an address in lfdblock, the byte to which itpoints contains the data that is in the file at the position given bylfpos; when lfbyte contains an address beyond lfdblock, values in lfdblock cannot be used.The general idea is that setting the current byte position beyond the end of the current data block causes the system to fetch another data block before performing transfers. That is, any attempt to read or write bytes will cause the system to read a new data block from disk. The details will become clear when we examine data transfer functions, such as lflgetc and lflputc.19.14 Closing A File Pseudo-Device (lflclose)When an application finishes using a file, the application calls close to terminateuse. Note that the application has been using one of the pseudo-devices to read andwrite the file. Therefore, when the application calls close, the device descriptor corresponds to a pseudo-device. Closing the device terminates use of the file, and makes the pseudo-device available for other uses.In theory, closing a pseudo-device is trivial: change the state to indicate that the device is no longer in use. In practice, however, caching complicates closing becausethe control block may contain data that has not been written to the file. Therefore, function lflclose must check the dirty bits† in the control block that specify whether the index block or data block have been changed since they were written to disk.If changes have occurred since the last time information was written to disk, the data block (and possibly the index block) should be written to disk before the control block is deallocated and made available for another file. Rather than write data directly, lflclose calls function lfflush to take care of writing the items to disk. Isolating all up-dates to lfflush keeps the design cleaner. Once the disk has been updated, lflclose changes the state of the control block. File lflclose.c contains the code.19.15 Flushing Data To Disk (lfflush)Function lfflush operates as expected. It receives a pointer to the control block of the pseudo-device as an argument, and uses the pointer to examine “dirty” bits in the control block. If the index block has changed, lfflush uses lfibput to write a copy to disk; if the data block has changed, lfflush uses write to write a copy to disk. Fields lfi-num and lfdnum contain the index block number and data block number to use. The code can be found in file lfflush.c.†The term dirty bit refers to a Boolean (i.e., a single bit) that is set to TRUE to indicate that data haschanged.484File Systems Chap. 19//**llffllcclloossee..cc--llffllcclloossee..cc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffllcclloossee--CClloosseeaaffiilleebbyyfflluusshhiinnggoouuttppuuttaannddffrreeeeiinnggddeevviicceeeennttrryy**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffllcclloossee((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttllffllccbbllkk**llffppttrr;;//**PPttrrttooooppeennffiilleettaabblleeeennttrryy**////**OObbttaaiinneexxcclluussiivveeuusseeoofftthheeffiillee**//llffppttrr==&&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;wwaaiitt((llffppttrr-->>llffmmuutteexx));;//**IIffffiilleeiissnnoottooppeenn,,rreettuurrnnaanneerrrroorr**//iiff((llffppttrr-->>llffssttaattee!!==LLFF__UUSSEEDD)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**WWrriitteeiinnddeexxoorrddaattaabblloocckkssttooddiisskkiifftthheeyyhhaavveecchhaannggeedd**//iiff((LLff__ddaattaa..llff__ddiirrddiirrttyy||||llffppttrr-->>llffddbbddiirrttyy||||llffppttrr-->>llffiibbddiirrttyy)){{llfffflluusshh((llffppttrr));;}} //**SSeettddeevviicceessttaatteettooFFRREEEEaannddrreettuurrnnttooccaalllleerr**//llffppttrr-->>llffssttaattee==LLFF__FFRREEEE;;ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnOOKK;;}}Sec. 19.15        Flushing Data To Disk (lfflush) 485//**llfffflluusshh..cc--llfffflluusshh**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llfffflluusshh--FFlluusshhddiirreeccttoorryy,,ddaattaabblloocckk,,aannddiinnddeexxbblloocckkffoorraannooppeenn**ffiillee((aassssuummeessffiilleemmuutteexxiisshheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussllfffflluusshh((ssttrruuccttllffllccbbllkk**llffppttrr//**PPttrrttooffiilleeppsseeuuddooddeevviiccee**//)){{iiff((llffppttrr-->>llffssttaattee====LLFF__FFRREEEE)){{rreettuurrnnSSYYSSEERRRR;;}} //**WWrriitteetthheeddiirreeccttoorryyiiffiitthhaasscchhaannggeedd**//iiff((LLff__ddaattaa..llff__ddiirrddiirrttyy)){{wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr**))&&LLff__ddaattaa..llff__ddiirr,,LLFF__AARREEAA__DDIIRR));;LLff__ddaattaa..llff__ddiirrddiirrttyy==FFAALLSSEE;;}} //**WWrriitteeddaattaabblloocckkiiffiitthhaasscchhaannggeedd**//iiff((llffppttrr-->>llffddbbddiirrttyy)){{wwrriittee((LLff__ddaattaa..llff__ddsskkddeevv,,llffppttrr-->>llffddbblloocckk,,llffppttrr-->>llffddnnuumm));;llffppttrr-->>llffddbbddiirrttyy==FFAALLSSEE;;}} //**WWrriitteeii--bblloocckkiiffiitthhaasscchhaannggeedd**//iiff((llffppttrr-->>llffiibbddiirrttyy)){{llffiibbppuutt((LLff__ddaattaa..llff__ddsskkddeevv,,llffppttrr-->>llffiinnuumm,,&&llffppttrr-->>llffiibblloocckk));;llffppttrr-->>llffiibbddiirrttyy==FFAALLSSEE;;}} rreettuurrnnOOKK;;}}486File Systems Chap. 1919.16 Bulk Transfer Functions For A File (lflwrite, lflread)Our implementation adopts a straightforward approach to transfer operations write and read: each uses a loop that calls a character transfer function. For example, func-tion lflwrite calls lflputc repeatedly. File lflwrite.c contains the code.//**llffllwwrriittee..cc--llffllwwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffllwwrriittee----WWrriitteeddaattaattooaapprreevviioouussllyyooppeenneeddllooccaallddiisskkffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffllwwrriittee((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrhhoollddiinnggddaattaattoowwrriittee**//iinntt3322ccoouunntt//**NNuummbbeerrooffbbyytteessttoowwrriittee**//)){{iinntt3322ii;;//**NNuummbbeerrooffbbyytteesswwrriitttteenn**//iiff((ccoouunntt<<00)){{rreettuurrnnSSYYSSEERRRR;;}} //**IItteerraattaatteeaannddwwrriitteeoonneebbyytteeaattaattiimmee**//ffoorr((ii==00;;ii<<ccoouunntt;;ii++++)){{iiff((llffllppuuttcc((ddeevvppttrr,,**bbuuffff++++))====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}}}} rreettuurrnnccoouunntt;;}}Function lflread calls lflgetc repeatedly to satisfy a read request. It places each byte in the next location of the caller’s buffer. An interesting part of the code concerns how lflread handles an end-of-file condition. When it reaches the end of the file, lflgetc returns constant EOF. Iflflread has already extracted one or more bytes of data from the file when it receives an EOF from lflgetc, lflread stops the loop and returns a count of the bytes that have been read. If no data has been found when an end-of-file is re-ceived, lflread returns constant EOF to its caller. File lflread.c contains the code.Sec. 19.16        Bulk Transfer Functions For A File (lflwrite, lflread) 487//**llffllrreeaadd..cc--llffllrreeaadd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffllrreeaadd--RReeaaddffrroommaapprreevviioouussllyyooppeenneeddllooccaallffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffllrreeaadd((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrttoohhoollddbbyytteess**//iinntt3322ccoouunntt//**MMaaxxbbyytteessttoorreeaadd**//)){{uuiinntt3322nnuummrreeaadd;;//**NNuummbbeerrooffbbyytteessrreeaadd**//iinntt3322nnxxttbbyyttee;;//**CChhaarraacctteerroorrSSYYSSEERRRR//EEOOFF**//iiff((ccoouunntt<<00)){{rreettuurrnnSSYYSSEERRRR;;}} //**IItteerraatteeaanndduusseellffllggeettccttoorreeaaddiinnddiivvddiiuuaallbbyytteess**//ffoorr((nnuummrreeaadd==00;;nnuummrreeaadd<<ccoouunntt;;nnuummrreeaadd++++)){{nnxxttbbyyttee==llffllggeettcc((ddeevvppttrr));;iiff((nnxxttbbyyttee====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnxxttbbyyttee====EEOOFF)){{//**EEOOFFbbeeffoorreeffiinniisshheedd**//iiff((nnuummrreeaadd====00)){{rreettuurrnnEEOOFF;;}}eellssee{{rreettuurrnnnnuummrreeaadd;;}}}}eellssee{{**bbuuffff++++==((cchhaarr))((00xxffff&&nnxxttbbyyttee));;}}}} rreettuurrnnnnuummrreeaadd;;}}488File Systems Chap. 1919.17 Seeking To A New Position In the File (lflseek)A process can call seek to change the current position in a file. Our system uses function lflseek to implement seek, and restricts the position to a valid point in the file(i.e., it is unlike Unix, which allows an application to seek beyond the end of the file).Seeking to a new position consists of changing field lfpos in the file control block and setting field lfbyte to an address beyond lfdblock (which, according to the invariant above, means that the pointer cannot be used to extract data until the index block and data block are in place). File lflseek.c contains the code.//**llffllsseeeekk..cc--llffllsseeeekk**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffllsseeeekk--SSeeeekkttooaassppeecciiffiieeddppoossiittiioonniinnaaffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffllsseeeekk((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//uuiinntt3322ooffffsseett//**BByytteeppoossiittiioonniinntthheeffiillee**//)){{ssttrruuccttllffllccbbllkk**llffppttrr;;//**PPttrrttooooppeennffiilleettaabblleeeennttrryy**////**IIffffiilleeiissnnoottooppeenn,,rreettuurrnnaanneerrrroorr**//llffppttrr==&&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;wwaaiitt((llffppttrr-->>llffmmuutteexx));;iiff((llffppttrr-->>llffssttaattee!!==LLFF__UUSSEEDD)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyyooffffsseettiisswwiitthhiinnccuurrrreennttffiilleessiizzee**//iiff((ooffffsseett>>llffppttrr-->>llffddiirrppttrr-->>lldd__ssiizzee)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**RReeccoorrddnneewwooffffsseettaannddiinnvvaalliiddaatteebbyytteeppooiinntteerr((ii..ee..,,ffoorrccee**////**tthheeiinnddeexxaannddddaattaabblloocckkssttoobbeerreeppllaacceeddiiffaassuucccceessssiivvee**////**ccaalllliissmmaaddeettoorreeaaddoorrwwrriittee))**//Sec. 19.17        Seeking To A New Position In the File (lflseek) 489llffppttrr-->>llffppooss==ooffffsseett;;llffppttrr-->>llffbbyyttee==&&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnOOKK;;}}19.18 Extracting One Byte From A File (lflgetc)Once a file has been opened and both the correct index block and data block have been loaded into memory, extracting a byte from the file is trivial: it consists of treating lfbyte as a pointer to the byte, extracting the byte, and advancing the buffer pointer to the next byte. Function lflgetc, which performs the operation, can be found in file lflgetc.c.//**llffllggeettcc..cc--llffggeettcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffllggeettcc--RReeaaddtthheenneexxttbbyytteeffrroommaannooppeennllooccaallffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffllggeettcc((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttllffllccbbllkk**llffppttrr;;//**PPttrrttooooppeennffiilleettaabblleeeennttrryy**//ssttrruuccttllddeennttrryy**llddppttrr;;//**PPttrrttooffiillee’’sseennttrryyiinntthhee**////**iinn--mmeemmoorryyddiirreeccttoorryy**//iinntt3322oonneebbyyttee;;//**NNeexxttddaattaabbyytteeiinntthheeffiillee**////**OObbttaaiinneexxcclluussiivveeuusseeoofftthheeffiillee**//llffppttrr==&&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;wwaaiitt((llffppttrr-->>llffmmuutteexx));;//**IIffffiilleeiissnnoottooppeenn,,rreettuurrnnaanneerrrroorr**//iiff((llffppttrr-->>llffssttaattee!!==LLFF__UUSSEEDD)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}490File Systems Chap. 19//**RReettuurrnnEEOOFFffoorraannyyaatttteemmppttttoorreeaaddbbeeyyoonnddtthheeeenndd--ooff--ffiillee**//llddppttrr==llffppttrr-->>llffddiirrppttrr;;iiff((llffppttrr-->>llffppooss>>==llddppttrr-->>lldd__ssiizzee)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnEEOOFF;;}} //**IIffbbyytteeppooiinntteerriissbbeeyyoonnddtthheeccuurrrreennttddaattaabblloocckk,,sseettuupp**////**aanneewwddaattaabblloocckk**//iiff((llffppttrr-->>llffbbyyttee>>==&&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]])){{llffsseettuupp((llffppttrr));;}} //**EExxttrraacctttthheenneexxttbbyytteeffrroommbblloocckk,,uuppddaatteeffiilleeppoossiittiioonn,,aanndd**////**rreettuurrnntthheebbyytteettootthheeccaalllleerr**//oonneebbyyttee==00xxffff&&**llffppttrr-->>llffbbyyttee++++;;llffppttrr-->>llffppooss++++;;ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnoonneebbyyttee;;}}If the specified file is not open, lflgetc returns SYSERR. If the current file position exceeds the file size, lflgetc returns EOF. In other cases, lflgetc checks pointer lfbyte tosee whether it currently points outside of the data block in lfdblock. If so, lflgetc calls lfsetup to read the correct index block and data block into memory.Once the data block is in memory, lflgetc can extract a byte. To do so, it derefer-ences lfbyte to obtain a byte and places the byte in variable onebyte. It increments boththe byte pointer and the file position before returning the byte to the caller.19.19 Changing One Byte In A File (lflputc)Function lflputc handles the task of storing a byte into a file at the current position.As with lflgetc, the code that performs the transfer is trivial and only occupies a fewlines. Pointer lfbyte gives a location in lfdblock at which the byte should be stored; thecode uses the pointer, stores the specified byte, increments the pointer, and sets lfdbdirty to indicate that the data block has been changed. Note that lflputc merely accumulates characters in a buffer in memory; it does not write the buffer to disk each time a change occurs. The buffer will only be copied to disk when the current position moves to another disk block.Sec. 19.19        Changing One Byte In A File (lflputc) 491//**llffllppuuttcc..cc--llffppuuttcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffllppuuttcc--WWrriitteeaassiinngglleebbyytteettooaannooppeennllooccaallffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffllppuuttcc((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarrcchh//**CChhaarraacctteerr((bbyyttee))ttoowwrriittee**//)){{ssttrruuccttllffllccbbllkk**llffppttrr;;//**PPttrrttooooppeennffiilleettaabblleeeennttrryy**//ssttrruuccttllddeennttrryy**llddppttrr;;//**PPttrrttooffiillee’’sseennttrryyiinntthhee**////**iinn--mmeemmoorryyddiirreeccttoorryy**////**OObbttaaiinneexxcclluussiivveeuusseeoofftthheeffiillee**//llffppttrr==&&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;wwaaiitt((llffppttrr-->>llffmmuutteexx));;//**IIffffiilleeiissnnoottooppeenn,,rreettuurrnnaanneerrrroorr**//iiff((llffppttrr-->>llffssttaattee!!==LLFF__UUSSEEDD)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**RReettuurrnnSSYYSSEERRRRffoorraannaatttteemmppttttoosskkiippbbyytteessbbeeyyoonnddtthheebbyyttee**////**tthhaattiissccuurrrreennttllyytthheeeennddoofftthheeffiillee**//llddppttrr==llffppttrr-->>llffddiirrppttrr;;iiff((llffppttrr-->>llffppooss>>llddppttrr-->>lldd__ssiizzee)){{ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**IIffppooiinntteerriissoouuttssiiddeeccuurrrreennttbblloocckk,,sseettuuppnneewwbblloocckk**//iiff((llffppttrr-->>llffbbyyttee>>==&&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]])){{//**SSeettuuppbblloocckkffoorrccuurrrreennttffiilleeppoossiittiioonn**//llffsseettuupp((llffppttrr));;}}492File Systems Chap. 19//**IIffaappppeennddiinnggaabbyytteettootthheeffiillee,,iinnccrreemmeenntttthheeffiilleessiizzee..**////**NNoottee::ccoommppaarriissoonnmmiigghhttbbeeeeqquuaall,,bbuuttsshhoouullddnnoottbbeeggrreeaatteerr..**//iiff((llffppttrr-->>llffppooss>>==llddppttrr-->>lldd__ssiizzee)){{llddppttrr-->>lldd__ssiizzee++++;;LLff__ddaattaa..llff__ddiirrddiirrttyy==TTRRUUEE;;}} //**PPllaacceebbyytteeiinnbbuuffffeerraannddmmaarrkkbbuuffffeerr""ddiirrttyy""**//**llffppttrr-->>llffbbyyttee++++==cchh;;llffppttrr-->>llffppooss++++;;llffppttrr-->>llffddbbddiirrttyy==TTRRUUEE;;ssiiggnnaall((llffppttrr-->>llffmmuutteexx));;rreettuurrnnOOKK;;}}Like lflgetc, lflputc examines lfbyte on each call. If lfbyte lies outside of data block lfdblock, lflputc calls lfsetup to move to the next block. However, a subtle differ-ence exists in the way lflputc and lflgetc treat an invalid file position.  Lflgetc always returns EOF if the file position exceeds the last byte of the file. Lflputc returns SYSERR when the file position is more than one byte beyond the end of the file, but if the position is exactly one byte beyond the end, it allows the operation to proceed. That is, it allows a file to be extended. When a file is extended, the file size, found in the directory entry for the file, must be incremented. File lflputc.c contains the code.19.20 Loading An Index Block And A Data Block (lfsetup)Once a file position has been assigned to field lfpos, function lfsetup handles the details of positioning the in-memory data structures at the specified position. That is, lfsetup identifies the index block for the position, loads a copy of the index block into memory, identifies the data block that contains the position, and loads a copy of the data block into memory. Lfsetup begins by obtaining pointers to data structures.A key idea is that lfsetup handles the case where an existing data block is dirty. To do so, before it reads new items from disk, lfsetup checks the control block. If the existing index or data blocks have changed, lfsetup calls lfflush to write them to disk.The first step in loading data for the current file position consists of finding the in-dex block that covers the specified file position. To do so, lfsetup starts with an indexblock that precedes the current position, and moves along the linked list of index blocksto find the needed block. There are two cases for an initial block: no index block hasbeen loaded or an index block is currently in memory.Sec. 19.20        Loading An Index Block And A Data Block (lfsetup) 493If no index block has been loaded (i.e., the file was just opened), lfsetup obtains one. For a new file, lfsetup must allocate an initial index block from the free list; for an existing file, it loads the first index block for the file. In either case, the initial condi-tion will be that the index block either corresponds to the file position or covers an ear-lier position in the file.If an index block has already been loaded, there are two possibilities. If the index block covers an earlier part of the file, no further action is needed. If the index block corresponds to a portion of the file that lies after the current file position (e.g., a process has issued a seek to an earlier position), lfsetup must find an initial block that covers an earlier part of the file. To handle the case, lfsetup replaces the index block with the ini-tial index block for the file.Once it has loaded an index block that covers an earlier part of the file, lfsetup enters a loop that moves along the linked list of index blocks until it reaches the index block that covers the current file position. At each iteration, lfsetup uses field ib_next to find the number of the next index block on the list, and then calls lfibget to read the index block into memory.Once the correct index block has been loaded, lfsetup must determine the datablock to load. To do so, it uses the file position to compute an index (from 0 through15) for the data block array. Because each index block covers exactly 8K bytes (i.e., 213 bytes) of data and each slot in the array corresponds to a block of 512 bytes (29), binary arithmetic can be used. Lfsetup computes the logical and of the LF_IMASK (the low-order 13 bits), and then shifts the result right 9 bits.Lfsetup uses the result of the above computation as an index into array ib_dba toobtain the ID of a data block. There are two cases that require lfsetup to load a newdata block. In the first case, the pointer in the array is null, which means lflputc isabout to write a new byte on the end of the file and no data block has been assigned for the position.  Lfsetup calls lfdballoc to allocate a new data block from the free list, and records the ID in the entry of array ib_dba. In the second case, the entry in array ib_dba specifies a data block other than the data block currently loaded. Lfsetup calls read to fetch the correct data block from disk.As the final step before returning, lfsetup uses the file position to compute a posi-tion within the data block, and assigns the address to field lfbyte. The careful arrange-ment of making the data block size a power of two means that the indices from 0through 511 can be computed by selecting the low-order 9 bits of the file position. The code uses a logical and with mask LF_DMASK. File lfsetup.c contains the code.494File Systems Chap. 19//**llffsseettuupp..cc--llffsseettuupp**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffsseettuupp--SSeettaaffiillee’’ssiinnddeexxbblloocckkaannddddaattaabblloocckkffoorrtthheeccuurrrreenntt**ffiilleeppoossiittiioonn((aassssuummeessffiilleemmuutteexxhheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussllffsseettuupp((ssttrruuccttllffllccbbllkk**llffppttrr//**PPooiinntteerrttoossllaavveeffiilleeddeevviiccee**//)){{ddbbiidd3322ddnnuumm;;//**DDaattaabblloocckkttooffeettcchh**//iibbiidd3322iibbnnuumm;;//**II--bblloocckknnuummbbeerrdduurriinnggsseeaarrcchh**//ssttrruuccttllddeennttrryy**llddppttrr;;//**PPttrrttooffiilleeeennttrryyiinnddiirr..**//ssttrruuccttllffiibbllkk**iibbppttrr;;//**PPttrrttooiinn--mmeemmoorryyiinnddeexxbblloocckk**//uuiinntt3322nneewwooffffsseett;;//**CCoommppuutteeddddaattaaooffffsseettffoorr**////**nneexxttiinnddeexxbblloocckk**//iinntt3322ddiinnddeexx;;//**IInnddeexxiinnttooaarrrraayyiinnaanniinnddeexx**////**bblloocckk**////**OObbttaaiinneexxcclluussiivveeaacccceessssttootthheeddiirreeccttoorryy**//wwaaiitt((LLff__ddaattaa..llff__mmuutteexx));;//**GGeettppooiinntteerrssttooiinn--mmeemmoorryyddiirreeccttoorryy,,ffiillee’’sseennttrryyiinntthhee**////**ddiirreeccttoorryy,,aannddtthheeiinn--mmeemmoorryyiinnddeexxbblloocckk**//llddppttrr==llffppttrr-->>llffddiirrppttrr;;iibbppttrr==&&llffppttrr-->>llffiibblloocckk;;//**IIffeexxiissttiinnggiinnddeexxbblloocckkoorrddaattaabblloocckkcchhaannggeedd,,wwrriitteettooddiisskk**//iiff((llffppttrr-->>llffiibbddiirrttyy||||llffppttrr-->>llffddbbddiirrttyy)){{llfffflluusshh((llffppttrr));;}} iibbnnuumm==llffppttrr-->>llffiinnuumm;;//**GGeettIIDDooffccuurrrr..iinnddeexxbblloocckk**////**IIfftthheerreeiissnnooiinnddeexxbblloocckkiinnmmeemmoorryy((ee..gg..,,bbeeccaauusseetthheeffiillee**////**wwaassjjuussttooppeenneedd)),,eeiitthheerrllooaaddtthheeffiirrssttiinnddeexxbblloocckkooff**////**tthheeffiilleeoorraallllooccaatteeaanneewwffiirrssttiinnddeexxbblloocckk**//iiff((iibbnnuumm====LLFF__IINNUULLLL)){{Sec. 19.20        Loading An Index Block And A Data Block (lfsetup) 495//**CChheecckkddiirreeccttoorryyeennttrryyttoosseeeeiiffiinnddeexxbblloocckkeexxiissttss**//iibbnnuumm==llddppttrr-->>lldd__iilliisstt;;iiff((iibbnnuumm====LLFF__IINNUULLLL)){{//**EEmmppttyyffiillee--ggeettnneewwii--bblloocckk**//iibbnnuumm==llffiibbaalllloocc(());;llffiibbcclleeaarr((iibbppttrr,,00));;llddppttrr-->>lldd__iilliisstt==iibbnnuumm;;llffppttrr-->>llffiibbddiirrttyy==TTRRUUEE;;}}eellssee{{//**NNoonneemmppttyy--rreeaaddffiirrssttii--bblloocckk**//llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,,iibbnnuumm,,iibbppttrr));;}} llffppttrr-->>llffiinnuumm==iibbnnuumm;;//**OOtthheerrwwiissee,,iiffccuurrrreennttffiilleeppoossiittiioonnhhaassbbeeeennmmoovveeddttooaann**////**ooffffsseettbbeeffoorreetthheeccuurrrreennttiinnddeexxbblloocckk,,ssttaarrttaatttthhee**////**bbeeggiinnnniinnggoofftthheeiinnddeexxlliissttffoorrtthheeffiillee**//}}eellsseeiiff((llffppttrr-->>llffppooss<<iibbppttrr-->>iibb__ooffffsseett)){{//**LLooaaddiinniittiiaalliinnddeexxbblloocckkffoorrtthheeffiillee((wweekknnoowwtthhaatt**////**aattlleeaassttoonneeiinnddeexxbblloocckkeexxiissttss))**//iibbnnuumm==llddppttrr-->>lldd__iilliisstt;;llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,,iibbnnuumm,,iibbppttrr));;llffppttrr-->>llffiinnuumm==iibbnnuumm;;}} //**AAtttthhiissppooiinntt,,aanniinnddeexxbblloocckkiissiinnmmeemmoorryy,,bbuuttmmaayyccoovveerr**////**aannooffffsseettlleesssstthhaanntthheeccuurrrreennttffiilleeppoossiittiioonn..LLooooppuunnttiill**////**tthheeiinnddeexxbblloocckkccoovveerrsstthheeccuurrrreennttffiilleeppoossiittiioonn..**//wwhhiillee((((llffppttrr-->>llffppooss&&~~LLFF__IIMMAASSKK))>>iibbppttrr-->>iibb__ooffffsseett)){{iibbnnuumm==iibbppttrr-->>iibb__nneexxtt;;iiff((iibbnnuumm====LLFF__IINNUULLLL)){{//**AAllllooccaatteenneewwiinnddeexxbblloocckkttooeexxtteennddffiillee**//iibbnnuumm==llffiibbaalllloocc(());;iibbppttrr-->>iibb__nneexxtt==iibbnnuumm;;llffiibbppuutt((LLff__ddaattaa..llff__ddsskkddeevv,,llffppttrr-->>llffiinnuumm,,iibbppttrr));;llffppttrr-->>llffiinnuumm==iibbnnuumm;;nneewwooffffsseett==iibbppttrr-->>iibb__ooffffsseett++LLFF__IIDDAATTAA;;llffiibbcclleeaarr((iibbppttrr,,nneewwooffffsseett));;llffppttrr-->>llffiibbddiirrttyy==TTRRUUEE;;}}eellssee{{llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,,iibbnnuumm,,iibbppttrr));;llffppttrr-->>llffiinnuumm==iibbnnuumm;;496File Systems Chap. 19}} llffppttrr-->>llffddnnuumm==LLFF__DDNNUULLLL;;//**IInnvvaalliiddaatteeoollddddaattaabblloocckk**//}} //**AAtttthhiissppooiinntt,,tthheeiinnddeexxbblloocckkiinnllffiibblloocckkccoovveerrsstthhee**////**ccuurrrreennttffiilleeppoossiittiioonn((ii..ee..,,ppoossiittiioonnllffppttrr-->>llffppooss))..TThhee**////**nneexxttsstteeppccoonnssiissttssooffllooaaddiinnggtthheeccoorrrreeccttddaattaabblloocckk..**//ddiinnddeexx==((llffppttrr-->>llffppooss&&LLFF__IIMMAASSKK))>>>>99;;//**IIffddaattaabblloocckkiinnddeexxddooeessnnoottmmaattcchhccuurrrreennttddaattaabblloocckk,,rreeaadd**////**tthheeccoorrrreeccttddaattaabblloocckkffrroommddiisskk**//ddnnuumm==llffppttrr-->>llffiibblloocckk..iibb__ddbbaa[[ddiinnddeexx]];;iiff((ddnnuumm====LLFF__DDNNUULLLL)){{//**AAllllooccaatteenneewwddaattaabblloocckk**//ddnnuumm==llffddbbaalllloocc((((ssttrruuccttllffddbbffrreeee**))&&llffppttrr-->>llffddbblloocckk));;llffppttrr-->>llffiibblloocckk..iibb__ddbbaa[[ddiinnddeexx]]==ddnnuumm;;llffppttrr-->>llffiibbddiirrttyy==TTRRUUEE;;}}eellsseeiiff((ddnnuumm!!==llffppttrr-->>llffddnnuumm)){{rreeaadd((LLff__ddaattaa..llff__ddsskkddeevv,,((cchhaarr**))llffppttrr-->>llffddbblloocckk,,ddnnuumm));;llffppttrr-->>llffddbbddiirrttyy==FFAALLSSEE;;}} llffppttrr-->>llffddnnuumm==ddnnuumm;;//**UUsseeccuurrrreennttffiilleeooffffsseettttoosseetttthheeppooiinntteerrttootthheenneexxttbbyyttee**////**wwiitthhiinntthheeddaattaabblloocckk**//llffppttrr-->>llffbbyyttee==&&llffppttrr-->>llffddbblloocckk[[llffppttrr-->>llffppooss&&LLFF__DDMMAASSKK]];;ssiiggnnaall((LLff__ddaattaa..llff__mmuutteexx));;rreettuurrnnOOKK;;}}19.21 Master File System Device Initialization (lfsinit)Initialization for the master file system device is straightforward. Function lfsinit performs the task, which consists of recording the ID of the disk device, creating a semaphore that provides mutual exclusion to the directory, clearing the in-memory directory (merely to help with debugging), and setting a Boolean to indicate that the directory has not been read into memory. Data for the master file system device is kept in the global structure Lf_data. File lfsinit.c contains the code.Sec. 19.21        Master File System Device Initialization (lfsinit) 497//**llffssiinniitt..cc--llffssiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttllffddaattaaLLff__ddaattaa;;//**------------------------------------------------------------------------------------------------------------------------------------------------**llffssiinniitt--IInniittiiaalliizzeetthheellooccaallffiilleessyysstteemmmmaasstteerrddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllffssiinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{//**AAssssiiggnnIIDDooffddiisskkddeevviicceetthhaattwwiillllbbeeuusseedd**//LLff__ddaattaa..llff__ddsskkddeevv==LLFF__DDIISSKK__DDEEVV;;//**CCrreeaatteeaammuuttuuaalleexxcclluussiioonnsseemmaapphhoorree**//LLff__ddaattaa..llff__mmuutteexx==sseemmccrreeaattee((11));;//**ZZeerrooddiirreeccttoorryyaarreeaa((ffoorrddeebbuuggggiinngg))**//mmeemmsseett((((cchhaarr**))&&LLff__ddaattaa..llff__ddiirr,,NNUULLLLCCHH,,ssiizzeeooff((ssttrruuccttllffddiirr))));;//**IInniittiiaalliizzeeddiirreeccttoorryyttoo""nnoottpprreesseenntt""iinnmmeemmoorryy**//LLff__ddaattaa..llff__ddiirrpprreesseenntt==LLff__ddaattaa..llff__ddiirrddiirrttyy==FFAALLSSEE;;rreettuurrnnOOKK;;}}19.22 Pseudo-Device Initialization (lflinit)When it opens a file, lfsopen initializes many of the entries in the control block for the file pseudo-device. However, some initialization is performed at system startup. To indicate that the device is not in use, the state is assigned LF_FREE. A mutual exclu-sion semaphore is created to guarantee that at most one operation will be in progress on the file at a given time. Most other fields in the control block are initialized to zero (they will not be used until a file is opened, but initializing to zero can make debugging easier). File lflinit.c contains the code.498File Systems Chap. 19//**llfflliinniitt..cc--llfflliinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttllffllccbbllkkllffllttaabb[[NNllffll]];;//**PPsseeuuddoo--ddeevviicceeccoonnttrroollbblloocckkss**////**------------------------------------------------------------------------------------------------------------------------------------------------**llfflliinniitt--IInniittiiaalliizzeeccoonnttrroollbblloocckkssffoorrllooccaallffiilleeppsseeuuddoo--ddeevviicceess**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllllfflliinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttllffllccbbllkk**llffppttrr;;//**PPttrr..ttooccoonnttrroollbblloocckkeennttrryy**//iinntt3322ii;;//**WWaallkksstthhrroouugghhnnaammeeaarrrraayy**//llffppttrr==&&llffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**IInniittiiaalliizzeeccoonnttrroollbblloocckkeennttrryy**//llffppttrr-->>llffssttaattee==LLFF__FFRREEEE;;//**DDeevviicceeiissccuurrrreennttllyyuunnuusseedd**//llffppttrr-->>llffddeevv==ddeevvppttrr-->>ddvvnnuumm;;//**SSeettddeevviicceeIIDD**//llffppttrr-->>llffmmuutteexx==sseemmccrreeaattee((11));;//**CCrreeaatteetthheemmuutteexxsseemmaapphhoorree**////**IInniittiiaalliizzeetthheeddiirreeccttoorryyaannddffiilleeppoossiittiioonn**//llffppttrr-->>llffddiirrppttrr==((ssttrruuccttllddeennttrryy**))NNUULLLL;;llffppttrr-->>llffppooss==00;;ffoorr((ii==00;;ii<<LLFF__NNAAMMEE__LLEENN;;ii++++)){{llffppttrr-->>llffnnaammee[[ii]]==NNUULLLLCCHH;;}} //**ZZeerrootthheeiinn--mmeemmoorryyiinnddeexxbblloocckkaannddddaattaabblloocckk**//llffppttrr-->>llffiinnuumm==LLFF__IINNUULLLL;;mmeemmsseett((((cchhaarr**))&&llffppttrr-->>llffiibblloocckk,,NNUULLLLCCHH,,ssiizzeeooff((ssttrruuccttllffiibbllkk))));;llffppttrr-->>llffddnnuumm==00;;mmeemmsseett((((cchhaarr**))&&llffppttrr-->>llffddbblloocckk,,NNUULLLLCCHH,,LLFF__BBLLKKSSIIZZ));;//**SSttaarrttwwiitthhtthheebbyytteebbeeyyoonnddtthheeccuurrrreennttddaattaabblloocckk**//llffppttrr-->>llffbbyyttee==&&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;llffppttrr-->>llffiibbddiirrttyy==llffppttrr-->>llffddbbddiirrttyy==FFAALLSSEE;;rreettuurrnnOOKK;;}}Sec. 19.22        Pseudo-Device Initialization (lflinit) 49919.23 File Truncation (lftruncate)We will use file truncation as a way to show how file data structures are deallocat-ed. To truncate a file to zero length, each of the index blocks for the file must beplaced on the free list of index blocks. Before an index block can be released, however, each of the data blocks to which the index block points must be placed on the free list of data blocks. Function lftruncate performs file truncation; file lftruncate.c contains the code.//**llffttrruunnccaattee..cc--llffttrruunnccaattee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffttrruunnccaattee--TTrruunnccaatteeaaffiilleebbyyffrreeeeiinnggiittssiinnddeexxaannddddaattaabblloocckkss**((aassssuummeessddiirreeccttoorryymmuutteexxhheelldd))**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussllffttrruunnccaattee((ssttrruuccttllffllccbbllkk**llffppttrr//**PPttrrttooffiillee’’ssccnnttllbbllkkeennttrryy**//)){{ssttrruuccttllddeennttrryy**llddppttrr;;//**PPooiinntteerrttooffiillee’’ssddiirr..eennttrryy**//ssttrruuccttllffiibbllkkiibblloocckk;;//**BBuuffffeerrffoorroonneeiinnddeexxbblloocckk**//iibbiidd3322iiffrreeee;;//**SSttaarrttooffiinnddeexxbbllkkffrreeeelliisstt**//iibbiidd3322ffiirrssttiibb;;//**FFiirrssttiinnddeexxbbllkkoofftthheeffiillee**//iibbiidd3322nneexxttiibb;;//**WWaallkkssddoowwnnlliissttoofftthhee**////**ffiillee’’ssiinnddeexxbblloocckkss**//ddbbiidd3322nneexxttddbb;;//**NNeexxttddaattaabblloocckkttooffrreeee**//iinntt3322ii;;//**MMoovveesstthhrroouugghhddaattaabblloocckkssiinn**////**aaggiivveenniinnddeexxbblloocckk**//llddppttrr==llffppttrr-->>llffddiirrppttrr;;//**GGeettppooiinntteerrttooddiirr..eennttrryy**//iiff((llddppttrr-->>lldd__ssiizzee====00)){{//**FFiilleeiissaallrreeaaddyyeemmppttyy**//rreettuurrnnOOKK;;}} //**CClleeaannuupptthheeooppeennllooccaallffiilleeffiirrsstt**//iiff((((llffppttrr-->>llffiibbddiirrttyy))||||((llffppttrr-->>llffddbbddiirrttyy)))){{llfffflluusshh((llffppttrr));;}} llffppttrr-->>llffppooss==00;;llffppttrr-->>llffiinnuumm==LLFF__IINNUULLLL;;500File Systems Chap. 19llffppttrr-->>llffddnnuumm==LLFF__DDNNUULLLL;;llffppttrr-->>llffbbyyttee==&&llffppttrr-->>llffddbblloocckk[[LLFF__BBLLKKSSIIZZ]];;//**OObbttaaiinnIIDDooffffiirrssttiinnddeexxbblloocckkoonnffrreeeelliisstt**//iiffrreeee==LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee;;//**RReeccoorrddffiillee’’ssffiirrssttii--bblloocckkaannddcclleeaarrddiirreeccttoorryyeennttrryy**//ffiirrssttiibb==llddppttrr-->>lldd__iilliisstt;;llddppttrr-->>lldd__iilliisstt==LLFF__IINNUULLLL;;llddppttrr-->>lldd__ssiizzee==00;;LLff__ddaattaa..llff__ddiirrddiirrttyy==TTRRUUEE;;//**WWaallkkaalloonnggiinnddeexxbblloocckklliisstt,,ddiissppoossiinnggooffeeaacchhddaattaabblloocckk**////**aannddcclleeaarriinnggtthheeccoorrrreessppoonnddiinnggppooiinntteerr..AAnnootteeoonnlloooopp**////**tteerrmmiinnaattiioonn::llaassttppooiinntteerriisssseettttooiiffrreeeebbeellooww..**//ffoorr((nneexxttiibb==ffiirrssttiibb;;nneexxttiibb!!==iiffrreeee;;nneexxttiibb==iibblloocckk..iibb__nneexxtt)){{//**OObbttaaiinnaaccooppyyooffccuurrrreennttiinnddeexxbblloocckkffrroommddiisskk**//llffiibbggeett((LLff__ddaattaa..llff__ddsskkddeevv,,nneexxttiibb,,&&iibblloocckk));;//**FFrreeeeeeaacchhddaattaabblloocckkiinntthheeiinnddeexxbblloocckk**//ffoorr((ii==00;;ii<<LLFF__IIBBLLEENN;;ii++++)){{//**FFoorreeaacchhdd--bblloocckk**////**FFrreeeetthheeddaattaabblloocckk**//nneexxttddbb==iibblloocckk..iibb__ddbbaa[[ii]];;iiff((nneexxttddbb!!==LLFF__DDNNUULLLL)){{llffddbbffrreeee((LLff__ddaattaa..llff__ddsskkddeevv,,nneexxttddbb));;}} //**CClleeaarreennttrryyiinnii--bblloocckkffoorrtthhiissdd--bblloocckk**//iibblloocckk..iibb__ddbbaa[[ii]]==LLFF__DDNNUULLLL;;}} //**CClleeaarrooffffsseett((jjuussttttoommaakkeeddeebbuuggggiinnggeeaassiieerr))**//iibblloocckk..iibb__ooffffsseett==00;;//**FFoorrtthheellaassttiinnddeexxbblloocckkoonntthheelliisstt,,mmaakkeeiittppooiinntt**//Sec. 19.23        File Truncation (lftruncate) 501//**ttootthheeccuurrrreennttffrreeeelliisstt**//iiff((iibblloocckk..iibb__nneexxtt====LLFF__IINNUULLLL)){{iibblloocckk..iibb__nneexxtt==iiffrreeee;;}} //**WWrriitteecclleeaarreeddii--bblloocckkbbaacckkttooddiisskk**//llffiibbppuutt((LLff__ddaattaa..llff__ddsskkddeevv,,nneexxttiibb,,&&iibblloocckk));;}} //**LLaassttiinnddeexxbblloocckkoonntthheeffiilleelliissttnnoowwppooiinnttssttooffiirrssttnnooddee**////**oonntthheeccuurrrreennttffrreeeelliisstt..OOnncceewweemmaakkeetthheeffrreeeelliisstt**////**ppooiinnttttootthheeffiirrssttiinnddeexxbblloocckkoonntthheeffiilleelliisstt,,tthhee**////**eennttiirreesseettooffiinnddeexxbblloocckksswwiillllbbeeoonntthheeffrreeeelliisstt**//LLff__ddaattaa..llff__ddiirr..llffdd__iiffrreeee==ffiirrssttiibb;;//**IInnddiiccaatteetthhaattddiirreeccttoorryyhhaasscchhaannggeeddaannddrreettuurrnn**//LLff__ddaattaa..llff__ddiirrddiirrttyy==TTRRUUEE;;rreettuurrnnOOKK;;}}The approach used is straightforward: if the file already has length zero, return tothe caller. Otherwise, walk along the file’s index block list. Read each index blockinto memory, and call lfdbfree to free each data block to which the index block points.Once the final index block has been reached, add all the index blocks for the file tothe free list. To do so, observe that all index blocks for the file are already linked.Thus, only two pointer changes are needed. First, change the next pointer in the finalindex block of the file to point to the current free list. Second, change the free list topoint to the first index block of the file.19.24 Initial File System Creation (lfscreate)A final initialization function will complete details of the file system. Function lfscreate creates an initial, empty file system on a disk. That is, it forms a free list of index blocks, a free list of data blocks, and a directory that contains no files. Filelfscreate.c contains the code.502File Systems Chap. 19//**llffssccrreeaattee..cc--llffssccrreeaattee**//##iinncclluuddee<<xxiinnuu..hh>>##iinncclluuddee<<rraammddiisskk..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**llffssccrreeaattee--CCrreeaatteeaanniinniittiiaallllyy--eemmppttyyffiilleessyysstteemmoonnaaddiisskk**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussllffssccrreeaattee((ddiidd3322ddiisskk,,//**IIDDooffaannooppeennddiisskkddeevviiccee**//iibbiidd3322llffiibbllkkss,,//**NNuumm..ooffiinnddeexxbblloocckkssoonnddiisskk**//uuiinntt3322ddssiizz//**TToottaallssiizzeeooffddiisskkiinnbbyytteess**//)){{uuiinntt3322sseeccttoorrss;;//**NNuummbbeerrooffsseeccttoorrssttoouussee**//uuiinntt3322iibbsseeccttoorrss;;//**NNuummbbeerrooffsseeccttoorrssooffii--bblloocckkss**//uuiinntt3322iibbppeerrsseeccttoorr;;//**NNuummbbeerrooffii--bblloocckkssppeerrsseeccttoorr**//ssttrruuccttllffddiirrddiirr;;//**BBuuffffeerrttoohhoollddtthheeddiirreeccttoorryy**//uuiinntt3322ddbbllkkss;;//**TToottaallffrreeeeddaattaabblloocckkss**//ssttrruuccttllffiibbllkkiibblloocckk;;//**SSppaacceeffoorroonneeii--bblloocckk**//ssttrruuccttllffddbbffrreeeeddbblloocckk;;//**DDaattaabblloocckkoonntthheeffrreeeelliisstt**//ddbbiidd3322ddbbiinnddeexx;;//**IInnddeexxffoorrddaattaabblloocckkss**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluueeffrroommffuunnccccaallll**//iinntt3322ii;;//**LLooooppiinnddeexx**////**CCoommppuutteettoottaallsseeccttoorrssoonnddiisskk**//sseeccttoorrss==ddssiizz//LLFF__BBLLKKSSIIZZ;;//**TTrruunnccaatteettooffuullllsseeccttoorr**////**CCoommppuutteennuummbbeerrooffsseeccttoorrssccoommpprriissiinnggii--bblloocckkss**//iibbppeerrsseeccttoorr==LLFF__BBLLKKSSIIZZ//ssiizzeeooff((ssttrruuccttllffiibbllkk));;iibbsseeccttoorrss==((llffiibbllkkss++((iibbppeerrsseeccttoorr--11))))//iibbppeerrsseeccttoorr;;//**RRoouunndduupp**//llffiibbllkkss==iibbsseeccttoorrss**iibbppeerrsseeccttoorr;;iiff((iibbsseeccttoorrss>>sseeccttoorrss//22)){{//**IInnvvaalliiddaarrgguummeennttss**//rreettuurrnnSSYYSSEERRRR;;}} //**CCrreeaatteeaanniinniittiiaallddiirreeccttoorryy**//mmeemmsseett((((cchhaarr**))&&ddiirr,,NNUULLLLCCHH,,ssiizzeeooff((ssttrruuccttllffddiirr))));;ddiirr..llffdd__nnffiilleess==00;;ddbbiinnddeexx==((ddbbiidd3322))((iibbsseeccttoorrss++11));;ddiirr..llffdd__ddffrreeee==ddbbiinnddeexx;;Sec. 19.24        Initial File System Creation (lfscreate) 503ddbbllkkss==sseeccttoorrss--iibbsseeccttoorrss--11;;rreettvvaall==wwrriittee((ddiisskk,,((cchhaarr**))&&ddiirr,,LLFF__AARREEAA__DDIIRR));;iiff((rreettvvaall====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**CCrreeaatteelliissttooffffrreeeeii--bblloocckkssoonnddiisskk**//llffiibbcclleeaarr((&&iibblloocckk,,00));;ffoorr((ii==00;;ii<<llffiibbllkkss--11;;ii++++)){{iibblloocckk..iibb__nneexxtt==((iibbiidd3322))((ii++11));;llffiibbppuutt((ddiisskk,,ii,,&&iibblloocckk));;}} iibblloocckk..iibb__nneexxtt==LLFF__IINNUULLLL;;llffiibbppuutt((ddiisskk,,ii,,&&iibblloocckk));;//**CCrreeaatteelliissttooffffrreeeeddaattaabblloocckkssoonnddiisskk**//mmeemmsseett((((cchhaarr**))&&ddbblloocckk,,NNUULLLLCCHH,,LLFF__BBLLKKSSIIZZ));;ffoorr((ii==00;;ii<<ddbbllkkss--11;;ii++++)){{ddbblloocckk..llff__nneexxttddbb==ddbbiinnddeexx++11;;wwrriittee((ddiisskk,,((cchhaarr**))&&ddbblloocckk,,ddbbiinnddeexx));;ddbbiinnddeexx++++;;}} ddbblloocckk..llff__nneexxttddbb==LLFF__DDNNUULLLL;;wwrriittee((ddiisskk,,((cchhaarr**))&&ddbblloocckk,,ddbbiinnddeexx));;cclloossee((ddiisskk));;rreettuurrnnOOKK;;}}19.25 PerspectiveFile systems are among the most complex pieces of an operating system. Our im-plementation avoids one of the most challenging problems, sharing, by imposing a res-triction: a file can only be opened once at a given time. If the restriction is relaxed, a file system must coordinate operations among multiple file descriptors that can refer to the same file. Sharing raises the question of semantics: how should overlapping write operations be interpreted? In particular, if a process attempts to write bytes 0 through N of a file and another process simultaneously attempts to write bytes 2 through N-1 of the same file, what should happen? Should the file system guarantee that one of the two operations occurs first? Should the file system allow bytes to be intermingled? How should the file system manage a shared cache to make operations efficient?504File Systems Chap. 19A second form of complexity arises from the implementation. All operations onfiles must be translated into operations on disk blocks. As a result, basic data struc-tures, such as linked lists, can be complex to manipulate. Interestingly, much of the complexity arises when disk blocks are shared. For example, because a given disk block can hold index blocks from multiple files, two processes may need to access the same disk block simultaneously. Most file systems arrange to cache disk blocks, mak-ing such access efficient.A final form of complexity arises from the need for safety and recovery. Users as-sume that once data has been written to a file, the data is “safe,” even if the power fails. However, a file system cannot afford to write to disk each time an application stores a byte in a file. Thus, one of the grand challenges of file system design arises from the tradeoff between efficiency and safety — a designer looks for ways to minimize the risk of losing data while also looking for ways to maximize efficiency.19.26 SummaryA file system manages objects on nonvolatile storage. To ensure the interface tofiles is the same as the interface to devices, our example system is organized into amaster file system device and a set of file pseudo-devices. To access a file, a process opens the master device; the call returns the descriptor of a pseudo-device for the file. Once a file has been opened, functions read, write, getc, putc, seek, and close can be used on the file.Our design allows files to grow dynamically; the data structures for a file consistof a directory entry and a linked list of index blocks that each point to a set of datablocks. When a file is used, the driver software loads an index block and data blockinto memory. Subsequent accesses or changes to a file affect the data block in memory. When the file position moves outside the current block, the file system writes the data block back to disk and allocates another data block. Similarly, when the file position moves outside the data covered by the current index block, the system writes the current index block to disk and allocates a new index block.EXERCISES19.1  Consider the amount of code needed for the Xinu file system. Can you find an alterna-tive file system design that provides equivalent functionality, but requires substantiallyless code?19.2 Redesign functions lflread and lflwrite to perform high-speed copies (i.e., copy bytesfrom or to the current data block without making repeated calls to lflgetc or lflputc.19.3     Redesign the system to permit multiple processes to open the same file simultaneously.Coordinate all writes to ensure that a given byte in the file always contains the data writ-ten last.Exercises50519.4  Free data blocks are chained together on a singly-linked list. Redesign the system toplace them in a file (i.e., reserve index block 0 to be an unnamed “file” in which index blocks point to free data blocks). Compare the performance of the new and original designs.19.5 What are the maximum number of disk accesses necessary to allocate and free a datablock under the original design and the new design in the previous exercise?19.6 The number of index blocks is important because having too many wastes space thatcould be used for data, while having too few means data blocks will be wasted because there are insufficient index blocks to use them. Given that there are 16 data block pointers in an index block and 7 index blocks fill a disk block, how many index blocks might be needed for a disk of n total blocks if the directory can hold k files?19.7  Current index block IDs are 32 bits long. Redesign the system to use 16-bit index blockIDs. What are the tradeoffs of the two approaches?19.8 Redesign the system so it closes all files that have been opened by a process when theprocess terminates.19.9 Change the system to have a file switch table separate from the device switch table.What are the advantages and disadvantages of each approach?19.10  After modifying the free list, function lfiballoc writes a copy of the directory to disk. Asan alternative, lfiballoc could mark the directory “dirty” and defer the write operationuntil later. Discuss the advantages and disadvantages of each approach.19.11  Consider two processes attempting to write to a single file. Suppose one process repeat-edly writes 20 bytes of character A and the other process repeatedly writes 20 bytes of character B. Describe the order in which characters might appear in the file.19.12    Create a control function for the file pseudo-device driver that allows a caller to invokelftruncate.19.13    Create a control function for the master file system device that allows a caller to invokelfscreate.Chapter Contents20.1 Introduction, 50920.2 Remote File Access, 50920.3 Remote File Semantics, 51020.4 Remote File Design And Messages, 51020.5 Remote File Server Communication (rfscomm), 51820.6 Sending A Basic Message (rfsndmsg), 52020.7 Network Byte Order, 52220.8 A Remote File System Using A Device Paradigm, 52220.9 Opening A Remote File (rfsopen), 52420.10 Checking The File Mode (rfsgetmode), 527 20.11 Closing A Remote File (rflclose), 52820.12 Reading From A Remote File (rflread), 529 20.13 Writing To A Remote File (rflwrite), 532 20.14 Seeking On A Remote File (rflseek), 53520.15 Character I/O On A Remote File (rflgetc, rflputc), 536 20.16 Remote File System Control Functions (rfscontrol), 537 20.17 Initializing The Remote File System (rfsinit, rflinit), 541 20.18 Perspective, 54320.19 Summary, 54320A Remote File Mechanism
Networking makes the far-away the here-and-now.— Unknown20.1 IntroductionChapter 16 discusses a network interface and a device driver that uses the hardware interface to send and receive packets. Chapter 18 considers disk hardware and theblock transfer paradigm. Chapter 19 explains how a file system creates high-level abstractions, including dynamic files, and shows how files can be mapped onto a disk.This chapter expands the discussion of file systems by considering an alternativethat uses a remote file server. That is, instead of implementing the file abstractiondirectly on hardware, the operating system relies on a separate computer called a server. When an application requests a file operation, the operating system sends a request to the server and receives a response. The next chapter extends the discussion by showing how a remote and local file system can be integrated.20.2 Remote File AccessA remote file access mechanism requires four conceptual pieces. First, an operat-ing system must contain a device driver for a network device (such as an Ethernet). Second, the operating system must also contain protocol software (such as UDP and IP) that handles addressing so the packets can reach the remote server and replies can re-turn. Third, the operating system must have remote file access software that becomes a client (i.e., forms a request, uses the network to send the request to the server and re-509510 A Remote File Mechanism Chap. 20ceive a response, and interprets the response). Whenever a process invokes an I/O operation on a remote file (e.g., read or write), the remote file access software forms a message that specifies the operation, sends the request to the remote file server, and processes the response. Fourth, a computer on the network must be running a remote file server application that honors each request.In practice, many questions arise about the design of a remote file access mecha-nism. What services should a remote file server provide? Should the service permit a client to create hierarchical directories, or should the server only permit a client to create data files? Should the mechanism allow a client to remove files? If two or more clients send requests to a given server, should the files be shared or should each client have its own files? Should a file be cached in the memory of the client machine? For example, when a process reads a byte from a remote file, should the client software re-quest one-thousand bytes and hold the extra bytes in a cache to avoid sending requests to the remote server for successive bytes?20.3 Remote File SemanticsOne of the primary design considerations surrounding remote file systems arises from heterogeneity: the operating systems on the client and server machines may differ. As a result, the file operations available to the remote server may differ from the file operations used on the client machine. For example, because the file server we use runs on a Unix system (e.g., Linux or Solaris), the server supplies functionality from the Unix file system, not from Xinu.Some of the Xinu file operations map directly to Unix file operations. For exam-ple, Xinu uses the same semantics for read as Unix — a request specifies a buffer size and read specifies the number of data bytes that were placed in the buffer. Similarly, a Xinu write operation follows the same semantics as a Unix write.However, Xinu semantics do differ from Unix semantics in many ways. EachUnix file has an owner that is identified by a Unix userid; Xinu does not have userids,and even if it did, they would not align with the userids used by the server. Even small details differ. For example, the mode argument used with a Xinu open operation allows a caller to specify that the file must be new (i.e., must not exist) or that the file must be old (i.e., must exist). Unix allows a file to be created, but does not test whether the file already exists. Instead, if the file exists, Unix truncates the file to zero bytes. Thus, to implement the Xinu newmode, a remote server running on a Unix system must first test whether the file exists and return an error indication if it does.20.4 Remote File Design And MessagesOur example remote file system provides basic functionality: a Xinu process can create a file, write data to the file, seek to an arbitrary position in the file, read data from the file, truncate a file, and delete a file. The remote file system also allows aSec. 20.4        Remote File Design And Messages 511Xinu process to create or remove directories. However, the system does not permit processes on multiple computers to share files. For each operation, the system defines a request message (sent from a Xinu client to the remote file server) and a response mes-sage (sent from the server back to the Xinu client). Each message begins with a com-mon header that specifies the type of the operation, a status value (used in responses to report errors), a sequence number, and the name of a file. Each outgoing request is as-signed a unique sequence number, and the remote file software checks a reply to ensure that an incoming reply matches the outgoing request. Our implementation defines a structure for each message type. To avoid nested structure declarations, the code uses a preprocessor definition, RF_MSG_HDR, for the header fields, and then includes the header in each struct. File rfilesys.h contains the code.//**rrffiilleessyyss..hh--DDeeffiinniittiioonnssffoorrrreemmootteeffiilleessyysstteemmppsseeuuddoo--ddeevviicceess**//##iiffnnddeeffNNrrffll##ddeeffiinneeNNrrffll1100##eennddiiff//**CCoonnttrroollbblloocckkffoorraarreemmootteeffiilleeppsseeuuddoo--ddeevviiccee**//##ddeeffiinneeRRFF__NNAAMMLLEENN112288//**MMaaxxiimmuummlleennggtthhooffffiilleennaammee**//##ddeeffiinneeRRFF__DDAATTAALLEENN11002244//**MMaaxxiimmuummddaattaaiinnrreeaaddoorrwwrriittee**//##ddeeffiinneeRRFF__MMOODDEE__RRFF__MMOODDEE__RR//**BBiittttooggrraannttrreeaaddaacccceessss**//##ddeeffiinneeRRFF__MMOODDEE__WWFF__MMOODDEE__WW//**BBiittttooggrraannttwwrriitteeaacccceessss**//##ddeeffiinneeRRFF__MMOODDEE__RRWWFF__MMOODDEE__RRWW//**MMaasskkffoorrrreeaaddaannddwwrriitteebbiittss**//##ddeeffiinneeRRFF__MMOODDEE__NNFF__MMOODDEE__NN//**BBiittffoorr""nneeww""mmooddee**//##ddeeffiinneeRRFF__MMOODDEE__OOFF__MMOODDEE__OO//**BBiittffoorr""oolldd""mmooddee**//##ddeeffiinneeRRFF__MMOODDEE__NNOOFF__MMOODDEE__NNOO//**MMaasskkffoorr""nn""aanndd""oo""bbiittss**////**GGlloobbaallddaattaaffoorrtthheerreemmootteesseerrvveerr**//##iiffnnddeeffRRFF__SSEERRVVEERR__IIPP##ddeeffiinneeRRFF__SSEERRVVEERR__IIPP""112288..1100..33..5511""##eennddiiff##iiffnnddeeffRRFF__SSEERRVVEERR__PPOORRTT##ddeeffiinneeRRFF__SSEERRVVEERR__PPOORRTT3333112233##eennddiiff##iiffnnddeeffRRFF__LLOOCC__PPOORRTT##ddeeffiinneeRRFF__LLOOCC__PPOORRTT3333112233##eennddiiffssttrruuccttrrffddaattaa{{iinntt3322rrff__sseeqq;;//**NNeexxttsseeqquueenncceennuummbbeerrttoouussee**//uuiinntt3322rrff__sseerr__iipp;;//**SSeerrvveerrIIPPaaddddrreessss**//512 A Remote File Mechanism Chap. 20uuiinntt1166rrff__sseerr__ppoorrtt;;//**SSeerrvveerrUUDDPPppoorrtt**//uuiinntt1166rrff__lloocc__ppoorrtt;;//**LLooccaall((cclliieenntt))UUPPDDppoorrtt**//iinntt3322rrff__uuddpp__sslloott;;//**UUDDPPsslloottttoouussee**//ssiidd3322rrff__mmuutteexx;;//**MMuuttuuaalleexxcclluussiioonnffoorraacccceessss**//bbooooll88rrff__rreeggiisstteerreedd;;//**HHaassUUDDPPppoorrttbbeeeennrreeggiisstteerreedd??**//}};;eexxtteerrnnssttrruuccttrrffddaattaaRRff__ddaattaa;;//**DDeeffiinniittiioonnoofftthheeccoonnttrroollbblloocckkffoorraarreemmootteeffiilleeppsseeuuddoo--ddeevviiccee**//##ddeeffiinneeRRFF__FFRREEEE00//**EEnnttrryyiissccuurrrreennttllyyuunnuusseedd**//##ddeeffiinneeRRFF__UUSSEEDD11//**EEnnttrryyiissccuurrrreennttllyyiinnuussee**//ssttrruuccttrrffllccbbllkk{{iinntt3322rrffssttaattee;;//**EEnnttrryyiissffrreeeeoorruusseedd**//iinntt3322rrffddeevv;;//**DDeevviicceennuummbbeerroofftthhiissddeevv..**//cchhaarrrrffnnaammee[[RRFF__NNAAMMLLEENN]];;//**NNaammeeoofftthheeffiillee**//uuiinntt3322rrffppooss;;//**CCuurrrreennttffiilleeppoossiittiioonn**//uuiinntt3322rrffmmooddee;;//**MMooddee::rreeaaddaacccceessss,,wwrriittee**////**aacccceessssoorrbbootthh**//}};;eexxtteerrnnssttrruuccttrrffllccbbllkkrrffllttaabb[[]];;//**RReemmootteeffiilleeccoonnttrroollbblloocckkss**////**DDeeffiinniittiioonnssooffppaarraammeetteerrssuusseeddwwhheennaacccceessssiinnggaarreemmootteesseerrvveerr**//##ddeeffiinneeRRFF__RREETTRRIIEESS33//**TTiimmeettoorreettrryysseennddiinnggaammssgg**//##ddeeffiinneeRRFF__TTIIMMEEOOUUTT33000000//**WWaaiittoonneesseeccoonnddffoorraarreeppllyy**////**CCoonnttrroollffuunnccttiioonnssffoorraarreemmootteeffiilleeppsseeuuddooddeevviiccee**//##ddeeffiinneeRRFFSS__CCTTLL__DDEELLFF__CCTTLL__DDEELL//**DDeelleetteeaaffiillee**//##ddeeffiinneeRRFFSS__CCTTLL__TTRRUUNNCCFF__CCTTLL__TTRRUUNNCC//**TTrruunnccaatteeaaffiillee**//##ddeeffiinneeRRFFSS__CCTTLL__MMKKDDIIRRFF__CCTTLL__MMKKDDIIRR//**MMaakkeeaaddiirreeccttoorryy**//##ddeeffiinneeRRFFSS__CCTTLL__RRMMDDIIRRFF__CCTTLL__RRMMDDIIRR//**RReemmoovveeaaddiirreeccttoorryy**//##ddeeffiinneeRRFFSS__CCTTLL__SSIIZZEEFF__CCTTLL__SSIIZZEE//**OObbttaaiinntthheessiizzeeooffaaffiillee**////************************************************************************************************************************************************////** **////**DDeeffiinniittiioonnooffmmeessssaaggeesseexxcchhaannggeeddwwiitthhtthheerreemmootteesseerrvveerr**////** **////************************************************************************************************************************************************////**VVaalluueessffoorrtthheettyyppeeffiieellddiinnmmeessssaaggeess**//Sec. 20.4        Remote File Design And Messages 513##ddeeffiinneeRRFF__MMSSGG__RREESSPPOONNSSEE00xx00110000//**BBiitttthhaattiinnddiiccaatteessrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__RRRREEQQ00xx00000011//**RReeaaddRReeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__RRRREESS((RRFF__MMSSGG__RRRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__WWRREEQQ00xx00000022//**WWrriitteeRReeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__WWRREESS((RRFF__MMSSGG__WWRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__OORREEQQ00xx00000033//**OOppeennrreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__OORREESS((RRFF__MMSSGG__OORREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__DDRREEQQ00xx00000044//**DDeelleetteerreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__DDRREESS((RRFF__MMSSGG__DDRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__TTRREEQQ00xx00000055//**TTrruunnccaatteerreeqquueesstt&&rreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__TTRREESS((RRFF__MMSSGG__TTRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__SSRREEQQ00xx00000066//**SSiizzeerreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__SSRREESS((RRFF__MMSSGG__SSRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__MMRREEQQ00xx00000077//**MMkkddiirrrreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__MMRREESS((RRFF__MMSSGG__MMRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMSSGG__XXRREEQQ00xx00000088//**RRmmddiirrrreeqquueessttaannddrreessppoonnssee**//##ddeeffiinneeRRFF__MMSSGG__XXRREESS((RRFF__MMSSGG__XXRREEQQ||RRFF__MMSSGG__RREESSPPOONNSSEE))##ddeeffiinneeRRFF__MMIINN__RREEQQRRFF__MMSSGG__RRRREEQQ//**MMiinniimmuummrreeqquueessttttyyppee**//##ddeeffiinneeRRFF__MMAAXX__RREEQQRRFF__MMSSGG__XXRREEQQ//**MMaaxxiimmuummrreeqquueessttttyyppee**////**MMeessssaaggeehheeaaddeerrffiieellddsspprreesseennttiinneeaacchhmmeessssaaggee**//##ddeeffiinneeRRFF__MMSSGG__HHDDRR//**CCoommmmoonnmmeessssaaggeeffiieellddss**//\\uuiinntt1166rrff__ttyyppee;;//**MMeessssaaggeettyyppee**//\\uuiinntt1166rrff__ssttaattuuss;;//**00iinnrreeqq,,ssttaattuussiinnrreessppoonnssee**//\\uuiinntt3322rrff__sseeqq;;//**MMeessssaaggeesseeqquueenncceennuummbbeerr**//\\cchhaarrrrff__nnaammee[[RRFF__NNAAMMLLEENN]];;//**NNuullll--tteerrmmiinnaatteeddffiilleennaammee**////**TThheessttaannddaarrddhheeaaddeerrpprreesseennttiinnaallllmmeessssaaggeesswwiitthhnnooeexxttrraaffiieellddss**////************************************************************************************************************************************************////** **////**HHeeaaddeerr**////** **////************************************************************************************************************************************************//514 A Remote File Mechanism Chap. 20##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__hhddrr{{//**HHeeaaddeerrffiieellddsspprreesseennttiinneeaacchh**//RRFF__MMSSGG__HHDDRR//**rreemmootteeffiilleessyysstteemmmmeessssaaggee**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**RReeaadd**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__rrrreeqq{{//**RReemmootteeffiilleerreeaaddrreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrff__ppooss;;//**PPoossiittiioonniinnffiilleettoorreeaadd**//uuiinntt3322rrff__lleenn;;//**NNuummbbeerrooffbbyytteessttoorreeaadd**////**((bbeettwweeeenn11aanndd11002244))**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__rrrreess{{//**RReemmootteeffiilleerreeaaddrreeppllyy**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrff__ppooss;;//**PPoossiittiioonniinnffiillee**//uuiinntt3322rrff__lleenn;;//**NNuummbbeerrooffbbyytteesstthhaattffoollllooww**////**((00ffoorrEEOOFF))**//cchhaarrrrff__ddaattaa[[RRFF__DDAATTAALLEENN]];;//**AArrrraayyccoonnttaaiinniinnggddaattaaffrroomm**////**tthheeffiillee**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**WWrriittee**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__wwrreeqq{{//**RReemmootteeffiilleewwrriitteerreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrff__ppooss;;//**PPoossiittiioonniinnffiillee**//uuiinntt3322rrff__lleenn;;//**NNuummbbeerrooffvvaalliiddbbyytteessiinn**////**aarrrraayytthhaattffoolllloowwss**//Sec. 20.4        Remote File Design And Messages 515cchhaarrrrff__ddaattaa[[RRFF__DDAATTAALLEENN]];;//**AArrrraayyccoonnttaaiinniinnggddaattaattoobbee**////**wwrriitttteennttootthheeffiillee**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__wwrreess{{//**RReemmootteeffiilleewwrriitteerreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrff__ppooss;;//**OOrriiggiinnaallppoossiittiioonniinnffiillee**//uuiinntt3322rrff__lleenn;;//**NNuummbbeerrooffbbyytteesswwrriitttteenn**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**OOppeenn**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__oorreeqq{{//**RReemmootteeffiilleeooppeennrreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//iinntt3322rrff__mmooddee;;//**XXiinnuummooddeebbiittss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__oorreess{{//**RReemmootteeffiilleeooppeennrreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//iinntt3322rrff__mmooddee;;//**XXiinnuummooddeebbiittss**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**SSiizzee**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__ssrreeqq{{//**RReemmootteeffiilleessiizzeerreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())516 A Remote File Mechanism Chap. 20##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__ssrreess{{//**RReemmootteeffiilleessttaattuussrreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//uuiinntt3322rrff__ssiizzee;;//**SSiizzeeooffffiilleeiinnbbyytteess**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**DDeelleettee**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__ddrreeqq{{//**RReemmootteeffiilleeddeelleetteerreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__ddrreess{{//**RReemmootteeffiilleeddeelleetteerreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**TTrruunnccaattee**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__ttrreeqq{{//**RReemmootteeffiilleettrruunnccaatteerreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__ttrreess{{//**RReemmootteeffiilleettrruunnccaatteerreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **//Sec. 20.4        Remote File Design And Messages 517//**MMkkddiirr**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__mmrreeqq{{//**RReemmootteeffiilleemmkkddiirrrreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__mmrreess{{//**RReemmootteeffiilleemmkkddiirrrreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())//************************************************************************************************************************************************////** **////**RRmmddiirr**////** **////************************************************************************************************************************************************//##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__xxrreeqq{{//**RReemmootteeffiilleerrmmddiirrrreeqquueesstt**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())##pprraaggmmaappaacckk((22))ssttrruuccttrrff__mmssgg__xxrreess{{//**RReemmootteeffiilleerrmmddiirrrreessppoonnssee**//RRFF__MMSSGG__HHDDRR//**HHeeaaddeerrffiieellddss**//}};;##pprraaggmmaappaacckk(())In the file, constants that begin RF_MSG_ define a unique type value for each mes-sage. For example, RF_MSG_RREQ defines the type value used in a read requestmes-sage, and RF_MSG_RRES defines the type value used in a read response message. The implementation uses a trick to improve efficiency: rather than define arbitrary integers, the type of a response is formed by a logical or of the request type and constant RF_MSG_RESPONSE, which is defined to be 0x0100. That is, a response has the same type value as a request except that the low-order bit of the second byte is turned on.The size of a message depends on the type. Many of the messages only needfields in the common header. For example, a file deletion request only requires a type(to indicate that it is a deletion request), a file name, and a sequence number. Thus, the518 A Remote File Mechanism Chap. 20struct that defines a deletion request, rf_msg_dreq, only contains header fields. How-ever, a write request message must include a file offset, the number of data bytes in the request, and the data to be written. Consequently, the struct that defines a write request message, rf_msg_wreq, includes three additional fields beyond the common header.20.5 Remote File Server Communication (rfscomm)Our remote file system software follows a principle that works well in many cases:the functionality is separated into two levels of software. A lower level handles detailsof communication with the remote server — it sends a message, waits for a response,and handles retransmission, if necessary. An upper level handles message semantics —it forms a message, passes the message to the lower level for transmission, receives a response, and interprets the response. The important idea is that because it only handles transmission and reception, the lower level does not need to understand or interpret the contents of a message. Consequently, a single function provides all lower-level func-tionality.Examining the code will clarify the idea. Function rfscomm performs the action of sending a message to the remote file server and receiving a response. File rfscomm.c contains the code://**rrffssccoommmm..cc--rrffssccoommmm**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffssccoommmm--HHaannddlleeccoommmmuunniiccaattiioonnwwiitthhRRFFSSsseerrvveerr((sseennddrreeqquueessttaanndd**rreecceeiivveeaarreeppllyy,,iinncclluuddiinnggsseeqquueenncciinnggaannddrreettrriieess))**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322rrffssccoommmm((ssttrruuccttrrff__mmssgg__hhddrr**mmssgg,,//**MMeessssaaggeettoosseenndd**//iinntt3322mmlleenn,,//**MMeessssaaggeelleennggtthh**//ssttrruuccttrrff__mmssgg__hhddrr**rreeppllyy,,//**BBuuffffeerrffoorrrreeppllyy**//iinntt3322rrlleenn//**SSiizzeeooffrreeppllyybbuuffffeerr**//)){{iinntt3322ii;;//**CCoouunnttssrreettrriieess**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**//iinntt3322sseeqq;;//**SSeeqquueenncceeffoorrtthhiisseexxcchhaannggee**//iinntt1166rrttyyppee;;//**RReeppllyyttyyppeeiinnhhoossttbbyytteeoorrddeerr**//iinntt3322sslloott;;//**UUDDPPsslloott**////**FFoorrtthheeffiirrssttttiimmeeaafftteerrrreebboooott,,rreeggiisstteerrtthheesseerrvveerrppoorrtt**//Sec. 20.5        Remote File Server Communication (rfscomm) 519iiff((!!RRff__ddaattaa..rrff__rreeggiisstteerreedd)){{iiff((((rreettvvaall==uuddpp__rreeggiisstteerr((RRff__ddaattaa..rrff__sseerr__iipp,,RRff__ddaattaa..rrff__sseerr__ppoorrtt,,RRff__ddaattaa..rrff__lloocc__ppoorrtt))))====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} RRff__ddaattaa..rrff__uuddpp__sslloott==rreettvvaall;;RRff__ddaattaa..rrff__rreeggiisstteerreedd==TTRRUUEE;;}} //**AAssssiiggnnmmeessssaaggeenneexxttsseeqquueenncceennuummbbeerr**//sseeqq==RRff__ddaattaa..rrff__sseeqq++++;;mmssgg-->>rrff__sseeqq==hhttoonnll((sseeqq));;//**RReeppeeaattRRFF__RREETTRRIIEESSttiimmeess::sseennddmmeessssaaggeeaannddrreecceeiivveerreeppllyy**//ffoorr((ii==00;;ii<<RRFF__RREETTRRIIEESS;;ii++++)){{//**SSeennddaaccooppyyoofftthheemmeessssaaggee**//rreettvvaall==uuddpp__sseenndd((RRff__ddaattaa..rrff__uuddpp__sslloott,,((cchhaarr**))mmssgg,,mmlleenn));;iiff((rreettvvaall====SSYYSSEERRRR)){{kkpprriinnttff((""CCaannnnoottsseennddttoorreemmootteeffiilleesseerrvveerr\\nn""));;rreettuurrnnSSYYSSEERRRR;;}} //**RReecceeiivveeaarreeppllyy**//rreettvvaall==uuddpp__rreeccvv((RRff__ddaattaa..rrff__uuddpp__sslloott,,((cchhaarr**))rreeppllyy,,rrlleenn,,RRFF__TTIIMMEEOOUUTT));;iiff((rreettvvaall====TTIIMMEEOOUUTT)){{ccoonnttiinnuuee;;}}eellsseeiiff((rreettvvaall====SSYYSSEERRRR)){{kkpprriinnttff((""EErrrroorrrreeaaddiinnggrreemmootteeffiilleerreeppllyy\\nn""));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyytthhaattsseeqquueenncceeiinnrreeppllyymmaattcchheessrreeqquueesstt**//iiff((nnttoohhll((rreeppllyy-->>rrff__sseeqq))!!==sseeqq)){{ccoonnttiinnuuee;;}}520 A Remote File Mechanism Chap. 20//**VVeerriiffyytthheettyyppeeiinntthheerreeppllyymmaattcchheesstthheerreeqquueesstt**//rrttyyppee==nnttoohhss((rreeppllyy-->>rrff__ttyyppee));;iiff((rrttyyppee!!==((nnttoohhss((mmssgg-->>rrff__ttyyppee))||RRFF__MMSSGG__RREESSPPOONNSSEE)))){{ccoonnttiinnuuee;;}} rreettuurrnnrreettvvaall;;//**RReettuurrnnlleennggtthhttooccaalllleerr**//}} //**RReettrriieesseexxhhaauusstteeddwwiitthhoouuttssuucccceessss**//kkpprriinnttff((""TTiimmeeoouuttoonneexxcchhaannggeewwiitthhrreemmootteeffiilleesseerrvveerr\\nn""));;rreettuurrnnTTIIMMEEOOUUTT;;}}The four arguments specify the address of a message that should be sent to the server, the length of the message, the address of a buffer that will hold a response mes-sage, and the length of the buffer. After assigning a unique sequence number to the message, rfscomm enters a loop that iterates RF_RETRIES times. On each iteration, rfscomm uses function udp_send to send a copy of the request message over the net-work† and function udp_recv to receive a response.Udp_recv allows a caller to specify a maximum time to wait for a response; rfscomm specifies RF_TIMEOUT.‡ If no message arrives within the specified time, udp_recv returns the value TIMEOUT, and the loop continues by transmitting anothercopy of the request. If no response arrives after RF_RETRIES attempts, rfscomm re-turns TIMEOUT to its caller.If a response does arrive, rfscomm verifies that the sequence number matches the sequence number in the outgoing request and the message type in the incoming message is the response for the outgoing request. If either test fails, the server formed the mes-sage incorrectly or the message was intended for another client on the network. In ei-ther case, rfscomm continues the loop, sending another copy of the request and waiting for a response to arrive. If the two tests succeed, the incoming message is a valid response, and rfscomm returns the length of the response to its caller.20.6 Sending A Basic Message (rfsndmsg)To understand how rfscomm functions, consider a message that only requires the common header fields. For example, the request and response messages used for a truncate operation consist of a message header. Because multiple message types only have the common header fields, function rfsndmsg has been created to send such a mes-sage. File rfsndmsg.c contains the code.†We say that rfscomm sends a copy of the message because the original message remains unchanged. ‡RF_TIMEOUT is defined to be 1000 milliseconds (i.e., one second), which is ample time for a client totransmit a message across a network to a server and a server to send a response back to the client.Sec. 20.6        Sending A Basic Message (rfsndmsg) 521//**rrffssnnddmmssgg..cc--rrffssnnddmmssgg**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffssnnddmmssgg--CCrreeaatteeaannddsseennddaammeessssaaggeetthhaattoonnllyyhhaasshheeaaddeerrffiieellddss**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussrrffssnnddmmssgg((uuiinntt1166ttyyppee,,//**MMeessssaaggeettyyppee**//cchhaarr**nnaammee//**NNuullll--tteerrmmiinnaatteeddffiilleennaammee**//)){{ssttrruuccttrrff__mmssgg__hhddrrrreeqq;;//**RReeqquueessttmmeessssaaggeettoosseenndd**//ssttrruuccttrrff__mmssgg__hhddrrrreesspp;;//**BBuuffffeerrffoorrrreessppoonnssee**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**//cchhaarr**ttoo;;//**UUsseedddduurriinnggnnaammeeccooppyy**////**FFoorrmmaarreeqquueesstt**//rreeqq..rrff__ttyyppee==hhttoonnss((ttyyppee));;rreeqq..rrff__ssttaattuuss==hhttoonnss((00));;rreeqq..rrff__sseeqq==00;;//**RRffssccoommmmwwiillllsseettsseeqquueennccee**//ttoo==rreeqq..rrff__nnaammee;;wwhhiillee((((**ttoo++++==**nnaammee++++)))){{//**CCooppyynnaammeettoorreeqquueesstt**//;;}} //**SSeennddmmeessssaaggeeaannddrreecceeiivveerreessppoonnssee**//rreettvvaall==rrffssccoommmm((&&rreeqq,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__hhddrr)),,&&rreesspp,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__hhddrr))));;//**CChheecckkrreessppoonnssee**//iiff((rreettvvaall====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((rreettvvaall====TTIIMMEEOOUUTT)){{kkpprriinnttff((""TTiimmeeoouuttdduurriinnggrreemmootteeffiilleesseerrvveerraacccceessss\\nn""));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnttoohhll((rreesspp..rrff__ssttaattuuss))!!==00)){{rreettuurrnnSSYYSSEERRRR;;}} rreettuurrnnOOKK;;}}522 A Remote File Mechanism Chap. 20Rfsndmsg takes two arguments that specify the type of the message to send and the name of a file. To create a request message, the code assigns a value to each field of variable req. It then calls rfscomm to transmit the message and receive a response. If rfscomm reports an error or timeout or if the status in the response indicates an error, rfsndmsg returns SYSERR to its caller. Otherwise, rfsndmsg returns OK.20.7 Network Byte OrderRemote file access raises an important consideration: the format of integers (i.e., endianness) depends on the computer architecture. If one were to transfer an integerfrom the memory of one computer directly to the memory on another, the numeric value of the integer on the second computer may differ from the numeric value on the first. To accommodate differences, software that sends data over a computer network follows the convention of converting integers from the local byte order to a standard known as network byte order, and software that receives data from a computer network converts integers from network byte order to the local byte order. We can summarize:To accommodate differences in endianness, an integer value sent from one computer to another is converted to network byte order before sending and converted to local byte order upon reception. In our design, upper-level functions perform the conversion.Xinu follows the Unix naming convention for byte-order transform functions. Function htonl (htons) transforms an integer (a short integer) from local host byte order to network byte order; function ntohl (ntohs) transforms an integer (a short integer) from network byte order to local byte order. For example, function rfsndmsg uses htonsto convert the integers that specify the message type and status from local byte order to network byte order.20.8 A Remote File System Using A Device ParadigmAs we have seen, Xinu uses a device paradigm for both devices and files. The re-mote file system follows the pattern. Figure 20.1 shows an excerpt from the Xinu Con-figuration file that defines the type of a remote file system master device and a set of remote file pseudo-devices.Sec. 20.8        A Remote File System Using A Device Paradigm 523//**RReemmootteeFFiilleeSSyysstteemmmmaasstteerrddeevviicceettyyppee**//rrffss::oonnuuddpp--iirrffssiinniitt--oorrffssooppeenn--cciiooeerrrr--rriiooeerrrr--ggiiooeerrrr--ppiiooeerrrr--wwiiooeerrrr--ssiiooeerrrr--nnrrffssccoonnttrrooll--iinnttrrNNUULLLL//**RReemmootteeffiilleeppsseeuuddoo--ddeevviicceettyyppee**//rrffll::oonnrrffss--iirrfflliinniitt--ooiiooeerrrr--ccrrffllcclloossee--rrrrffllrreeaadd--ggrrffllggeettcc--pprrffllppuuttcc--wwrrffllwwrriittee--ssrrffllsseeeekk--nniiooeerrrr--iinnttrrNNUULLLLFigure 20.1Excerpt from a Xinu Configuration file that defines the two de-vice types used by the remote file system.Figure 20.2 contains an excerpt from the Configuration file that defines a remote file system master device (RFILESYS) and a set of six remote file pseudo-devices (RFILE0 through RFILE5).//**RReemmootteeffiilleessyysstteemmmmaasstteerrddeevviiccee((oonneeppeerrssyysstteemm))**//RRFFIILLEESSYYSSiissrrffssoonnuuddpp//**RReemmootteeffiilleeppsseeuuddoo--ddeevviicceess((mmaannyyiinnssttaanncceessppeerrssyysstteemm))**//RRFFIILLEE00iissrrfflloonnrrffssRRFFIILLEE11iissrrfflloonnrrffssRRFFIILLEE22iissrrfflloonnrrffssRRFFIILLEE33iissrrfflloonnrrffssRRFFIILLEE44iissrrfflloonnrrffssRRFFIILLEE55iissrrfflloonnrrffssFigure 20.2Excerpt from a Xinu Configuration file that defines devices usedby the remote file system.When an application calls open on the remote file system master device, the call allocates one of the remote file pseudo-devices and returns the device ID of the allocat-524 A Remote File Mechanism Chap. 20ed pseudo-device. The application uses the device ID in calls to read and write, and eventually calls close to deallocate the pseudo-device. The next sections define the de-vice driver functions used for both the remote file system master device and the remote file pseudo-devices.20.9 Opening A Remote File (rfsopen)To open a remote file, a program calls open on device RFILESYS, supplying a file name and mode argument.  Open invokes function rfsopen, which forms a request and uses rfscomm to communicate with the remote file server. If it succeeds, the call to open returns the descriptor of a remote file pseudo-device that is associated with the open file (i.e., can be used to write data into the file or read data from the file). File rfsopen.c contains the code://**rrffssooppeenn..cc--rrffssooppeenn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffssooppeenn--AAllllooccaatteeaarreemmootteeffiilleeppsseeuuddoo--ddeevviicceeffoorraassppeecciiffiiccffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffssooppeenn((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**nnaammee,,//**FFiilleennaammeettoouussee**//cchhaarr**mmooddee//**MMooddeecchhaarrss::’’rr’’’’ww’’’’oo’’’’nn’’**//)){{ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPttrrttooccoonnttrroollbblloocckkeennttrryy**//ssttrruuccttrrff__mmssgg__oorreeqqmmssgg;;//**MMeessssaaggeettoobbeesseenntt**//ssttrruuccttrrff__mmssgg__oorreessrreesspp;;//**BBuuffffeerrttoohhoollddrreessppoonnssee**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluueeffrroommrrffssccoommmm**//iinntt3322lleenn;;//**CCoouunnttsscchhaarrssiinnnnaammee**//cchhaarr**nnppttrr;;//**PPooiinntteerriinnttoonnaammeessttrriinngg**//cchhaarr**ffppttrr;;//**PPooiinntteerriinnttooffiilleennaammee**//iinntt3322ii;;//**GGeenneerraallllooooppiinnddeexx**////**WWaaiittffoorreexxcclluussiivveeaacccceessss**//wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;//**SSeeaarrcchhccoonnttrroollbblloocckkaarrrraayyttooffiinnddaaffrreeeeeennttrryy**//Sec. 20.9        Opening A Remote File (rfsopen) 525ffoorr((ii==00;;ii<<NNrrffll;;ii++++)){{rrffppttrr==&&rrffllttaabb[[ii]];;iiff((rrffppttrr-->>rrffssttaattee====RRFF__FFRREEEE)){{bbrreeaakk;;}}}} iiff((ii>>==NNrrffll)){{//**NNooffrreeeettaabblleesslloottssrreemmaaiinn**//ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**CCooppyynnaammeeiinnttooffrreeeettaabblleesslloott**//nnppttrr==nnaammee;;ffppttrr==rrffppttrr-->>rrffnnaammee;;lleenn==00;;wwhhiillee((((**ffppttrr++++==**nnppttrr++++))!!==NNUULLLLCCHH)){{lleenn++++;;iiff((lleenn>>==RRFF__NNAAMMLLEENN)){{//**FFiilleennaammeeiissttoooolloonngg**//ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}}} //**VVeerriiffyytthhaattnnaammeeiissnnoonn--nnuullll**//iiff((lleenn====00)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**PPaarrsseemmooddeessttrriinngg**//iiff((((rrffppttrr-->>rrffmmooddee==rrffssggeettmmooddee((mmooddee))))====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**FFoorrmmaannooppeennrreeqquueessttttooccrreeaatteeaanneewwffiilleeoorrooppeennaannoollddoonnee**//mmssgg..rrff__ttyyppee==hhttoonnss((RRFF__MMSSGG__OORREEQQ));;//**RReeqquueessttaaffiilleeooppeenn**//mmssgg..rrff__ssttaattuuss==hhttoonnss((00));;mmssgg..rrff__sseeqq==00;;//**RRffssccoommmmffiillllssiinnsseeqq..nnuummbbeerr**//nnppttrr==mmssgg..rrff__nnaammee;;mmeemmsseett((nnppttrr,,NNUULLLLCCHH,,RRFF__NNAAMMLLEENN));;//**IInniittiiaalliizzeennaammeettoozzeerroobbyytteess**//526 A Remote File Mechanism Chap. 20wwhhiillee((((**nnppttrr++++==**nnaammee++++))!!==NNUULLLLCCHH)){{//**CCooppyynnaammeettoorreeqq..**//;;}} mmssgg..rrff__mmooddee==hhttoonnll((rrffppttrr-->>rrffmmooddee));;//**SSeettmmooddeeiinnrreeqquueesstt**////**SSeennddmmeessssaaggeeaannddrreecceeiivveerreessppoonnssee**//rreettvvaall==rrffssccoommmm((((ssttrruuccttrrff__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__oorreeqq)),,((ssttrruuccttrrff__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__oorreess))));;//**CChheecckkrreessppoonnssee**//iiff((rreettvvaall====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((rreettvvaall====TTIIMMEEOOUUTT)){{kkpprriinnttff((""TTiimmeeoouuttdduurriinnggrreemmootteeffiilleeooppeenn\\nn\\rr""));;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnttoohhss((rreesspp..rrff__ssttaattuuss))!!==00)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**SSeettiinniittiiaallffiilleeppoossiittiioonn**//rrffppttrr-->>rrffppooss==00;;//**MMaarrkkssttaatteeaassccuurrrreennttllyyuusseedd**//rrffppttrr-->>rrffssttaattee==RRFF__UUSSEEDD;;//**RReettuurrnnddeevviicceeddeessccrriippttoorrooffnneewwllyyccrreeaatteeddppsseeuuddoo--ddeevviiccee**//ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnrrffppttrr-->>rrffddeevv;;}}Before proceeding to check its arguments, rfsopen checks the remote pseudo-devices to ensure that one is available. The code then checks the file name to ensurethat the name is less than the maximum allowed and the mode string to ensure that the specification is valid.Sec. 20.9        Opening A Remote File (rfsopen) 527Before it allocates the remote file device, rfsopen must communicate with the re-mote server to ensure the remote server agrees the file can be opened. The code createsa request message, and uses rfscomm to send the message to the server. If a positive response arrives, rfsopen marks the control block entry for the remote file device as be-ing used, sets the initial file position to zero, and returns the descriptor to the caller.20.10 Checking The File Mode (rfsgetmode)When it needs to check the file mode argument, rfsopen calls function rfsgetmode,passing the mode string as an argument. The code can be found in file rfsgetmode.c://**rrffssggeettmmooddee..cc--rrffssggeettmmooddee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffssggeettmmooddee--PPaarrsseemmooddeeaarrgguummeennttaannddggeenneerraatteeiinntteeggeerrooffmmooddeebbiittss**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322rrffssggeettmmooddee((cchhaarr**mmooddee//**SSttrriinnggooffmmooddeecchhaarraacctteerrss**//)){{iinntt3322mmbbiittss;;//**MMooddeebbiittssttoorreettuurrnn((iinnhhoosstt**////**bbyytteeoorrddeerr))**//cchhaarrcchh;;//**NNeexxttcchhaarraacctteerriinnmmooddeessttrriinngg**//mmbbiittss==00;;//**MMooddeessttrriinnggssppeecciiffiieess::**////**rr--rreeaadd**////**ww--wwrriittee**////**oo--oolldd((ffiilleemmuusstteexxiisstt))**////**nn--nneeww((ccrreeaatteeaanneewwffiillee))**//wwhhiillee((((cchh==**mmooddee++++))!!==NNUULLLLCCHH)){{sswwiittcchh((cchh)){{ccaassee’’rr’’::iiff((mmbbiittss&&RRFF__MMOODDEE__RR)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==RRFF__MMOODDEE__RR;;ccoonnttiinnuuee;;528 A Remote File Mechanism Chap. 20ccaassee’’ww’’::iiff((mmbbiittss&&RRFF__MMOODDEE__WW)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==RRFF__MMOODDEE__WW;;ccoonnttiinnuuee;;ccaassee’’oo’’::iiff((mmbbiittss&&RRFF__MMOODDEE__OO||||mmbbiittss&&RRFF__MMOODDEE__NN)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==RRFF__MMOODDEE__OO;;bbrreeaakk;;ccaassee’’nn’’::iiff((mmbbiittss&&RRFF__MMOODDEE__OO||||mmbbiittss&&RRFF__MMOODDEE__NN)){{rreettuurrnnSSYYSSEERRRR;;}} mmbbiittss||==RRFF__MMOODDEE__NN;;bbrreeaakk;;ddeeffaauulltt::rreettuurrnnSSYYSSEERRRR;;}}}} //**IIffnneeiitthheerrrreeaaddnnoorrwwrriitteessppeecciiffiieedd,,aalllloowwbbootthh**//iiff((((mmbbiittss&&RRFF__MMOODDEE__RRWW))====00)){{mmbbiittss||==RRFF__MMOODDEE__RRWW;;}} rreettuurrnnmmbbiittss;;}}Rfsgetmode extracts characters from the mode string, ensures each is valid, and checks for illegal combinations (e.g., a mode string cannot specify both new and old modes). As it parses the mode string, rfsgetmode sets the bits in integer mbits. Once it has finished examining the string and checking the combinations, rfsgetmode returns in-teger mbits to the caller.20.11 Closing A Remote File (rflclose)Once a process has finished using a file, the process can call close to release the remote file device and make it available for the system to use for another file. For a re-mote file device, close invokes rflclose. In our implementation, closing a remote file is trivial. Function rflclose.c contains the code:Sec. 20.11        Closing A Remote File (rflclose) 529//**rrffllcclloossee..cc--rrffllcclloossee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffllcclloossee--CClloosseeaarreemmootteeffiilleeddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffllcclloossee((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**////**WWaaiittffoorreexxcclluussiivveeaacccceessss**//wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;//**VVeerriiffyyrreemmootteeffiilleeddeevviicceeiissooppeenn**//rrffppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrffppttrr-->>rrffssttaattee====RRFF__FFRREEEE)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**MMaarrkkddeevviicceecclloosseedd**//rrffppttrr-->>rrffssttaattee==RRFF__FFRREEEE;;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnOOKK;;}}After verifying that the device is currently open, rflclose sets the state of the con-trol block entry to RF_FREE. Note that this version of rflclose does not inform the re-mote file server that the file is closed. The exercises suggest redesigning the system to inform the remote server when a file is closed.20.12 Reading From A Remote File (rflread)Once a remote file has been opened, a process can read data from the file. Driverfunction rflread performs the read operation. The code can be found in file rflread.c:530 A Remote File Mechanism Chap. 20//**rrffllrreeaadd..cc--rrffllrreeaadd**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffllrreeaadd--RReeaaddddaattaaffrroommaarreemmootteeffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffllrreeaadd((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrooffbbyytteess**//iinntt3322ccoouunntt//**CCoouunnttooffbbyytteessttoorreeaadd**//)){{ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**//ssttrruuccttrrff__mmssgg__rrrreeqqmmssgg;;//**RReeqquueessttmmeessssaaggeettoosseenndd**//ssttrruuccttrrff__mmssgg__rrrreessrreesspp;;//**BBuuffffeerrffoorrrreessppoonnssee**//iinntt3322ii;;//**CCoouunnttssbbyytteessccooppiieedd**//cchhaarr**ffrroomm,,**ttoo;;//**UUsseedddduurriinnggnnaammeeccooppyy**//iinntt3322lleenn;;//**LLeennggtthhooffnnaammee**////**WWaaiittffoorreexxcclluussiivveeaacccceessss**//wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;//**VVeerriiffyyccoouunnttiisslleeggiittiimmaattee**//iiff((((ccoouunntt<<==00))||||((ccoouunntt>>RRFF__DDAATTAALLEENN)))){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyyppsseeuuddoo--ddeevviicceeiissiinnuussee**//rrffppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**IIffddeevviicceennoottccuurrrreennttllyyiinnuussee,,rreeppoorrttaanneerrrroorr**//iiff((rrffppttrr-->>rrffssttaattee====RRFF__FFRREEEE)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyyppsseeuuddoo--ddeevviicceeaalllloowwssrreeaaddiinngg**//Sec. 20.12        Reading From A Remote File (rflread) 531iiff((((rrffppttrr-->>rrffmmooddee&&RRFF__MMOODDEE__RR))====00)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**FFoorrmmrreeaaddrreeqquueesstt**//mmssgg..rrff__ttyyppee==hhttoonnss((RRFF__MMSSGG__RRRREEQQ));;mmssgg..rrff__ssttaattuuss==hhttoonnss((00));;mmssgg..rrff__sseeqq==00;;//**RRffssccoommmmwwiillllsseettsseeqquueennccee**//ffrroomm==rrffppttrr-->>rrffnnaammee;;ttoo==mmssgg..rrff__nnaammee;;mmeemmsseett((ttoo,,NNUULLLLCCHH,,RRFF__NNAAMMLLEENN));;//**SSttaarrttnnaammeeaassaallllzzeerroobbyytteess**//lleenn==00;;wwhhiillee((((**ttoo++++==**ffrroomm++++)))){{//**CCooppyynnaammeettoorreeqquueesstt**//iiff((++++lleenn>>==RRFF__NNAAMMLLEENN)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}}} mmssgg..rrff__ppooss==hhttoonnll((rrffppttrr-->>rrffppooss));;//**SSeettffiilleeppoossiittiioonn**//mmssgg..rrff__lleenn==hhttoonnll((ccoouunntt));;//**SSeettccoouunnttooffbbyytteessttoorreeaadd**////**SSeennddmmeessssaaggeeaannddrreecceeiivveerreessppoonnssee**//rreettvvaall==rrffssccoommmm((((ssttrruuccttrrff__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__rrrreeqq)),,((ssttrruuccttrrff__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__rrrreess))));;//**CChheecckkrreessppoonnssee**//iiff((rreettvvaall====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((rreettvvaall====TTIIMMEEOOUUTT)){{kkpprriinnttff((""TTiimmeeoouuttdduurriinnggrreemmootteeffiilleerreeaadd\\nn""));;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnttoohhss((rreesspp..rrff__ssttaattuuss))!!==00)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**CCooppyyddaattaattooaapppplliiccaattiioonnbbuuffffeerraanndduuppddaatteeffiilleeppoossiittiioonn**//532 A Remote File Mechanism Chap. 20ffoorr((ii==00;;ii<<hhttoonnll((rreesspp..rrff__lleenn));;ii++++)){{**bbuuffff++++==rreesspp..rrff__ddaattaa[[ii]];;}} rrffppttrr-->>rrffppooss++==hhttoonnll((rreesspp..rrff__lleenn));;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnhhttoonnll((rreesspp..rrff__lleenn));;}}Rflread begins by checking argument count to verify that the request is in range. Itthen verifies that the pseudo-device has been opened and the mode allows reading.Once the checking is complete, rflread performs the read operation: it forms a message, uses rfscomm to transmit a copy to the server and receive a response, and interprets the response.If rfscomm returns a valid response, the message will include the data that has been read. Rflread copies the data from the response message into the caller’s buffer, up-dates the file position, and returns the number of bytes to the caller.20.13 Writing To A Remote File (rflwrite)Writing to a remote file follows the same general paradigm as reading from a re-mote file. Driver function rflwrite performs the write operation; the code can be foundin file rflwrite.c://**rrffllwwrriittee..cc--rrffllwwrriittee**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffllwwrriittee--WWrriitteeddaattaattooaarreemmootteeffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffllwwrriittee((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**bbuuffff,,//**BBuuffffeerrooffbbyytteess**//iinntt3322ccoouunntt//**CCoouunnttooffbbyytteessttoowwrriittee**//)){{ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**//ssttrruuccttrrff__mmssgg__wwrreeqqmmssgg;;//**RReeqquueessttmmeessssaaggeettoosseenndd**//ssttrruuccttrrff__mmssgg__wwrreessrreesspp;;//**BBuuffffeerrffoorrrreessppoonnssee**//cchhaarr**ffrroomm,,**ttoo;;//**UUsseeddttooccooppyynnaammee**//Sec. 20.13        Writing To A Remote File (rflwrite) 533iinnttii;;//**CCoouunnttssbbyytteessccooppiieeddiinnttoorreeqq**//iinntt3322lleenn;;//**LLeennggtthhooffnnaammee**////**WWaaiittffoorreexxcclluussiivveeaacccceessss**//wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;//**VVeerriiffyyccoouunnttiisslleeggiittiimmaattee**//iiff((((ccoouunntt<<==00))||||((ccoouunntt>>RRFF__DDAATTAALLEENN)))){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**VVeerriiffyyppsseeuuddoo--ddeevviicceeiissiinnuusseeaannddmmooddeeaalllloowwsswwrriittiinngg**//rrffppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((((rrffppttrr-->>rrffssttaattee====RRFF__FFRREEEE))||||!!((rrffppttrr-->>rrffmmooddee&&RRFF__MMOODDEE__WW)))){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**FFoorrmmwwrriitteerreeqquueesstt**//mmssgg..rrff__ttyyppee==hhttoonnss((RRFF__MMSSGG__WWRREEQQ));;mmssgg..rrff__ssttaattuuss==hhttoonnss((00));;mmssgg..rrff__sseeqq==00;;//**RRffssccoommmmwwiillllsseettsseeqquueennccee**//ffrroomm==rrffppttrr-->>rrffnnaammee;;ttoo==mmssgg..rrff__nnaammee;;mmeemmsseett((ttoo,,NNUULLLLCCHH,,RRFF__NNAAMMLLEENN));;//**SSttaarrttnnaammeeaassaallllzzeerroobbyytteess**//lleenn==00;;wwhhiillee((((**ttoo++++==**ffrroomm++++)))){{//**CCooppyynnaammeettoorreeqquueesstt**//iiff((++++lleenn>>==RRFF__NNAAMMLLEENN)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}}} wwhhiillee((((**ttoo++++==**ffrroomm++++)))){{//**CCooppyynnaammeeiinnttoorreeqquueesstt**//;;}} mmssgg..rrff__ppooss==hhttoonnll((rrffppttrr-->>rrffppooss));;//**SSeettffiilleeppoossiittiioonn**//mmssgg..rrff__lleenn==hhttoonnll((ccoouunntt));;//**SSeettccoouunnttooffbbyytteessttoowwrriittee**//ffoorr((ii==00;;ii<<ccoouunntt;;ii++++)){{//**CCooppyyddaattaaiinnttoommeessssaaggee**//mmssgg..rrff__ddaattaa[[ii]]==**bbuuffff++++;;534 A Remote File Mechanism Chap. 20}} wwhhiillee((ii<<RRFF__DDAATTAALLEENN)){{mmssgg..rrff__ddaattaa[[ii++++]]==NNUULLLLCCHH;;}} //**SSeennddmmeessssaaggeeaannddrreecceeiivveerreessppoonnssee**//rreettvvaall==rrffssccoommmm((((ssttrruuccttrrff__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__wwrreeqq)),,((ssttrruuccttrrff__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__wwrreess))));;//**CChheecckkrreessppoonnssee**//iiff((rreettvvaall====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((rreettvvaall====TTIIMMEEOOUUTT)){{kkpprriinnttff((""TTiimmeeoouuttdduurriinnggrreemmootteeffiilleerreeaadd\\nn""));;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellsseeiiff((nnttoohhss((rreesspp..rrff__ssttaattuuss))!!==00)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} //**RReeppoorrttrreessuullttssttooccaalllleerr**//rrffppttrr-->>rrffppooss++==nnttoohhll((rreesspp..rrff__lleenn));;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnnnttoohhll((rreesspp..rrff__lleenn));;}}As with a read operation, rflwrite begins by checking the count argument, verify-ing that the pseudo-device is open and the mode allows writing.  Rflwrite then forms a request message and uses rfscomm to send the message to the server.Unlike a read request, an outgoing write request contains data. Thus, when form-ing the request, rflwrite copies data from the user’s buffer into the request message.When a response arrives, the response message does not contain a copy of the data that has been written. Thus, rflwrite uses the status field in the message to determine whether to report success or failure to the caller.Sec. 20.14        Seeking On A Remote File (rflseek) 53520.14 Seeking On A Remote File (rflseek)How should a seek operation be implemented for our remote file system? Thereare two possibilities. In one design, the system sends a message to the remote server,and the remote server seeks to the specified location in the file. In the other design, all location data is kept on the local computer, and each request to the server contains an explicit file position.Our implementation uses the latter: the current file position is stored in the control block entry for a remote file device. When read is called, rflread requests data from the server and updates the file position in the control block entry accordingly. The remote server does not record a position because each request includes explicit position infor-mation. An exercise considers a consequence of the design.Because all file position information is stored on the client, a seek operation can be performed locally. That is, the software stores the file position in the control block en-try for use on the next read or write operation. Function rflseek performs the seekoperation on a remote file device. The code can be found in file rflseek.c://**rrffllsseeeekk..cc--rrffllsseeeekk**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffllsseeeekk--CChhaannggeetthheeccuurrrreennttppoossiittiioonniinnaannooppeennffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffllsseeeekk((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//uuiinntt3322ppooss//**NNeewwffiilleeppoossiittiioonn**//)){{ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPooiinntteerrttooccoonnttrroollbblloocckk**////**WWaaiittffoorreexxcclluussiivveeaacccceessss**//wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;//**VVeerriiffyyrreemmootteeffiilleeddeevviicceeiissooppeenn**//rrffppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrffppttrr-->>rrffssttaattee====RRFF__FFRREEEE)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}536 A Remote File Mechanism Chap. 20//**SSeetttthheenneewwppoossiittiioonn**//rrffppttrr-->>rrffppooss==ppooss;;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnOOKK;;}}The code is trivial. After obtaining exclusive access, rflseek verifies that the de-vice has been opened. It then stores the file position argument in field rfpos of the con-trol block, signals the mutual exclusion semaphore, and returns. There is no need to contact the remote server.20.15 Character I/O On A Remote File (rflgetc, rflputc)Using a remote file server to read and write individual bytes of data is expensive because a message must be sent to the server for each byte. Rather than prohibit char-acter I/O, our implementations of getc and putc, call rflread and rflwrite, respectively. Thus, we allow a programmer to decide whether the cost is reasonable. Files rflgetc.c and rflputc.c contain the code.//**rrffllggeettcc..cc--rrffllggeettcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffllggeettcc--RReeaaddoonneecchhaarraacctteerrffrroommaarreemmootteeffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffllggeettcc((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{cchhaarrcchh;;//**CChhaarraacctteerrttoorreeaadd**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**//rreettvvaall==rrffllrreeaadd((ddeevvppttrr,,&&cchh,,11));;iiff((rreettvvaall!!==11)){{rreettuurrnnSSYYSSEERRRR;;}} rreettuurrnn((ddeevvccaallll))cchh;;}}Sec. 20.15        Character I  /O On A Remote File (rflgetc, rflputc) 537//**rrffllppuuttcc..cc--rrffllppuuttcc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffllppuuttcc--WWrriitteeoonneecchhaarraacctteerrttooaarreemmootteeffiillee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffllppuuttcc((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarrcchh//**CChhaarraacctteerrttoowwrriittee**//)){{ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPooiinntteerrttoorrffllccoonnttrroollbblloocckk**//rrffppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;iiff((rrffllwwrriittee((ddeevvppttrr,,&&cchh,,11))!!==11)){{rreettuurrnnSSYYSSEERRRR;;}} rreettuurrnnOOKK;;}}20.16 Remote File System Control Functions (rfscontrol)Several file operations are needed beyond open, read, write, and close. For exam-ple, it may be necessary to delete a file. The Xinu remote file system uses the control function to implement such functions. The table in Figure 20.3 lists the set of symbolic constants used for control functions along with the meaning of each.Constant MeaningRFS_CTL_DEL Delete the named fileRFS_CTL_TRUNC Truncate a named file to zero bytesRFS_CTL_MKDIR Make a directoryRFS_CTL_RMDIR Remove a directoryRFS_CTL_SIZE Return the current size of a file in bytesFigure 20.3  Control functions used with the remote file system.538 A Remote File Mechanism Chap. 20Because they refer to operations outside individual files, control operations are per-formed on the master device, RFILESYS, rather than on an individual file pseudo-device. Driver function rfscontrol implements the control operation; the code can befound in file rfscontrol.c://**rrffssccoonnttrrooll..cc--rrffssccoonnttrrooll**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffssccoonnttrrooll--PPrroovviiddeeccoonnttrroollffuunnccttiioonnssffoorrtthheerreemmootteeffiilleessyysstteemm**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffssccoonnttrrooll((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//iinntt3322ffuunncc,,//**AAccoonnttrroollffuunnccttiioonn**//iinntt3322aarrgg11,,//**AArrgguummeenntt##11**//iinntt3322aarrgg22//**AArrgguummeenntt##22**//)){{iinntt3322lleenn;;//**LLeennggtthhooffnnaammee**//ssttrruuccttrrff__mmssgg__ssrreeqqmmssgg;;//**BBuuffffeerrffoorrssiizzeerreeqquueesstt**//ssttrruuccttrrff__mmssgg__ssrreessrreesspp;;//**BBuuffffeerrffoorrssiizzeerreessppoonnssee**//ssttrruuccttrrffllccbbllkk**rrffppttrr;;//**PPooiinntteerrttooeennttrryyiinnrrffllttaabb**//cchhaarr**ttoo,,**ffrroomm;;//**UUsseedddduurriinnggnnaammeeccooppyy**//iinntt3322rreettvvaall;;//**RReettuurrnnvvaalluuee**////**WWaaiittffoorreexxcclluussiivveeaacccceessss**//wwaaiitt((RRff__ddaattaa..rrff__mmuutteexx));;//**CChheecckklleennggtthhaannddccooppyy((nneeeeddeeddffoorrssiizzee))**//rrffppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;ffrroomm==rrffppttrr-->>rrffnnaammee;;ttoo==mmssgg..rrff__nnaammee;;lleenn==00;;mmeemmsseett((ttoo,,NNUULLLLCCHH,,RRFF__NNAAMMLLEENN));;//**SSttaarrttnnaammeeaassaallllzzeerrooeess**//wwhhiillee((((**ttoo++++==**ffrroomm++++)))){{//**CCooppyynnaammeettoommeessssaaggee**//lleenn++++;;iiff((lleenn>>==((RRFF__NNAAMMLLEENN--11)))){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}}}Sec. 20.16        Remote File System Control Functions (rfscontrol) 539sswwiittcchh((ffuunncc)){{//**DDeelleetteeaaffiillee**//ccaasseeRRFFSS__CCTTLL__DDEELL::iiff((rrffssnnddmmssgg((RRFF__MMSSGG__DDRREEQQ,,((cchhaarr**))aarrgg11))====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} bbrreeaakk;;//**TTrruunnccaatteeaaffiillee**//ccaasseeRRFFSS__CCTTLL__TTRRUUNNCC::iiff((rrffssnnddmmssgg((RRFF__MMSSGG__TTRREEQQ,,((cchhaarr**))aarrgg11))====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} bbrreeaakk;;//**MMaakkeeaaddiirreeccttoorryy**//ccaasseeRRFFSS__CCTTLL__MMKKDDIIRR::iiff((rrffssnnddmmssgg((RRFF__MMSSGG__MMRREEQQ,,((cchhaarr**))aarrgg11))====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} bbrreeaakk;;//**RReemmoovveeaaddiirreeccttoorryy**//ccaasseeRRFFSS__CCTTLL__RRMMDDIIRR::iiff((rrffssnnddmmssgg((RRFF__MMSSGG__XXRREEQQ,,((cchhaarr**))aarrgg11))====SSYYSSEERRRR)){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} bbrreeaakk;;//**OObbttaaiinnccuurrrreennttffiilleessiizzee((nnoonn--ssttaannddaarrddmmeessssaaggeessiizzee))**//ccaasseeRRFFSS__CCTTLL__SSIIZZEE:://**HHaanndd--ccrraaffttaassiizzeerreeqquueessttmmeessssaaggee**//540 A Remote File Mechanism Chap. 20mmssgg..rrff__ttyyppee==hhttoonnss((RRFF__MMSSGG__SSRREEQQ));;mmssgg..rrff__ssttaattuuss==hhttoonnss((00));;mmssgg..rrff__sseeqq==00;;//**RRffssccoommmmwwiillllsseetttthheesseeqqnnuumm**////**SSeennddtthheerreeqquueessttttoosseerrvveerraannddoobbttaaiinnaarreessppoonnssee**//rreettvvaall==rrffssccoommmm((((ssttrruuccttrrff__mmssgg__hhddrr**))&&mmssgg,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__ssrreeqq)),,((ssttrruuccttrrff__mmssgg__hhddrr**))&&rreesspp,,ssiizzeeooff((ssttrruuccttrrff__mmssgg__ssrreess))));;iiff((((rreettvvaall====SSYYSSEERRRR))||||((rreettvvaall====TTIIMMEEOOUUTT)))){{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}}eellssee{{ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnnnttoohhll((rreesspp..rrff__ssiizzee));;}}ddeeffaauulltt::kkpprriinnttff((""rrffssccoonnttrrooll::ffuunnccttiioonn%%ddnnoottvvaalliidd\\nn"",,ffuunncc));;ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnSSYYSSEERRRR;;}} ssiiggnnaall((RRff__ddaattaa..rrff__mmuutteexx));;rreettuurrnnOOKK;;}}For all the control functions, argument arg1 contains a pointer to a null-terminated file name. After it obtains exclusive access and checks the length of the file name, rfscontrol uses the function argument to choose among several cases that correspond to file deletion, file truncation, directory creation, directory deletion, or a file size request. In each case, rfscontrol must send a message to the remote server and receive a response.Except for a file size request, all messages to the server only include the common header fields. Therefore, for all functions except a size request, rfscontrol uses function rfsndmsg to generate and send a request to the remote server. For a size request, rfscon-trol creates a message in variable msg, and uses rfscomm to send the message and re-ceive a response. To avoid scanning the file name twice, rfscontrol copies the file name into the name field of variable msg as it checks the length of the name. Thus, no extra copy is needed when rfscontrol creates a size request. If a valid response arrives to a size request, rfscontrol extracts the file size from the response, converts it to local byte order, and returns the size to the caller. In all other cases, rfscontrol returns a status of either OK or SYSERR.Sec. 20.17        Initializing The Remote File System (rfsinit, rflinit) 54120.17 Initializing The Remote File System (rfsinit, rflinit)Because the design includes both a remote file system master device and a set of remote file pseudo-devices, two initialization functions are needed. The first, rfsinit, in-itializes the control block associated with the master device.Data for the master device is kept in global variable Rf_data. Rfsinit fills in fields of the structure with the remote server’s IP address and UDP port number. It also allo-cates a mutual exclusion semaphore and stores the semaphore ID in the structure. Rfsinit sets field rf_registered to FALSE, indicating that before communication with the server is possible, the UDP port of the server must be registered with the network code. File rfsinit.c contains the code://**rrffssiinniitt..cc--rrffssiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttrrffddaattaaRRff__ddaattaa;;//**------------------------------------------------------------------------------------------------------------------------------------------------**rrffssiinniitt--IInniittiiaalliizzeetthheerreemmootteeffiilleessyysstteemmmmaasstteerrddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrffssiinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{//**CChhoooosseeaanniinniittiiaallmmeessssaaggeesseeqquueenncceennuummbbeerr**//RRff__ddaattaa..rrff__sseeqq==11;;//**SSeetttthheesseerrvveerrIIPPaaddddrreessss,,sseerrvveerrppoorrtt,,aannddllooccaallppoorrtt**//iiff((ddoott22iipp((RRFF__SSEERRVVEERR__IIPP,,&&RRff__ddaattaa..rrff__sseerr__iipp))====SSYYSSEERRRR)){{ppaanniicc((""iinnvvaalliiddIIPPaaddddrreessssffoorrrreemmootteeffiilleesseerrvveerr""));;}} RRff__ddaattaa..rrff__sseerr__ppoorrtt==RRFF__SSEERRVVEERR__PPOORRTT;;RRff__ddaattaa..rrff__lloocc__ppoorrtt==RRFF__LLOOCC__PPOORRTT;;//**CCrreeaatteeaammuuttuuaalleexxcclluussiioonnsseemmaapphhoorree**//iiff((((RRff__ddaattaa..rrff__mmuutteexx==sseemmccrreeaattee((11))))====SSYYSSEERRRR)){{ppaanniicc((""CCaannnnoottccrreeaatteerreemmootteeffiilleessyysstteemmsseemmaapphhoorree""));;}}542 A Remote File Mechanism Chap. 20//**SSppeecciiffyytthhaatttthheesseerrvveerrppoorrttiissnnoottyyeettrreeggiisstteerreedd**//RRff__ddaattaa..rrff__rreeggiisstteerreedd==FFAALLSSEE;;rreettuurrnnOOKK;;}}Function rflinit handles initialization of individual remote file devices. The codecan be found in file rflinit.c://**rrfflliinniitt..cc--rrfflliinniitt**//##iinncclluuddee<<xxiinnuu..hh>>ssttrruuccttrrffllccbbllkkrrffllttaabb[[NNrrffll]];;//**RReemmootteeffiilleeccoonnttrroollbblloocckkss**////**------------------------------------------------------------------------------------------------------------------------------------------------**rrfflliinniitt--IInniittiiaalliizzeeaarreemmootteeffiilleeddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllrrfflliinniitt((ssttrruuccttddeennttrryy**ddeevvppttrr//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//)){{ssttrruuccttrrffllccbbllkk**rrffllppttrr;;//**PPttrr..ttooccoonnttrroollbblloocckkeennttrryy**//iinntt3322ii;;//**WWaallkksstthhrroouugghhnnaammeeaarrrraarryy**//rrffllppttrr==&&rrffllttaabb[[ddeevvppttrr-->>ddvvmmiinnoorr]];;//**IInniittiiaalliizzeeeennttrryyttoouunnuusseedd**//rrffllppttrr-->>rrffssttaattee==RRFF__FFRREEEE;;rrffllppttrr-->>rrffddeevv==ddeevvppttrr-->>ddvvnnuumm;;ffoorr((ii==00;;ii<<RRFF__NNAAMMLLEENN;;ii++++)){{rrffllppttrr-->>rrffnnaammee[[ii]]==NNUULLLLCCHH;;}} rrffllppttrr-->>rrffppooss==rrffllppttrr-->>rrffmmooddee==00;;rreettuurrnnOOKK;;}}Rflinit sets the state of the entry to RF_FREE to indicate that the entry is currently unused. It also zeroes the name and mode fields. If the state is marked RF_FREE, no  references should occur to other fields of the entry. Placing zeroes in the fields aids de-bugging.Sec. 20.18        Perspective54320.18 PerspectiveAs with a local file system, the most complex decision involved in the design of a remote file system arises from the need to choose a balance between efficiency and sharing. To understand the choice, imagine multiple applications running on multiple computers all sharing a single file. At one extreme, to guarantee last-write semantics on a shared file, each file operation must be sent to the remote server so the requests can be serialized and operations can be applied to the file in the order they occur. At the other extreme, efficiency is maximized when a computer can cache files (or parts of files) and access items from the local cache. The goal is to devise a remote file system that maximizes performance when no sharing occurs, guarantees correctness in the pres-ence of sharing, and transitions gracefully and automatically between the two extremes.Sharing a remote file among multiple clients creates some unexpected subtleties.For example, consider the seek operation. Suppose a process on computer 1 writes1000 bytes to a file. Then a process on computer 2 seeks to the end of the file andwrites an additional 1000 bytes. Unless it contacts the server, the file access softwareon computer 1 cannot know that the file has been extended. Therefore, the software cannot determine whether a seek operation is valid without contacting the server. More important, the size of the file can continue to change while the communication takes place.20.19 SummaryA remote file access mechanism allows applications running on a client computerto access files stored on a remote server. The example design uses a device paradigmin which an application calls open on the remote file system master device to obtain theID of an individual remote file pseudo-device. The application can then use read and write on the pseudo-device.When an application accesses a remote file, the remote file software creates a mes-sage, sends the message to the remote file server, waits for a response, and interprets the response. The software transmits each request multiple times in case the network drops a packet or the server is too busy to answer.Operations such as file deletion, file truncation, creating and removing directories, and determining the current size of a file are handled with the control function. As with data transfer operations, each call to control results in the transmission of a request mes-sage and a response from the server.544 A Remote File Mechanism Chap. 20EXERCISES20.1  Modify the remote file server and rflclose. Arrange to have rflclose send a message tothe server when a file is closed, and have the server send a response.20.2 The underlying protocol limits a read request to RF_DATALEN bytes, and rflread rejectsany call that specifies more. Modify rflread to allow a user to request an arbitrary size,but still limit the size in a request message to RF_DATALEN (i.e., don’t reject large re-quests, but limit the data returned to RF_DATALEN bytes).20.3 As an alternative to the exercise above, devise a system in which rflread permits a callerto specify an arbitrary size read and sends multiple requests to the server to satisfy the request.20.4      The code in rflgetc calls rflread directly. What potential problem does such a direct callintroduce? Modify the code to use the device switch table when making the call.20.5 Our design keeps position information on the client side, which makes seek extremelyefficient. What limitation does the design impose? Hint: consider shared files.20.6     Consider an alternative design for the remote file system that improves efficiency. Ar-range rflread so it always requests RF_DATALEN bytes, even if the caller requestsfewer. Place extra bytes in a cache, making them available to subsequent calls.20.7 In the previous exercise, what is the chief disadvantage of caching data for subsequentreads? Hint: consider shared access to the server.20.8 Consider what happens if two clients attempt to use the remote file server at the sametime. When the clients boot, they each start their packet sequence number at 1, which makes the probability of conflict high. Revise the system to use a random starting se-quence number (and revise the server to accept arbitrary sequence numbers).20.9      Redesign the remote file system to allow multiple clients to share a given file.Chapter Contents21.1 Introduction, 54721.2 Transparency And A Namespace Abstraction, 54721.3 Myriad Naming Schemes, 54821.4 Naming System Design Alternatives, 55021.5 Thinking About Names Syntactically, 55021.6 Patterns And Replacements, 55121.7 Prefix Patterns, 55121.8 Implementation Of A Namespace, 55221.9 Namespace Data Structures And Constants, 55221.10 Adding Mappings To The Namespace Prefix Table, 553 21.11 Mapping Names With The Prefix Table, 55521.12 Opening A Named File, 559 21.13 Namespace Initialization, 56021.14 Ordering Entries In The Prefix Table, 562 21.15 Choosing A Logical Namespace, 56321.16 A Default Hierarchy And The Null Prefix, 564 21.17 Additional Object Manipulation Functions, 56421.18 Advantages And Limits Of The Namespace Approach, 566 21.19 Generalized Patterns, 56621.20 Perspective, 567 21.21 Summary, 56821A Syntactic Namespace
A rose by any other name ...— William Shakespeare21.1 IntroductionChapter 14 outlines a set of device-independent I/O operations, including read and write, and shows how a device switch table provides an efficient mapping betweenhigh-level operations and the driver functions for each device. Later chapters describe how device drivers are organized, and provide examples. The previous chapters illus-trate how a file system fits into the device paradigm, and illustrate the concept of pseudo-devices.This chapter considers a generalization of device names. It explains how namescan be viewed syntactically, and shows that both devices and files can be represented ina single unified namespace.21.2 Transparency And A Namespace AbstractionTransparency forms one of the fundamental principles in operating system design:Whenever possible, applications should remain unaware of implemen-tation details such as the location of an object or its representation.547548 A Syntactic Namespace Chap. 21For example, when an application creates a new process, the application does not need to know the location of the code or the location of the stack that is allocated. Similarly, when an application opens a local file, the application does not need to know which disk blocks the file occupies.In terms of file access, the Xinu paradigm seems to violate the principle of trans-parency because it requires the user to specify a file system name when opening a file. For example, the master device for the local file system is named LFILESYS. When aXinu system includes a remote file system, the violation of transparency becomes obvi-ous: a programmer must also know the master device for the remote file system, RFILESYS, and must choose between local and remote files. Furthermore, a file name must be chosen to match the naming convention used on the specified file system.How can we add transparency to file and device naming? The answer lies in a high-level abstraction called a namespace. Conceptually, a namespace provides a uni-form set of names that knits together apparently diverse file naming schemes into a sin-gle unified whole, allowing users to open files and devices without knowing their loca-tion. The Unix operating system uses a directory abstraction to provide a namespace: local files, remote files, and devices are each assigned names in a hierarchical directory namespace. For example, the name /  dev/  console usually corresponds to the system console device and the name / dev/ usb corresponds to the USB device.Xinu takes a novel approach to the namespace abstraction by separating the namespace mechanism from the underlying files and directories. Furthermore, Xinuuses a syntactic approach, which means that the namespace examines names without understanding their meaning. What makes our implementation of the namespace espe-cially fascinating is its combination of simplicity and power. By thinking of names as strings, we can understand their similarity. By using the relationship between prefix strings and trees, we can manipulate names easily. By following the principle of access transparency, we can improve the system dramatically. Adding just a small layer of software to existing mechanisms will allow us to unify naming completely.Before looking at namespace mechanisms, we will review a few examples of file naming to understand the problem at hand. Following the discussion of file names, we will look at a general-purpose syntactic naming scheme, and then examine a simpler, less general solution. Finally, we will examine an implementation of the simplified scheme.21.3 Myriad Naming SchemesThe problem designers face when inventing a namespace can be summarized: they must glue together myriad unrelated naming schemes, each of which has evolved into a self-contained system. On some systems, file names specify the storage device on which the file resides. On others, the filename includes a suffix that tells the type of the file (older systems used suffixes to specify a version for the file). Other systems map all files into a single flat namespace in which each name is merely a string of al-phanumeric characters. The following sections give examples of file names on severalSec. 21.3        Myriad Naming Schemes 549systems, and help the reader understand the types and formats of names our namespace must accommodate.21.3.1  MS-DOSNames in MS-DOS consist of two parts: a device specification and a file name. Syntactically, an MS-DOS name has the form X:file, where X is a single letter that designates the device on which the file resides and file is the name of the file. Typical-ly, the letter C denotes the system hard disk, which means a name like C:abc refers to file abc on the hard disk.21.3.2  UnixUnix organizes files into a hierarchical, tree structured directory system. A filename is either relative to the current directory or a full path name that specifies a pathfrom the root of the directory tree to a file.Syntactically, full path names consist of slash-separated components, where each intermediate component specifies a directory and the final component specifies a file. Thus, the Unix name /homes/xinu/x refers to file x in subdirectory xinu, which is found in subdirectory homes, which is contained in the root directory. The root directory itself is named by a single slash (/). Notice that the prefix /homes/xinu/ refers to a directory, and that the names of all files in that directory share the prefix.The importance of the prefix property will become apparent later. For now, it issufficient to remember that the tree structure relates to a name prefix:When components in a file name specify a path through a tree-structured directory, the names of all files that reside in the same directory share a common prefix that denotes the directory.21.3.3  V SystemA research operating system known as the V system allowed a user to specify a context and a name; the system used the context to resolve the name. The syntax used brackets to enclose the context. Thus, [ctx] abc refers to file abc in context ctx. Usual-ly, one thinks of each context as a set of files on a particular remote file server.21.3.4  IBISThe research operating system, IBIS, provides yet another syntax for multiple-machine connections that has been adopted for use with Linux commands, such as scp. In IBIS, names have the form machine:path, where machine denotes a particular com-puter system, and path is the file name on that machine (e.g., a Unix full path name).550 A Syntactic Namespace Chap. 2121.4 Naming System Design AlternativesWe seek a single naming system that provides a unified view of all possible file names, independent of the location of the file or the operating system under which it re-sides. It seems that a designer could choose between two basic approaches in solving the problem: define yet another file naming scheme, or adopt an existing naming scheme. Surprisingly, the Xinu namespace uses neither of these two approaches. In-stead, it adds a syntactic naming mechanism that accommodates many underlying nam-ing schemes, while allowing the user to choose a uniform interface to the naming software. The namespace software maps names that the user supplies into names ap-propriate for the underlying system.A naming mechanism that accommodates many underlying schemes has several advantages. First, it allows the designer to integrate existing file systems and devicesinto a single, uniform namespace, even when implemented by remote servers on a set of heterogeneous systems. Second, it permits designers to add new devices or file systems without requiring recompilation of the application programs that use them. Third, it avoids two unattractive extremes. At one extreme, choosing the simplest naming scheme ensures that all file systems can handle the names, but means that the user can-not take advantage of the complexity offered by some servers. At the other extreme, choosing a naming scheme that encompasses the most complex cases means that an ap-plication which takes advantage of the complexity may not be able to run on a less so-phisticated file system.21.5 Thinking About Names SyntacticallyTo understand how to handle names, think of them syntactically: a name is merely a string of characters. Consequentially, a namespace can be created that transforms strings. The namespace does not need to provide files and directories, nor does it need to understand the semantics of each underlying file system. Instead, the namespace maps strings from a uniform representation chosen by the user into strings appropriate for each particular subsystem. For example, the namespace might translate the string clf into the string C:long_file_name.What makes a syntactic namespace powerful? Syntactic manipulation is both natu-ral and flexible. Thus, it is easy to specify and understand as well as easy to adapt tomany underlying naming schemes. A user can imagine a consistent set of names, andcan use the namespace software to translate them into the forms required by underlying file systems. For example, suppose a system has access to a local file system that uses MS-DOS naming and a remote file system that uses Unix full path names. The user might adopt the Unix full path name syntax for all names, making the local disk names start with /local. In such a scheme, the name /local/abc would refer to file abc on the local hard drive, while the name /etc/passwd would refer to a remote file. The namespace must translate /local/abc into C:abc so the local MS-DOS file system canSec. 21.5        Thinking About Names Syntactically 551understand it, but would pass /etc/passwd on to the remote Unix file system without change.21.6 Patterns And ReplacementsExactly how should a syntactic namespace operate? One convenient method uses a pattern string to specify the name syntax and a replacement string to specify the map-ping. For example, consider the pattern replacement pair:""//llooccaall""""CC::""which means “translate all occurrences of the string /local into the string C:”.How should patterns be formed? Patterns that consist of literal strings cannotspecify replacement unambiguously. In the previous example, the pattern works wellon strings like /local/x, but it fails on strings like /homes/local/bin because /local is an internal substring that should not be changed. To be effective, more powerful patterns are needed. For example, Unix pattern matching tools introduce meta-characters that specify how matching should be performed. A carat (sometimes called up-arrow) matches the beginning of a string. Thus, the Unix pattern:""^^//llooccaall""""CC::""specifies that /local only matches at the beginning of a string. Unfortunately, imple-mentations that allow arbitrary patterns and replacements tend to be cumbersome and the patterns become difficult to read. A more efficient solution is needed.21.7 Prefix PatternsThe problem at hand is to find a useful pattern-replacement mechanism that allows the user to specify how names map onto a subsystem without introducing more com-plexity than is needed. Before thinking about complex patterns, consider what can be done with patterns that consist of literal strings. The key is to imagine files organized into a hierarchy, and to use the prefix property to understand why patterns should speci-fy prefixes.In a hierarchy, name prefixes group files into subdirectories, making it easy to de-fine the relationship between names and the underlying file systems or devices. Fur-thermore, each prefix can be represented by a literal string. The point is:Restricting name replacement to prefixes means it is possible to use literal strings to separate underlying file systems into distinct parts of a name hierarchy.552 A Syntactic Namespace Chap. 2121.8 Implementation Of A NamespaceA concrete example will clarify the details of how a syntactic namespace uses the pattern-replacement paradigm, and will show how the namespace hides subsystem de-tails. In the example, patterns will consist of fixed strings, and only prefixes will be matched. Later sections discuss alternative implementations and generalizations.The example implementation of a namespace consists of a pseudo-device, NAMESPACE, that programs use to open a named object. An application program in-vokes open on the NAMESPACE device, passing a name and mode as arguments. The NAMESPACE pseudo-device uses a set of prefix patterns to transform the name into a new name, and then passes the new name to the appropriate underlying device through a call to open. We will see that all files and devices can be part of the namespace, meaning that an application never needs to open a device other than the NAMESPACE pseudo-device.The next sections present the namespace software, beginning with declarations of the basic data structures and culminating in the definition of the NAMESPACE pseudo-device. Following the declarations, two functions are presented that transform names according to the prefix patterns. The two functions are used by the most important piece of namespace software: a function that implements open for the NAMESPACE pseudo-device. Later sections show examples that illustrate how the NAMESPACE is used.21.9 Namespace Data Structures And ConstantsFile name.h contains declarations for the data structures and constants used in theXinu namespace.//**nnaammee..hh**////**CCoonnssttaannttsstthhaattddeeffiinneetthheennaammeessppaacceemmaappppiinnggttaabblleessiizzeess**//##ddeeffiinneeNNMM__PPRREELLEENN6644//**MMaaxxssiizzeeooffaapprreeffiixxssttrriinngg**//##ddeeffiinneeNNMM__RREEPPLLLLEENN9966//**MMaaxxiimmuummssiizzeeooffaarreeppllaacceemmeenntt**//##ddeeffiinneeNNMM__MMAAXXLLEENN225566//**MMaaxxiimmuummssiizzeeooffaaffiilleennaammee**//##ddeeffiinneeNNNNAAMMEESS4400//**NNuummbbeerrooffpprreeffiixxddeeffiinniittiioonnss**////**DDeeffiinniittiioonnoofftthheennaammeepprreeffiixxttaabblleetthhaattddeeffiinneessaallllnnaammeemmaappppiinnggss**//ssttrruuccttnnmmeennttrryy{{//**DDeeffiinniittiioonnooffpprreeffiixxttaabbllee**//cchhaarrnnpprreeffiixx[[NNMM__PPRREELLEENN]];;//**NNuullll--tteerrmmiinnaatteeddpprreeffiixx**//cchhaarrnnrreeppllaaccee[[NNMM__RREEPPLLLLEENN]];;//**NNuullll--tteerrmmiinnaatteeddrreeppllaacceemmeenntt**//ddiidd3322nnddeevviiccee;;//**DDeevviicceeddeessccrriippttoorrffoorrpprreeffiixx**//}};;Sec. 21.9        Namespace Data Structures And Constants 553eexxtteerrnnssttrruuccttnnmmeennttrryynnaammeettaabb[[]];;//**TTaabblleeooffnnaammeemmaappppiinnggss**//eexxtteerrnniinntt3322nnnnaammeess;;//**NNuummbbeerrooffeennttrriieessaallllooccaatteedd**//The principle data structure is array nametab, which holds up to NNAMES entries. Each entry consists of a prefix pattern string, a replacement string, and a device ID. External integer nnames holds a count of the valid entries in nametab.21.10 Adding Mappings To The Namespace Prefix TableFunction mount is used to add mappings to the prefix table. As expected, mounttakes three arguments: a prefix string, a replacement string, and a device ID. Filemount.c contains the code.//**mmoouunntt..cc--mmoouunntt,,nnaammlleenn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**mmoouunntt--AAddddaapprreeffiixxmmaappppiinnggttootthheennaammeessppaaccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssyyssccaallllmmoouunntt((cchhaarr**pprreeffiixx,,//**PPrreeffiixxttooaadddd**//cchhaarr**rreeppllaaccee,,//**RReeppllaacceemmeennttssttrriinngg**//ddiidd3322ddeevviiccee//**DDeevviicceeIIDDttoouussee**//)) {{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttnnmmeennttrryy**nnaammppttrr;;//**PPooiinntteerrttoouunnuusseeddttaabblleeeennttrryy**//iinntt3322ppssiizz,,rrssiizz;;//**SSiizzeessooffpprreeffiixx&&rreeppllaacceemmeenntt**//iinntt3322ii;;//**CCoouunntteerrffoorrccooppyylloooopp**//mmaasskk==ddiissaabbllee(());;ppssiizz==nnaammlleenn((pprreeffiixx,,NNMM__PPRREELLEENN));;rrssiizz==nnaammlleenn((rreeppllaaccee,,NNMM__RREEPPLLLLEENN));;//**IIffaarrgguummeennttssaarreeiinnvvaalliiddoorrttaabblleeiissffuullll,,rreettuurrnneerrrroorr**//iiff((((ppssiizz====SSYYSSEERRRR))||||((rrssiizz====SSYYSSEERRRR))||||((iissbbaaddddeevv((ddeevviiccee))))||||((nnnnaammeess>>==NNNNAAMMEESS)))){{rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}554 A Syntactic Namespace Chap. 21//**AAllllooccaatteeaasslloottiinntthheettaabbllee**//nnaammppttrr==&&nnaammeettaabb[[nnnnaammeess]];;//**NNeexxttuunnuusseeddeennttrryyiinnttaabbllee**////**ccooppyypprreeffiixxaannddrreeppllaacceemmeennttssttrriinnggssaannddrreeccoorrddddeevviicceeIIDD**//ffoorr((ii==00;;ii<<ppssiizz;;ii++++)){{//**CCooppyypprreeffiixxiinnttoottaabblleeeennttrryy**//nnaammppttrr-->>nnpprreeffiixx[[ii]]==**pprreeffiixx++++;;}} ffoorr((ii==00;;ii<<rrssiizz;;ii++++)){{//**CCooppyyrreeppllaacceemmeennttiinnttooeennttrryy**//nnaammppttrr-->>nnrreeppllaaccee[[ii]]==**rreeppllaaccee++++;;}} nnaammppttrr-->>nnddeevviiccee==ddeevviiccee;;//**RReeccoorrddtthheeddeevviicceeIIDD**//nnnnaammeess++++;;//**IInnccrreemmeennttnnuummbbeerrooffnnaammeess**//rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**nnaammlleenn--CCoommppuutteetthheelleennggtthhooffaassttrriinnggssttooppppiinnggaattmmaaxxlleenn**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322nnaammlleenn((cchhaarr**nnaammee,,//**NNaammeettoouussee**//iinntt3322mmaaxxlleenn//**MMaaxxiimmuummlleennggtthh((iinncclluuddiinnggaa**////**NNUULLLLCCHH))**//)) {{iinntt3322ii;;//**CCoouunnttooffcchhaarraacctteerrssffoouunndd**////**SSeeaarrcchhuunnttiillaannuulllltteerrmmiinnaattoorroorrlleennggtthhrreeaacchheessmmaaxx**//ffoorr((ii==00;;ii<<mmaaxxlleenn;;ii++++)){{iiff((**nnaammee++++====NNUULLLLCCHH)){{rreettuurrnnii++11;;//**IInncclluuddeeNNUULLLLCCHHiinnlleennggtthh**//}}}} rreettuurrnnSSYYSSEERRRR;;}}Sec. 21.10        Adding Mappings To The Namespace Prefix Table 555If any of the arguments are invalid or the table is full, mount returns SYSERR. Otherwise, it increments nnames to allocate a new entry in the table and fills in thevalues.21.11 Mapping Names With The Prefix TableOnce a prefix table has been created, name translation can be performed. Mapping consists of finding a prefix match and substituting the corresponding replacement string. Function nammap performs translation. The code can be found in file nammap.c://**nnaammmmaapp..cc--nnaammmmaapp,,nnaammrreeppll,,nnaammccppyy**//##iinncclluuddee<<xxiinnuu..hh>>ssttaattuussnnaammccppyy((cchhaarr**,,cchhaarr**,,iinntt3322));;ddiidd3322nnaammrreeppll((cchhaarr**,,cchhaarr[[]]));;//**------------------------------------------------------------------------------------------------------------------------------------------------**nnaammmmaapp--UUssiinnggnnaammeessppaaccee,,mmaappnnaammeettoonneewwnnaammeeaannddnneewwddeevviiccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllnnaammmmaapp((cchhaarr**nnaammee,,//**TThheennaammeettoommaapp**//cchhaarrnneewwnnaammee[[NNMM__MMAAXXLLEENN]],,//**BBuuffffeerrffoorrmmaappppeeddnnaammee**//ddiidd3322nnaammddeevv//**IIDDoofftthheennaammeessppaacceeddeevviiccee**//)){{ddiidd3322nneewwddeevv;;//**DDeevviicceeddeessccrriippttoorrttoorreettuurrnn**//cchhaarrttmmppnnaammee[[NNMM__MMAAXXLLEENN]];;//**TTeemmppoorraarryybbuuffffeerrffoorrnnaammee**//iinntt3322iitteerr;;//**NNuummbbeerrooffiitteerraattiioonnss**////**PPllaacceeoorriiggiinnaallnnaammeeiinntteemmppoorraarryybbuuffffeerraannddnnuulllltteerrmmiinnaattee**//iiff((nnaammccppyy((ttmmppnnaammee,,nnaammee,,NNMM__MMAAXXLLEENN))====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**RReeppeeaatteeddllyyssuubbssttiittuutteetthheennaammeepprreeffiixxuunnttiillaannoonn--nnaammeessppaaccee**////**ddeevviicceeiissrreeaacchheeddoorraanniitteerraattiioonnlliimmiittiisseexxcceeeeddeedd**//ffoorr((iitteerr==00;;iitteerr<<nnnnaammeess;;iitteerr++++)){{nneewwddeevv==nnaammrreeppll((ttmmppnnaammee,,nneewwnnaammee));;iiff((nneewwddeevv!!==nnaammddeevv)){{556 A Syntactic Namespace Chap. 21nnaammccppyy((ttmmppnnaammee,,nneewwnnaammee,,NNMM__MMAAXXLLEENN));;rreettuurrnnnneewwddeevv;;//**EEiitthheerrvvaalliiddIIDDoorrSSYYSSEERRRR**//}}}} rreettuurrnnSSYYSSEERRRR;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**nnaammrreeppll--UUsseetthheennaammeettaabblleettooppeerrffoorrmmpprreeffiixxssuubbssttiittuuttiioonn**------------------------------------------------------------------------------------------------------------------------------------------------**//ddiidd3322nnaammrreeppll((cchhaarr**nnaammee,,//**OOrriiggiinnaallnnaammee**//cchhaarrnneewwnnaammee[[NNMM__MMAAXXLLEENN]]//**BBuuffffeerrffoorrmmaappppeeddnnaammee**//)){{iinntt3322ii;;//**IItteerraatteetthhrroouugghhnnaammeettaabbllee**//cchhaarr**ppppttrr;;//**WWaallkksstthhrroouugghhaapprreeffiixx**//cchhaarr**rrppttrr;;//**WWaallkksstthhrroouugghhaarreeppllaacceemmeenntt**//cchhaarr**ooppttrr;;//**WWaallkksstthhrroouugghhoorriiggiinnaallnnaammee**//cchhaarr**nnppttrr;;//**WWaallkksstthhrroouugghhnneewwnnaammee**//cchhaarroolleenn;;//**LLeennggtthhooffoorriiggiinnaallnnaammee**////**iinncclluuddiinnggtthheeNNUULLLLbbyyttee**//iinntt3322pplleenn;;//**LLeennggtthhooffaapprreeffiixxssttrriinngg**////****nnoott**iinncclluuddiinnggNNUULLLLbbyyttee**//iinntt3322rrlleenn;;//**LLeennggtthhooffrreeppllaaccmmeennttssttrriinngg**//iinntt3322rreemmaaiinn;;//**BByytteessiinnnnaammeebbeeyyoonnddpprreeffiixx**//ssttrruuccttnnmmeennttrryy**nnaammppttrr;;//**PPooiinntteerrttooaattaabblleeeennttrryy**////**SSeeaarrcchhnnaammeettaabblleeffoorrffiirrssttpprreeffiixxtthhaattmmaattcchheess**//ffoorr((ii==00;;ii<<nnnnaammeess;;ii++++)){{nnaammppttrr==&&nnaammeettaabb[[ii]];;ooppttrr==nnaammee;;//**SSttaarrttaattbbeeggiinnnniinnggooffnnaammee**//ppppttrr==nnaammppttrr-->>nnpprreeffiixx;;//**SSttaarrttaattbbeeggiinnnniinnggooffpprreeffiixx**////**CCoommppaarreepprreeffiixxttoossttrriinnggaannddccoouunnttpprreeffiixxssiizzee**//ffoorr((pplleenn==00;;**ppppttrr!!==NNUULLLLCCHH;;pplleenn++++)){{iiff((**ppppttrr!!==**ooppttrr)){{bbrreeaakk;;}} ppppttrr++++;;ooppttrr++++;;}}Sec. 21.11        Mapping Names With The Prefix Table 557iiff((**ppppttrr!!==NNUULLLLCCHH)){{//**PPrreeffiixxddooeessnnoottmmaattcchh**//ccoonnttiinnuuee;;}} //**FFoouunnddaammaattcchh--cchheecckktthhaattrreeppllaacceemmeennttssttrriinnggpplluuss**////**bbyytteessrreemmaaiinniinnggaatttthheeeennddoofftthheeoorriiggiinnaallnnaammeewwiillll**////**ffiittiinnttoonneewwnnaammeebbuuffffeerr..IIggnnoorreennuulllloonnrreeppllaacceemmeenntt**////**ssttrriinngg,,bbuuttkkeeeeppnnuulllloonnrreemmaaiinnddeerrooffnnaammee..**//oolleenn==nnaammlleenn((nnaammee,,NNMM__MMAAXXLLEENN));;rrlleenn==nnaammlleenn((nnaammppttrr-->>nnrreeppllaaccee,,NNMM__MMAAXXLLEENN))--11;;rreemmaaiinn==oolleenn--pplleenn;;iiff((((rrlleenn++rreemmaaiinn))>>NNMM__MMAAXXLLEENN)){{rreettuurrnn((ddiidd3322))SSYYSSEERRRR;;}} //**PPllaacceerreeppllaacceemmeennttssttrriinnggffoolllloowweeddbbyyrreemmaaiinnddeerrooff**////**oorriiggiinnaallnnaammee((aannddnnuullll))iinnttootthheenneewwnnaammeebbuuffffeerr**//nnppttrr==nneewwnnaammee;;rrppttrr==nnaammppttrr-->>nnrreeppllaaccee;;ffoorr((;;rrlleenn>>00;;rrlleenn----)){{**nnppttrr++++==**rrppttrr++++;;}} ffoorr((;;rreemmaaiinn>>00;;rreemmaaiinn----)){{**nnppttrr++++==**ooppttrr++++;;}} rreettuurrnnnnaammppttrr-->>nnddeevviiccee;;}} rreettuurrnn((ddiidd3322))SSYYSSEERRRR;;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**nnaammccppyy--CCooppyyaannaammeeffrroommoonneebbuuffffeerrttooaannootthheerr,,cchheecckkiinngglleennggtthh**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussnnaammccppyy((cchhaarr**nneewwnnaammee,,//**BBuuffffeerrttoohhoollddccooppyy**//cchhaarr**oollddnnaammee,,//**BBuuffffeerrccoonnttaaiinniinnggnnaammee**//iinntt3322bbuufflleenn//**SSiizzeeooffbbuuffffeerrffoorrccooppyy**//)){{cchhaarr**nnppttrr;;//**PPooiinnttttoonneewwnnaammee**//cchhaarr**ooppttrr;;//**PPooiinnttttoooollddnnaammee**//558 A Syntactic Namespace Chap. 21iinntt3322ccnntt;;//**CCoouunnttooffcchhaarraacctteerrssccooppiieedd**//nnppttrr==nneewwnnaammee;;ooppttrr==oollddnnaammee;;ffoorr((ccnntt==00;;ccnntt<<bbuufflleenn;;ccnntt++++)){{iiff((((**nnppttrr++++==**ooppttrr++++))====NNUULLLLCCHH)){{rreettuurrnnOOKK;;}}}} rreettuurrnnSSYYSSEERRRR;;//**BBuuffffeerrffiilllleeddbbeeffoorreeccooppyyccoommpplleetteedd**//}}The most interesting aspect of nammap arises because it allows multiple mappings.In particular, because the namespace is a pseudo-device, it is possible for a user tospecify a mapping back onto the NAMESPACE device. For example, consider the fol-lowing two entries in nametab:""//llooccaall//""""""LLFFIILLEESSYYSS""LLFFSS::""""//llooccaall//""NNAAMMEESSPPAACCEEThe first entry specifies that if a name begins with /local/, the prefix is removed and the name is passed to the local file system. The second entry specifies that LFS: is an ab-breviation for /local/. That is, the prefix LFS: is replaced by /local/ and the resulting string is passed back to the NAMESPACE device for another round of mapping.Of course, recursive mapping can be dangerous. Consider what can happen if auser adds the following to the namespace:""//xx""""//xx""NNAAMMEESSPPAACCEEWhen presented with a name /xyz, a naive implementation will find prefix /x, make the substitution, and call open on the NAMESPACE device, causing an infinite recursion. To avoid the problem, our implementation iterates through NAMESPACE replacements and limits the total iterations. In particular, the code only permits one iteration for each prefix in nametab (i.e., each prefix can be substituted at most once). Of course, nam-map also limits the size of a name: if a replacement would expand the name to more than NM_MAXLEN characters, nammap stops and returns SYSERR.Nammap begins by copying the original name into local array tmpname. It then iterates until the name has been mapped to a device other than the NAMESPACE or the iteration limit is reached. During each iteration, nammap calls function namrepl to look up the current name and form a replacement.Function namrepl implements a basic replacement policy. Our example replace-ment policy is simplistic: namrepl searches the table linearly. A search always beginswith the first entry in the table, and stops as soon as a prefix in the table matches theSec. 21.11        Mapping Names With The Prefix Table 559string supplied by argument name. Once searching has stopped, nammap forms amapped name in argument newname by appending the unmatched portion of the origi-nal name onto the replacement string. It then returns the device ID from the table entry. A later section explains that the design has consequences for users.21.12 Opening A Named FileOnce nammap is available, constructing the upper-half open routine for the namespace pseudo-device becomes trivial. Recall that the basic goal is to define a namespace pseudo-device, NAMESPACE, such that opening the device causes the sys-tem to open the appropriate underlying device. Once a name has been mapped and a new device identified, namopen merely invokes open. The code is contained in file namopen.c.//**nnaammooppeenn..cc--nnaammooppeenn**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**nnaammooppeenn--OOppeennaaffiilleeoorrddeevviicceebbaasseeddoonntthheennaammee**------------------------------------------------------------------------------------------------------------------------------------------------**//ddeevvccaallllnnaammooppeenn((ssttrruuccttddeennttrryy**ddeevvppttrr,,//**EEnnttrryyiinnddeevviicceesswwiittcchhttaabbllee**//cchhaarr**nnaammee,,//**NNaammeettooooppeenn**//cchhaarr**mmooddee//**MMooddeeaarrgguummeenntt**//)){{cchhaarrnneewwnnaammee[[NNMM__MMAAXXLLEENN]];;//**NNaammeewwiitthhpprreeffiixxrreeppllaacceedd**//ddiidd3322nneewwddeevv;;//**DDeevviicceeIIDDaafftteerrmmaappppiinngg**////**UUsseennaammeessppaacceettoommaappnnaammeettooaanneewwnnaammeeaannddnneewwddeessccrriippttoorr**//nneewwddeevv==nnaammmmaapp((nnaammee,,nneewwnnaammee,,ddeevvppttrr-->>ddvvnnuumm));;iiff((nneewwddeevv====SSYYSSEERRRR)){{rreettuurrnnSSYYSSEERRRR;;}} //**OOppeennuunnddeerrllyyiinnggddeevviicceeaannddrreettuurrnnssttaattuuss**//rreettuurrnnooppeenn((nneewwddeevv,,nneewwnnaammee,,mmooddee));;}}560 A Syntactic Namespace Chap. 2121.13 Namespace InitializationHow should initial values be assigned to the prefix table? There are two possible approaches: an initialization function could assign initial mappings when it creates the namespace data structure, or the initialization function could leave the table empty and require the user to add mappings. We chose the former approach.In terms of initialization, the mechanism should be clear. Because the namespacehas been designed as a pseudo-device, the files resemble a device driver. In particular,the namespace device includes an initialization function that the system calls when de-vices are initialized (i.e., when the system calls init for the device at system startup).Deciding how to initialize a prefix table can be difficult. Therefore, we will exam-ine the initialization function to see how it constructs a prefix table, and defer the dis-cussion of actual prefixes until later sections. File naminit.c contains the code for the naminit function://**nnaammiinniitt..cc--nnaammiinniitt**//##iinncclluuddee<<xxiinnuu..hh>>##iiffnnddeeffRRFFIILLEESSYYSS##ddeeffiinneeRRFFIILLEESSYYSSSSYYSSEERRRR##eennddiiff##iiffnnddeeffFFIILLEESSYYSS##ddeeffiinneeFFIILLEESSYYSSSSYYSSEERRRR##eennddiiff##iiffnnddeeffLLFFIILLEESSYYSS##ddeeffiinneeLLFFIILLEESSYYSSSSYYSSEERRRR##eennddiiffssttrruuccttnnmmeennttrryynnaammeettaabb[[NNNNAAMMEESS]];;//**TTaabblleeooffnnaammeemmaappppiinnggss**//iinntt3322nnnnaammeess;;//**NNuummbbeerrooffeennttrriieessaallllooccaatteedd**////**------------------------------------------------------------------------------------------------------------------------------------------------**nnaammiinniitt--IInniittiiaalliizzeetthheessyynnttaaccttiiccnnaammeessppaaccee**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussnnaammiinniitt((vvooiidd)){{ddiidd3322ii;;//**IInnddeexxiinnttooddeevvttaabb**//ssttrruuccttddeennttrryy**ddeevvppttrr;;//**PPooiinntteerrttooddeevviicceettaabblleeeennttrryy**//cchhaarrttmmppssttrr[[NNMM__MMAAXXLLEENN]];;//**SSttrriinnggttoohhoollddaannaammee**//ssttaattuussrreettvvaall;;//**RReettuurrnnvvaalluuee**//cchhaarr**ttppttrr;;//**PPooiinntteerriinnttootteemmppssttrriinngg**//cchhaarr**nnppttrr;;//**PPooiinntteerrttooddeevviicceennaammee**//Sec. 21.13        Namespace Initialization 561cchhaarrddeevvpprreeffiixx[[]]==""//ddeevv//"";;//**PPrreeffiixxttoouusseeffoorrddeevviicceess**//iinntt3322lleenn;;//**LLeennggtthhooffccrreeaatteeddnnaammee**//cchhaarrcchh;;//**SSttoorraaggeeffoorraacchhaarraacctteerr**////**SSeettpprreeffiixxttaabblleettooeemmppttyy**//nnnnaammeess==00;;ffoorr((ii==00;;ii<<NNDDEEVVSS;;ii++++)){{ttppttrr==ttmmppssttrr;;nnppttrr==ddeevvpprreeffiixx;;//**CCooppyypprreeffiixxiinnttoottmmppssttrr**//lleenn==00;;wwhhiillee((((**ttppttrr++++==**nnppttrr++++))!!==NNUULLLLCCHH)){{lleenn++++;;}} ttppttrr----;;//**MMoovveeppooiinntteerrttooppoossiittiioonnbbeeffoorreeNNUULLLLCCHH**//ddeevvppttrr==&&ddeevvttaabb[[ii]];;nnppttrr==ddeevvppttrr-->>ddvvnnaammee;;//**MMoovveettooddeevviicceennaammee**////**MMaappddeevviicceennaammeettoolloowweerrccaasseeaannddaappppeenndd**//wwhhiillee((++++lleenn<<NNMM__MMAAXXLLEENN)){{cchh==**nnppttrr++++;;iiff((((cchh>>==’’AA’’))&&&&((cchh<<==’’ZZ’’)))){{cchh++==’’aa’’--’’AA’’;;}} iiff((((**ttppttrr++++==cchh))====NNUULLLLCCHH)){{bbrreeaakk;;}}}} iiff((lleenn>>NNMM__MMAAXXLLEENN)){{kkpprriinnttff((""nnaammeessppaaccee::ddeevviicceennaammee%%ssttoooolloonngg\\rr\\nn"",,ddeevvppttrr-->>ddvvnnaammee));;ccoonnttiinnuuee;;}} rreettvvaall==mmoouunntt((ttmmppssttrr,,NNUULLLLSSTTRR,,ddeevvppttrr-->>ddvvnnuumm));;iiff((rreettvvaall====SSYYSSEERRRR)){{kkpprriinnttff((""nnaammeessppaaccee::ccaannnnoottmmoouunnttddeevviiccee%%dd\\rr\\nn"",,ddeevvppttrr-->>ddvvnnaammee));;ccoonnttiinnuuee;;}}}}562 A Syntactic Namespace Chap. 21//**AAddddootthheerrpprreeffiixxeess((lloonnggeessttpprreeffiixxffiirrsstt))**//mmoouunntt((""//ddeevv//nnuullll"",,"""",,NNUULLLLDDEEVV));;mmoouunntt((""//rreemmoottee//"",,""rreemmoottee::"",,RRFFIILLEESSYYSS));;mmoouunntt((""//llooccaall//"",,NNUULLLLSSTTRR,,LLFFIILLEESSYYSS));;mmoouunntt((""//ddeevv//"",,NNUULLLLSSTTRR,,SSYYSSEERRRR));;mmoouunntt((""~~//"",,NNUULLLLSSTTRR,,LLFFIILLEESSYYSS));;mmoouunntt((""//"",,""rroooott::"",,RRFFIILLEESSYYSS));;mmoouunntt(("""",,"""",,LLFFIILLEESSYYSS));;rreettuurrnnOOKK;;}}Ignore the specific prefix and replacement names and look only at how straightfor-ward initialization is. After setting the number of valid entries to zero, naminit calls mount to add entries to the prefix table, where each entry contains a prefix pattern, re-placement string, and device id. The for loop iterates through the device switch table. For each device, it creates a name of the form /dev/xxx, where xxx is the name of the de-vice mapped into lower case. Thus, it creates an entry for /dev/console that maps to the CONSOLE device. If a process calls:dd==ooppeenn((NNAAMMEESSPPAACCEE,,""//ddeevv//ccoonnssoollee"",,""rrww""));;the namespace will invoke open on the CONSOLE device and return the result.21.14 Ordering Entries In The Prefix TableThe Xinu name replacement policy affects users. To understand how, recall that namrepl uses sequential lookup. Therefore, a user must mount names so that sequential lookup produces the expected outcome. In particular, our implementation does not prohibit overlapping prefixes, and does not warn users if overlaps occur. Consequently, if overlapping prefixes occur, a user must ensure that the longest prefix appears earlier in the table than shorter prefixes. As an example, consider what happens if the table contains two entries as Figure 21.1 illustrates.Prefix Replacement Device"x" "" (null string) LFILESYS"xyz" "" (null string) RFILESYSFigure 21.1Two entries in a prefix table; the order must be swapped or thesecond entry will never be used.Sec. 21.14        Ordering Entries In The Prefix Table 563The first entry maps prefix x to a local file system, and the second entry maps pre-fix xyz to a remote file system. Unfortunately, because namrepl searches the table sequentially, any file name that starts with x will match the first entry and will be mapped to the local file system. The second entry will never be used. If the two are reversed, however, file names starting with xyz will map onto the remote file system, and other names starting with x will map to the local file system. The point is:Because our implementation searches the table of prefixes sequential-ly and does not detect overlapping prefixes, a user must insert prefixes in reverse order by length, ensuring that the system will match the longest prefix first.21.15 Choosing A Logical NamespaceIt is tempting to think of a namespace as merely a mechanism that can be used to abbreviate long names. However, focusing on the mechanism can be misleading. Thekey to choosing meaningful prefix names lies in thinking of a hierarchy into which files can be placed. Then, the namespace design defines the organization of the hierarchy.Rather than thinking of the namespace as a mechanism that abbrevi-ates names, we think of all names being organized into a hierarchy. Entries in the namespace are chosen to implement the desired hierar-chy.Imagine, for a minute, a system that can access files on a local disk as well as files on a remote server. Do not think about how to abbreviate specific file names; think in-stead of how to organize the files. Three possible organizations come to mind as Figure 21.2 shows.
RLLR(a) (b) (c)Figure 21.2 Three possible hierarchical organizations of local and remotefiles: (a) local and remote files at the same level, (b) remote files in a subdirectory of local files, and (c) local files as a subdirec-tory of remote files.564 A Syntactic Namespace Chap. 21As in the figure, local and remote files could be placed at equal, but distinct posi-tions in the hierarchy. Alternatively, the local system could form the main part of the hierarchy with remote files as a sub-hierarchy, or the remote files could form the main hierarchy with local files as a sub-hierarchy. Among the choices, the size of the two file systems and the frequency of access may help determine which organization is preferable. For example, if the remote file system has thousands of files while the local file system has only ten, it may be natural to think of the remote file system as the main hierarchy with the local files grafted onto a sub-hierarchy.21.16 A Default Hierarchy And The Null PrefixThe Xinu namespace software design can easily support any of the hierarchiesshown in Figure 21.2. In particular, mount permits the user to choose one subsystem asthe default, and organize the remaining files with respect to that hierarchy.How does a subsystem become the default? First, the prefix for the subsystem must be such that it matches all names not matched by other table entries. The null pre-fix provides guaranteed matching for our example namespace. Second, the default en-try, which carries the null prefix, must be examined only after all other prefixes have been tested. Because nammap searches the prefix table sequentially, the default must be placed at the end of the table. If any other entry matches, namrepl will follow the match.Look at naminit again to see how the local file system becomes the default. Thefinal call to mount inserts the default mapping with a null prefix. Thus, any name thatdoes not match another prefix will refer to the local file system.21.17 Additional Object Manipulation FunctionsAlthough it appears to organize all names into a single, unified hierarchy, the namespace illustrated above does not provide all needed functionality. To understand why, observe that the code only handles the case of opening a named object. Other operations on named objects are also possible:Testing the existence of an objectChanging the name of an objectDeleting an objectTesting the existence of an object.Often software needs to test the existence of an object without otherwise affecting the object. It may seem that the following test couldbe used to determine whether an object exists.Sec. 21.17        Additional Object Manipulation Functions 565ddeevv==ooppeenn((NNAAMMEESSPPAACCEE"",,""oobbjjeecctt"",,""rr""));;iiff((ddeevv====SSYYSSEERRRR)){{...object does not exist}}eellssee{{cclloossee((ddeevv));;...object exists}}Unfortunately, a call to open can have side effects. For example, opening a network in-terface device can cause the system to declare the interface to be available for packet transfer. Thus, opening and then closing the device may cause packet transfer to begin, even if a process has specifically disabled the interface. To avoid side effects, addition-al functionality is needed.Changing the name of an object.Most file systems allow a user to rename files. However, two problems arise when the namespace is used. First, because users view all files through the namespace, requests to rename files can be ambiguous: should the name of the underlying file be changed, or should the mapping in the namespace be changed? Although it is possible to include an escape mechanism that allows a user to distinguish between abstract names and names used in the underlying system, doing so is dangerous because changes to underlying names may no longer map through the namespace. Second, if a user specifies changing name Fto name G, it may turn out that string Gmaps to a local file system and Fmaps to a remote file system. Thus, even though a user sees a unified hierarchy, a renaming operation may not be allowed (or may involve a file copy).Deleting an object.The reasoning given above applies to object deletion as well. That is, because a user views all names through the namespace, a request to delete an object must map the name through the namespace to determine the underlying file sys-tem.How should deletion, renaming, and testing the existence of an object be imple-mented? Three possibilities arise: separate functions could be created for each opera-tion, the device switch table could be expanded, or the control functions could be aug-mented with additional operations. To understand the first approach, separate functions, imagine a function delete_obj that takes a name as an argument. The function would use the namespace to map the name to an underlying device, and then invoke the ap-propriate deletion operation on the device. The second approach consists of expanding the device switch table to add additional high-level functions, such as delete, rename, and an existence test. That is, in addition to open, read, write, and close operations, add new operations that implement the additional functionality. The third approach consists of adding functionality to the control function. For example, we could specify that if a subsystem implements object deletion, the driver function that implements control must honor a DELETE request. Xinu uses a mixture of the first and third approaches. Exer-cises ask the reader to consider the advantages and disadvantages of expanding the de-vice switch table.566 A Syntactic Namespace Chap. 2121.18 Advantages And Limits Of The Namespace ApproachA syntactic namespace isolates programs from the underlying devices and file sys-tems, allowing a naming hierarchy to be imagined or changed without changing the underlying systems. To appreciate the power of a namespace, consider a system that keeps temporary files on a local disk and uses the prefix /tmp/ to distinguish them from other files. Moving temporary files to the remote file system consists of changing the namespace entry that specifies how to handle prefix /tmp/. Because programs always use the namespace when they refer to files, all programs continue to operate correctly with no change to the source code. The key point is:A namespace permits the conceptual naming hierarchy to be reorgan-ized without requiring recompilation of programs that use it.Namespace software that uses only prefix patterns cannot handle all hierarchical organizations or file mappings. For example, in some Unix systems, the name /dev/tty refers to a process’s control terminal, which a server should not use. The namespace can prevent accidental access by mapping the prefix /dev/tty onto device ID SYSERR. Unfortunately, such a mapping prevents the client from accessing other entries that share the same prefix (e.g., /dev/tty1).Using fixed strings as prefix patterns also prevents the namespace from changing separator characters when they occur in the middle of names. For example, suppose a computer has two underlying file systems, one of which follows the Unix convention of using the slash character to separate components along a path, while the other uses the backslash character to separate components. Because it deals only with prefix patterns, our example namespace cannot map slashes to backslashes or vice versa unless all pos-sible prefixes are stored in the namespace.21.19 Generalized PatternsMany of the namespace limitations can be overcome by using more general pat-terns than were described near the beginning of the chapter. For example, if it is possi-ble to specify a full string match instead of just a prefix match, the problem of distin-guishing a name like /dev/tty from the name /dev/tty1 can be solved. Full match and prefix match can be combined: mount can be modified to have an additional argument that specifies the type of match, and the value can be stored in the table entry.Generalizing patterns to allow more than fixed strings solves additional problemsand keeps all matching information in the pattern itself. For example, suppose charac-ters have special meanings in a pattern as defined in Figure 21.3:††The pattern matching given here corresponds to that used in the Unix sed command.Sec. 21.19        Generalized Patterns 567Character Meaningpmatch beginning of string$ match end of string. match any single character* repeat 0 or more of a pattern\ take next character in pattern literallyother self match as in a fixed stringFigure 21.3  An example definition of generalized patterns.Thus, a pattern like p/dev/tty$ specifies a full match of the string /dev/tty, while a pat-tern like \$ matches a dollar sign that may be embedded in the string.Two additional rules are necessary to make generalized pattern matching useful inthe namespace. First, we assume the left-most possible match will be used. Second,we assume that among all left-most matches, the longest will be selected. The exercises suggest how to use these generalized patterns to map the names that fixed prefixes can-not handle.21.20 PerspectiveThe syntax of names has been studied and debated extensively. At one time, each operating system had its own naming scheme, and a variety of naming schemes flour-ished. However, once hierarchical directory systems became prevalent, most operating systems adopted a hierarchical naming scheme, and the only differences arise over small details, such as whether a forward slash or backslash is used to separate components.As our design points out, naming is conceptually separate from the underlying file and I/O systems, and allows a designer to impose a consistent namespace across all underlying facilities. However, the use of a syntactic approach has disadvantages as well as advantages. The chief problems arise from semantics: although it provides the appearance of uniformity, the namespace introduces ambiguity and confuses semantics. For example, if an object is renamed, should the namespace be modified or should the name of the underlying object be changed? If the namespace maps two prefixes to the same underlying file system, applications that use separate prefixes could inadvertently access the same object. If two names map to different underlying file systems, an operation such as move that references the names may not be possible or may not work as expected. Even an operation such as delete may have unexpected semantics (e.g., deleting a local object may move it to the trash, while deleting a remote object per-manently removes the object).568 A Syntactic Namespace Chap. 2121.21 SummaryDealing with file names is difficult, especially if the operating system supports multiple underlying naming schemes. One way to solve the naming problem employs a layer of namespace software between applications and the underlying file systems. The namespace does not implement files itself, but merely treats names as strings, mapping them into forms appropriate for underlying systems based on information in a mapping table.We examined the implementation of a syntactic namespace that uses a pattern-replacement scheme in which patterns are fixed strings representing name prefixes. The software includes a mount that installs a mapping, as well as functions like nammap that map names into their target form. Our example namespace uses a NAMESPACE pseudo-device that users specify when opening a file. The NAMESPACE pseudo-device maps the specified file name, and then opens the designated file.The namespace software is both elegant and powerful. With only a few functionsand the simplistic notion of prefix matching, it can accommodate many namingschemes. In particular, it accommodates a remote file system, a local file system, and aset of devices. However, our simplistic version cannot handle all possible mappings. To provide for more complex naming systems, the notion of pattern must be generalized. One possible generalization assigns special meanings to some characters in the pattern.EXERCISES21.1  Should users have access to both nammap and namrepl? Why or why not?21.2  Look carefully at the code in mount. Will the prefix and replacement strings in nametabalways include a NULL byte? Why or why not?21.3 Is it possible to modify mount so it refuses to mount prefix-replacement pairs that canpotentially cause an infinite loop? Why or why not?21.4 What is the minimum number of prefix-replacement pairs that can cause nammap toexceed the maximum string length?21.5 Minimize the code in namopen by replacing the body with a single statement consistingof two function calls.21.6   Implement an upper-half control function for the NAMESPACE pseudo-device, andmake nammap a control function.21.7  Implement generalized pattern matching. Refer to the Unix sed command for additionalways to define pattern match characters.21.8 Build a namespace that has both prefix matches and full string matches.21.9 Suppose a namespace uses fixed string patterns, but allows full string matching in addi-tion to the current prefix matching. Are there instances when it makes sense to have afull string pattern identical to a prefix pattern? Explain.Exercises56921.10    What additional file manipulation primitives might be needed beside rename, delete, andexistence test?21.11 Implement a function unmount that removes a prefix from the mapping table.21.12 As written, the namespace functions rely on a user to install patterns in longest-prefixorder. Rewrite the code to allow a user to mount patterns in an arbitrary order, and ar-range the table by prefix length.21.13 Rewrite function mount (either the original or the version in the previous exercise) tocheck for overlapping patterns, and report an error.21.14 Examine the Network File System technology used with Linux systems that allows re-mote files to be mapped into the directory hierarchy. What basic file operation is not permitted across file systems?Chapter Contents22.1 Introduction, 57322.2 Bootstrap: Starting From Scratch, 57322.3 An Example Of Booting Over A Network, 57422.4 Operating System Initialization, 57522.5 Xinu Initialization, 57622.6 Xinu System Startup, 57922.7 Transforming A Program Into A Process, 58322.8 Perspective, 58422.9 Summary, 58422System Initialization
Only by avoiding the beginning of things can weescape their end.— Cyril Connolly22.1 IntroductionInitialization is the last step of the design process. Designers create a system by thinking about the system in an executing state and postponing the details of how to get the system started. Thinking about initialization early has the same bad effect as worry-ing about optimization early: it tends to impose unnecessary constraints on the design, and diverts the designer’s attention from important issues to trivial ones.This chapter describes the steps required to initialize the system, and explains the conceptual leap that initialization code makes in switching from a program that executes sequentially to a system that supports concurrent processes. We will see that no special hardware steps are involved, and understand that concurrency is an abstraction created entirely by operating system software.22.2 Bootstrap: Starting From ScratchOur discussion of initialization begins with a consideration of system termination. Everyone who has worked with a computer system knows that errant programs or mal-functions in the hardware lead to catastrophic failures popularly called crashes. A crash occurs when the hardware attempts an invalid operation because code or data for a given operation is incorrect. Users know that when a crash occurs, the contents of memory are lost and the operating system must be restarted, which often takes consider-able time.573574 System Initialization Chap. 22How can a computer that is devoid of operating system code spring into action and begin executing? It cannot. Somehow a program must be available before a computercan start. On the oldest machines, restarting was a painful process because a human operator entered the initial program through switches on the front panel. Switches were replaced by keyboards, then by I/O devices such as tapes and disks, and eventually by Read-Only Memory (ROM), and Flash memory.Some embedded devices do more than store an initial program in Flash; they storethe entire operating system, which means that the device can start executing immediate-ly after receiving power (e.g., after the batteries are changed or the device is poweredon). However, most computers take multiple steps when restarting. When power is ap-plied, the hardware executes an initial startup program from Flash. Although it may in-clude mechanisms that allow engineers to debug the hardware, an initial program is usu-ally quite small — its primary function consists of loading and running a larger pro-gram. In a typical personal computer, for example, the startup program powers on de-vices (e.g., a display, keyboard, and disk), searches the disk for a bootable operating system image, copies the operating system image from disk into memory, and then jumps to the entry point of the operating system.Computer systems that do not have permanent storage or embedded systems may use a network: the initial startup program initializes the network interface, and then uses the network to download the operating system image from a remote server. Some Eth-ernet hardware includes firmware and a small onboard processor that can download an image network over a network, store the image in memory, and then start the processor running the image.In some cases, multiple steps are used. The initial startup program loads a larger, more powerful program, which then loads an operating system. Startup programs ar-ranged in a sequence to load ever larger startup programs are often called bootstraps, and the entire process is known as booting the system.† Older names for the bootstrap process include Initial Program Load (IPL) and cold start.22.3 An Example Of Booting Over A NetworkThe Galileo platform provides a specific example of a multi-stage bootstrap. Ourlab at Purdue is designed so systems boot over a network. Unfortunately, a Galileoboard does not have the hardware and software needed to boot over a network. Instead, when it receives power, a Galileo board runs an initial bootstrap program from the on-board Flash memory. The initial bootstrap, supplied by the vendor, can search local de-vices, find a specified image, download the image into memory, and start the processor executing the image. In particular, the initial bootstrap program can be configured to search the micro SD card for an image.To enable network booting, we created a second bootstrap program that includes a network stack plus code to use the network to download an image. We placed a copy of the program on the SD card in each Galileo board. To boot a Galileo board, we power-cycle it. We built a special hardware system to handle the task: the system re-†The terminology derives from the phrase “pulling one’s self up by one’s bootstraps,” a seemingly im-possible task.Sec. 22.3        An Example Of Booting Over A Network 575moves power, waits a short time, and then restores power. Once a Galileo board re-ceives power, the firmware begins the bootstrap process. The initial bootstrap program runs the second stage bootstrap, which uses the lab network to communicate with a server.The server in our lab stores a set of Xinu images, one for each Galileo board. When our network bootstrap program sends a request to the server, the server uses the MAC address in the packet to choose the correct image, and then downloads the image over the network. Figure 22.1 lists the steps.Galileo board receives power and runs an initial bootstrap pro-gram from onboard FlashInitial bootstrap copies a second bootstrap from the SD cardinto memorySecond bootstrap runs and uses the network to download aXinu imageProcessor jumps to the downloaded Xinu imageFigure 22.1The multi-step bootstrap used on the Galileo board to boot overa network.We took an interesting approach to create a bootstrap program that downloads an image from a remote server. Instead of building code from scratch, we took a Xinu sys-tem, removed all the unneeded modules, and wrote a main program that used the Trivial File Transfer Protocol (TFTP) to download an image from a remote server. We call the program Xboot (for Xinu bootstrap).If the Xboot code has been placed in memory, how can Xboot download another image without causing problems? The answer lies in a large memory. Instead of build-ing Xboot to occupy the same memory locations as a standard Xinu image, Xboot is configured to run in high memory locations that lie beyond those used by a standard image. Thus, there is no conflict because Xboot can load a standard Xinu image into low memory without overwriting itself.22.4 Operating System InitializationThe work of initialization does not end when the processor begins to execute the operating system image. Before it is ready to run processes, an operating system must initialize modules in the operating system as well as hardware devices. Figure 22.2 lists the initialization tasks.576 System Initialization Chap. 22Perform initialization required by the hardware platformInitialize the memory management hardware and the freememory listInitialize each operating system moduleLoad (if not present) and initialize a device driver for each de-viceStart (or reset) each I/O deviceTransform from a sequential program to a concurrent systemCreate a null processCreate a process to execute user code (e.g., a desktop)Figure 22.2  Initialization tasks an operating system performs.The most important step occurs after the hardware and operating system modules have been initialized: the operating system must undergo a metamorphosis, changing it-self from a program that executes sequentially into an operating system that runs processes and supports concurrent execution. In the next sections, we will see what happens when Xinu boots, and see exactly how the transformation occurs.22.5 Xinu InitializationThe underlying hardware handles some of the basic initialization tasks, and the bootstrap programs handle others. For example, if the firmware has initialized the busand console I/O device, it may be possible for Xinu to use polled I/O (i.e., kputc and kprintf) immediately after execution begins. On the Galileo, where the address space is not contiguous, the startup program handles the task of finding available addresses. The startup program builds a list of available memory blocks and places the list in memory, making it available to Xinu.Although some low-level initialization is completed before Xinu boots, an assem-bly language initialization function is still required. For example, Xinu must establishthe runtime environment suitable for C. In our code, execution begins at label start,found in file start.S. The BeagleBone Black startup code provides an example://**ssttaarrtt..SS--ssttaarrtt,,bbzzeerroo**//##iinncclluuddee<<aarrmmvv77aa..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ssttaarrtt--IInniittiiaalleennttrryyppooiinnttffoorraaXXiinnuuiimmaaggee((AARRMM))**------------------------------------------------------------------------------------------------------------------------------------------------Sec. 22.5        Xinu Initialization 577**//..tteexxtt..gglloobbllssttaarrtt//**DDeeccllaarreeeennttrryyppooiinnttgglloobbaall**//ssttaarrtt:://**LLooaaddtthheessttaacckkppooiinntteerrwwiitthheennddooffmmeemmoorryy**//llddrrsspp,,==MMAAXXAADDDDRR//**EEnnaabblleetthheeIInnssttrruuccttiioonnCCaacchhee**//mmrrccpp1155,,00,,rr00,,cc11,,cc00,,00oorrrrrr00,,rr00,,##AARRMMVV77AA__CC11CCTTLL__IImmccrrpp1155,,00,,rr00,,cc11,,cc00,,00//**UUsseebbzzeerroo((bbeellooww))ttoozzeerroooouutttthheeBBSSSSaarreeaa**//llddrrrr00,,==eeddaattaallddrrrr11,,==eennddbbllbbzzeerroo//**CCaallllnnuulllluusseerrttooiinniittiiaalliizzeetthheeXXiinnuussyysstteemm**////**((NNoottee::tthheeccaallllnneevveerrrreettuurrnnss))**//bbllnnuulllluusseerr//**FFuunnccttiioonnttoozzeerroommeemmoorryy((rr00iisslloowweessttaaddddrr;;rr11iisshhiigghheesstt))**//bbzzeerroo::mmoovvrr22,,##00//**RRoouunnddaaddddrreessssttoommuullttiippllee**//aaddddrr00,,rr00,,##33//**ooffffoouurrbbyyaaddddiinngg33aanndd**//aannddrr00,,rr00,,##00xxFFFFFFFFFFFFFFCC//**ttaakkiinnggtthheerreessuullttmmoodduullee44**//bblloooopp::ccmmpprr00,,rr11//**LLooooppuunnttiillllaassttaaddddrreessss**//bbhhssbbeexxiitt//**hhaassbbeeeennrreeaacchheedd**//ssttrrrr22,,[[rr00]]//**ZZeerrooffoouurr--bbyytteewwoorrddooffmmeemmoorryy**//aaddddrr00,,rr00,,##44//**MMoovveettoonneexxttwwoorrdd**//bbbblloooopp//**CCoonnttiinnuueettooiitteerraattee**//bbeexxiitt::mmoovvppcc,,llrr//**RReettuurrnnttooccaalllleerr**//The code sets an initial stack pointer, enables the instruction cache, and calls nulluser. Setting the stack pointer is trivial because memory on the BeagleBone Black is contiguous and the highest address is specified by the hardware vendor. The codeuses constantMAXADDR.578 System Initialization Chap. 22The code to enable the instruction cache seems cryptic, but the explanation is straightforward. On an ARM version 7a processor, the co-processor controls the cache.A bit in the co-processor control register determines whether the cache is enabled or disabled. The code fetches a copy of the control register, turns on the cache enable bit (constant ARMv7A_C1CTL_I), and stores the result back in the control register. File armv7a.h, which is included at the beginning of start.S, contains the definition of indi-vidual co-processor registers://**aarrmmvv77aa..hh**////**CCPPSSRRbbiittss**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__AA00xx0000000000110000//**IImmpprreecciisseeddaattaaaabboorrttddiissaabbllee**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__II00xx0000000000008800//**IIRRQQiinntteerrrruuppttssddiissaabbllee**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__FF00xx0000000000004400//**FFIIQQiinntteerrrruuppttssddiissaabbllee**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__MMMM00xx00000000000011FF//**PPrroocceessssoorrMMooddeeMMaasskk**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__UUSSRR00xx0000000000001100//**PPrroocceessssoorrMMooddee==UUsseerr**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__FFIIQQ00xx0000000000001111//**PPrroocceessssoorrMMooddee==FFIIQQ**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__IIRRQQ00xx0000000000001122//**PPrroocceessssoorrMMooddee==IIRRQQ**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__SSPPRR00xx0000000000001133//**PPrroocceessssoorrMMooddee==SSuuppeerrvviissoorr**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__AABBTT00xx0000000000001177//**PPrroocceessssoorrMMooddee==AAbboorrtt**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__UUNNDD00xx00000000000011BB//**PPrroocceessssoorrMMooddee==UUnnddeeffiinneedd**//##ddeeffiinneeAARRMMVV77AA__CCPPSSRR__SSYYSS00xx00000000000011FF//**PPrroocceessssoorrMMooddee==SSyysstteemm**//##ddeeffiinneeAARRMMvv77AA__CCPPSSRR__SSCCMM00xx0000000000001166//**PPrroocceessssoorrMMooddeeSSeeccuurreeMMoonniittoorr**////**CCoopprroocceessssoorrcc11--CCoonnttrroollRReeggiisstteerrbbiittss**//##ddeeffiinneeAARRMMVV77AA__CC11CCTTLL__VV00xx0000000022000000//**EExxcceeppttiioonnbbaasseeaaddddrrccoonnttrrooll**//##ddeeffiinneeAARRMMVV77AA__CC11CCTTLL__II00xx0000000011000000//**IInnssttrruuccttiioonnCCaacchheeeennaabbllee**//##ddeeffiinneeAARRMMVV77AA__CC11CCTTLL__CC00xx0000000000000044//**DDaattaaCCaacchheeeennaabbllee**//##ddeeffiinneeAARRMMVV77AA__CC11CCTTLL__AA00xx0000000000000022//**SSttrriiccttaalliiggnnmmeenntteennaabbllee**//##ddeeffiinneeAARRMMVV77AA__CC11CCTTLL__MM00xx0000000000000011//**MMMMUUeennaabbllee**////**EExxcceeppttiioonnVVeeccttoorrAAddddrreesssseess**//##ddeeffiinneeAARRMMVV77AA__EEVV__SSTTAARRTT00xx44003300CCEE0000//**EExxcceeppttiioonnvveeccttoorrssttaarrttaaddddrr**//##ddeeffiinneeAARRMMVV77AA__EEVV__EENNDD00xx44003300CCEE2200//**EExxcceeppttiioonnvveeccttoorreennddaaddddrr**//##ddeeffiinneeAARRMMVV77AA__EEHH__SSTTAARRTT00xx44003300CCEE2244//**EExxcceeppttiioonnhhaannddlleerrssttaarrttaaddddrr**//##ddeeffiinneeAARRMMVV77AA__EEHH__EENNDD00xx44003300CCEE4400//**EExxcceeppttiioonnhhaannddlleerreennddaaddddrr**//##ddeeffiinneeAARRMMVV77AA__IIRRQQHH__AADDDDRR00xx44003300CCEE3388//**IIRRQQeexxpphhaannddlleerraaddddrreessss**//##ddeeffiinneeMMAAXXAADDDDRR00xxAA00000000000000//**551122MMBBRRAAMMssttaarrttiinnggffrroomm00xx8800000000000000**//Sec. 22.6        Xinu System Startup 57922.6 Xinu System StartupAs the last step, the code in start.S calls function nulluser. A single program, not an operating system, is running when the call occurs.  Nulluser initializes the operating system, creates a process to execute function main, and becomes the null process. If there is drama in the system, it lies here, where the transformation from program to con-current system occurs. The code is found in file initialize.c.//**iinniittiiaalliizzee..cc--nnuulllluusseerr,,ssyyssiinniitt,,ssiizzmmeemm**////**HHaannddlleessyysstteemmiinniittiiaalliizzaattiioonnaannddbbeeccoommeetthheennuullllpprroocceessss**//##iinncclluuddee<<xxiinnuu..hh>>##iinncclluuddee<<ssttrriinngg..hh>>eexxtteerrnnvvooiiddssttaarrtt((vvooiidd));;//**SSttaarrttooffXXiinnuuccooddee**//eexxtteerrnnvvooiidd**__eenndd;;//**EEnnddooffXXiinnuuccooddee**////**FFuunnccttiioonnpprroottoottyyppeess**//eexxtteerrnnvvooiiddmmaaiinn((vvooiidd));;//**MMaaiinniisstthheeffiirrssttpprroocceessssccrreeaatteedd**//eexxtteerrnnvvooiiddxxddoonnee((vvooiidd));;//**SSyysstteemm""sshhuuttddoowwnn""pprroocceedduurree**//ssttaattiiccvvooiiddssyyssiinniitt(());;//**IInntteerrnnaallssyysstteemmiinniittiiaalliizzaattiioonn**//eexxtteerrnnvvooiiddmmeemmiinniitt((vvooiidd));;//**IInniittiiaalliizzeesstthheeffrreeeemmeemmoorryylliisstt**////**DDeeccllaarraattiioonnssooffmmaajjoorrkkeerrnneellvvaarriiaabblleess**//ssttrruuccttpprroocceennttpprrooccttaabb[[NNPPRROOCC]];;//**PPrroocceessssttaabbllee**//ssttrruuccttsseennttrryysseemmttaabb[[NNSSEEMM]];;//**SSeemmaapphhoorreettaabbllee**//ssttrruuccttmmeemmbbllkkmmeemmlliisstt;;//**LLiissttooffffrreeeemmeemmoorryybblloocckkss**////**AAccttiivveessyysstteemmssttaattuuss**//iinnttpprrccoouunntt;;//**TToottaallnnuummbbeerroofflliivveepprroocceesssseess**//ppiidd3322ccuurrrrppiidd;;//**IIDDooffccuurrrreennttllyyeexxeeccuuttiinnggpprroocceessss**////**------------------------------------------------------------------------------------------------------------------------------------------------**nnuulllluusseerr--iinniittiiaalliizzeetthheessyysstteemmaannddbbeeccoommeetthheennuullllpprroocceessss** **NNoottee::eexxeeccuuttiioonnbbeeggiinnsshheerreeaafftteerrtthheeCCrruunn--ttiimmeeeennvviirroonnmmeenntthhaassbbeeeenn**eessttaabblliisshheedd..IInntteerrrruuppttssaarreeiinniittiiaallllyyDDIISSAABBLLEEDD,,aannddmmuusstteevveennttuuaallllyy**bbeeeennaabblleeddeexxpplliicciittllyy..TThheeccooddeettuurrnnssiittsseellffiinnttootthheennuullllpprroocceessss**aafftteerriinniittiiaalliizzaattiioonn..BBeeccaauusseeiittmmuussttaallwwaayyssrreemmaaiinnrreeaaddyyttooeexxeeccuuttee,,580 System Initialization Chap. 22**tthheennuullllpprroocceessssccaannnnootteexxeeccuutteeccooddeetthhaattmmiigghhttccaauusseeiittttoobbee**ssuussppeennddeedd,,wwaaiittffoorraasseemmaapphhoorree,,ppuuttttoosslleeeepp,,oorreexxiitt..IInn**ppaarrttiiccuullaarr,,tthheeccooddeemmuussttnnoottppeerrffoorrmmII//OOeexxcceeppttffoorrppoolllleeddvveerrssiioonnss**ssuucchhaasskkpprriinnttff..**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddnnuulllluusseerr(()){{ssttrruuccttmmeemmbbllkk**mmeemmppttrr;;//**PPttrrttoommeemmoorryybblloocckk**//uuiinntt3322ffrreeee__mmeemm;;//**TToottaallaammoouunnttooffffrreeeemmeemmoorryy**////**IInniittiiaalliizzeetthheessyysstteemm**//ssyyssiinniitt(());;kkpprriinnttff((""\\nn\\rr%%ss\\nn\\nn\\rr"",,VVEERRSSIIOONN));;//**OOuuttppuuttXXiinnuummeemmoorryyllaayyoouutt**//ffrreeee__mmeemm==00;;ffoorr((mmeemmppttrr==mmeemmlliisstt..mmnneexxtt;;mmeemmppttrr!!==NNUULLLL;;mmeemmppttrr==mmeemmppttrr-->>mmnneexxtt)){{ffrreeee__mmeemm++==mmeemmppttrr-->>mmlleennggtthh;;}} kkpprriinnttff((""%%1100ddbbyytteessooffffrreeeemmeemmoorryy..FFrreeeelliisstt::\\nn"",,ffrreeee__mmeemm));;ffoorr((mmeemmppttrr==mmeemmlliisstt..mmnneexxtt;;mmeemmppttrr!!==NNUULLLL;;mmeemmppttrr==mmeemmppttrr-->>mmnneexxtt)){{kkpprriinnttff((""[[00xx%%0088XXttoo00xx%%0088XX]]\\rr\\nn"",,((uuiinntt3322))mmeemmppttrr,,((((uuiinntt3322))mmeemmppttrr))++mmeemmppttrr-->>mmlleennggtthh--11));;}} kkpprriinnttff((""%%1100ddbbyytteessooffXXiinnuuccooddee..\\nn"",,((uuiinntt3322))&&eetteexxtt--((uuiinntt3322))&&tteexxtt));;kkpprriinnttff((""[[00xx%%0088XXttoo00xx%%0088XX]]\\nn"",,((uuiinntt3322))&&tteexxtt,,((uuiinntt3322))&&eetteexxtt--11));;kkpprriinnttff((""%%1100ddbbyytteessooffddaattaa..\\nn"",,((uuiinntt3322))&&eebbssss--((uuiinntt3322))&&ddaattaa));;kkpprriinnttff((""[[00xx%%0088XXttoo00xx%%0088XX]]\\nn\\nn"",,((uuiinntt3322))&&ddaattaa,,((uuiinntt3322))&&eebbssss--11));;//**EEnnaabblleeiinntteerrrruuppttss**//eennaabbllee(());;//**CCrreeaatteeaapprroocceessssttooeexxeeccuutteeffuunnccttiioonnmmaaiinn(())**//Sec. 22.6        Xinu System Startup 581rreessuummee((ccrreeaattee((((vvooiidd**))mmaaiinn,,IINNIITTSSTTKK,,IINNIITTPPRRIIOO,,""MMaaiinnpprroocceessss"",,00,,NNUULLLL))));;//**BBeeccoommeetthheeNNuullllpprroocceessss((ii..ee..,,gguuaarraanntteeeetthhaatttthheeCCPPUUhhaass**////**ssoommeetthhiinnggttoorruunnwwhheennnnooootthheerrpprroocceessssiissrreeaaddyyttooeexxeeccuuttee))**//wwhhiillee((TTRRUUEE)){{;;//**DDoonnootthhiinngg**//}}}} //**------------------------------------------------------------------------------------------------------------------------------------------------** **ssyyssiinniitt--IInniittiiaalliizzeeaallllXXiinnuuddaattaassttrruuccttuurreessaannddddeevviicceess** **------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattiiccvvooiiddssyyssiinniitt(()){{iinntt3322ii;;ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessssttaabblleeeennttrryy**//ssttrruuccttsseennttrryy**sseemmppttrr;;//**PPttrrttoosseemmaapphhoorreettaabblleeeennttrryy**////**PPllaattffoorrmmSSppeecciiffiiccIInniittiiaalliizzaattiioonn**//ppllaattiinniitt(());;//**IInniittiiaalliizzeetthheeiinntteerrrruuppttvveeccttoorrss**//iinniitteevveecc(());;//**IInniittiiaalliizzeeffrreeeemmeemmoorryylliisstt**//mmeemmiinniitt(());;//**IInniittiiaalliizzeessyysstteemmvvaarriiaabblleess**////**CCoouunntttthheeNNuullllpprroocceessssaasstthheeffiirrssttpprroocceessssiinntthheessyysstteemm**//pprrccoouunntt==11;;//**SScchheedduulliinnggiissnnoottccuurrrreennttllyybblloocckkeedd**//DDeeffeerr..nnddeeffeerrss==00;;582 System Initialization Chap. 22//**IInniittiiaalliizzeepprroocceessssttaabblleeeennttrriieessffrreeee**//ffoorr((ii==00;;ii<<NNPPRROOCC;;ii++++)){{pprrppttrr==&&pprrooccttaabb[[ii]];;pprrppttrr-->>pprrssttaattee==PPRR__FFRREEEE;;pprrppttrr-->>pprrnnaammee[[00]]==NNUULLLLCCHH;;pprrppttrr-->>pprrssttkkbbaassee==NNUULLLL;;pprrppttrr-->>pprrpprriioo==00;;}} //**IInniittiiaalliizzeetthheeNNuullllpprroocceesssseennttrryy**//pprrppttrr==&&pprrooccttaabb[[NNUULLLLPPRROOCC]];;pprrppttrr-->>pprrssttaattee==PPRR__CCUURRRR;;pprrppttrr-->>pprrpprriioo==00;;ssttrrnnccppyy((pprrppttrr-->>pprrnnaammee,,""pprrnnuullll"",,77));;pprrppttrr-->>pprrssttkkbbaassee==ggeettssttkk((NNUULLLLSSTTKK));;pprrppttrr-->>pprrssttkklleenn==NNUULLLLSSTTKK;;pprrppttrr-->>pprrssttkkppttrr==00;;ccuurrrrppiidd==NNUULLLLPPRROOCC;;//**IInniittiiaalliizzeesseemmaapphhoorreess**//ffoorr((ii==00;;ii<<NNSSEEMM;;ii++++)){{sseemmppttrr==&&sseemmttaabb[[ii]];;sseemmppttrr-->>ssssttaattee==SS__FFRREEEE;;sseemmppttrr-->>ssccoouunntt==00;;sseemmppttrr-->>ssqquueeuuee==nneewwqquueeuuee(());;}} //**IInniittiiaalliizzeebbuuffffeerrppoooollss**//bbuuffiinniitt(());;//**CCrreeaatteeaarreeaaddyylliissttffoorrpprroocceesssseess**//rreeaaddyylliisstt==nneewwqquueeuuee(());;//**IInniittiiaalliizzeetthheerreeaallttiimmeecclloocckk**//ccllkkiinniitt(());;ffoorr((ii==00;;ii<<NNDDEEVVSS;;ii++++)){{iinniitt((ii));;}}Sec. 22.6        Xinu System Startup 583rreettuurrnn;;}} iinntt3322ssttoopp((cchhaarr**ss)){{kkpprriinnttff((""%%ss\\nn"",,ss));;kkpprriinnttff((""llooooppiinngg......pprreessssrreesseett\\nn""));;wwhhiillee((11))//**EEmmppttyy**//;;}} iinntt3322ddeellaayy((iinnttnn)){{DDEELLAAYY((nn));;rreettuurrnnOOKK;;}}Nulluser itself is exceedingly simple. It calls function sysinit to initialize the sys-tem data structures. When sysinit returns, the running program has become the nullprocess (process 0), but interrupts remain disabled and no other processes exist. After printing a few introductory messages, nulluser enables interrupts, and calls create to start a process running the user’s main program.Because the program executing nulluser has become the null process, it cannot exit, sleep, wait for a semaphore, or suspend itself. Fortunately, the initialization func-tion does not perform any action that takes the caller out of the current or ready states. If such actions were needed, sysinit would have created another process to handle the action. Once initialization is complete and a process has been created to execute the user’s main program, the null process falls into an infinite loop, giving resched a proc-ess to schedule when no user processes are ready to run.22.7 Transforming A Program Into A ProcessFunction sysinit handles the task of system initialization. It makes a series of callsto initialize the hardware platform (platinit), exception vectors (initevec), and thememory free list (meminit). It initializes remaining system data structures, such as the process table and semaphore table, and calls clkinit to initialize the real-time clock. Fi-nally, sysinit iterates through the devices that have been configured and calls the initiali-zation function for each device. To do so, it invokes init for the device ID.The most interesting piece of the initialization code occurs about half-way through sysinit when it fills in the process table entry for process zero. Many of the processtable fields, such as the process name field, can be left uninitialized — they are filled in merely to make debugging easier. The real work is done by the two lines that set the current process ID variable, currpid, to the ID of the null process, and assign PR_CURR584 System Initialization Chap. 22to the process state field of the process table entry. Until currpid and the state havebeen assigned, rescheduling is impossible. Once the process table entry and currpidhave been assigned, the program has become a currently running process that has proc-ess ID zero, and is available for context switching.To summarize:After it fills in the process table entry for process zero, the code sets variable currpid to zero, which transforms the sequential program into a process.Once the null process has been created, all that remains is for sysinit to initialize the other pieces of the system before it returns so that all services are available when function nulluser starts a process executing the user’s main program. When it is resumed, the new process will have a higher priority than the null process. Therefore, resched will switch context to the new process, and the scheduling invariant will be in effect.22.8 PerspectiveThe intellectually significant aspects of operating system design arise when new abstractions are created on top of low-level hardware. In the case of system initializa-tion, the details are not as important as the conceptual transformation: the processor starts a fetch-execute cycle running instructions sequentially, and the initialization code self-transforms into a concurrent processing system. The important point is that the ini-tial code does not create a separate, concurrent system and then jump to the new sys-tem. No leap is made to reach the abstraction, and the original sequential execution is not abandoned. Instead, the running code declares itself to be a process, fills in the sys-tem data structures needed to support the declaration, and eventually allows other processes to execute. Meanwhile, the processor continues the fetch-execute cycle, and the new abstraction emerges without any disruption.22.9 SummaryInitialization is the last step of system design; it should be postponed to avoid changing the design simply to make initialization easier. Although initialization in-volves many details, the most conceptually interesting part involves the transformation from a sequential program to a system that supports concurrent processing. To make it-self correspond to the null process, the code fills in the process table entry for process zero and sets variable currpid to zero.Exercises585EXERCISES22.1 What is the BIOS on an x86 computer, and what does it do?22.2 If you were designing a bootstrap loader program, what functionality would you include?Why?22.3  Read about the GRUB and UBOOT bootstrap programs. What functionality does eachprovide?22.4 Is the order of initialization important for the process table, semaphore table, memoryfree list, devices, and ready list? Explain.22.5 On many systems, it is possible to create a function sizmem that finds the highest validmemory address by probing memory until an exception occurs. Is such a function possi-ble on the example platforms? Why or why not?22.6 Explain, by tracing through the functions involved, what would go wrong if nulluser en-abled interrupts before calling sysinit.22.7 The network code, remote disk driver, and remote file system driver each create a proc-ess. Should the processes be created in sysinit? Why or why not?22.8 Most operating systems arrange for the network code to run and obtain an IP address be-fore the system starts any user processes. Design a way for Xinu to create a network process, wait for the network process to obtain an IP address, and then create a process to run the main program. Be careful: the null process cannot block.Chapter Contents23.1 Introduction, 58923.2 Self-initializing Modules, 59023.3 Self-initializing Modules In A Concurrent System, 59123.4 Self-initialization In The Presence Of Reboot, 59323.5 Initialization Using Accession Numbers, 59323.6 A Generalized Memory Marking Scheme, 59523.7 Data Declarations For The Memory Marking System, 59623.8 Implementation Of Marking, 59823.9 Perspective, 59923.10 Summary, 59923Subsystem Initialization And Memory Marking
The best thing about endings is knowing that justahead lies the daunting task to start over— Jodi Picoult23.1 IntroductionThe previous chapter considers hardware bootstrap and operating system initializa-tion. The chapter explains how an operating system starts as a program that executes instructions, and how, after initializing system variables and data structures, the initiali-zation code creates a process to start executing the main function, and then becomes the null process.This chapter extends our examination of initialization by considering two broad questions. First, if we divide sets of functions into modules, how can each perform self-initialization without relying on a central initialization function? Second, ifmodules remain resident in memory across system reboots, how can each module know whether it has been reinitialized following the latest reboot? The chapter introduces an elegant, compact mechanism called memory marking that allows self-initializing modules to be created. The system correctly identifies whether a module needs to be reinitialized, even if the module remains resident in memory across a system reboot.589590 Subsystem Initialization And Memory Marking Chap. 2323.2 Self-initializing ModulesWe use the term module to refer to a set of functions and the shared data on which they operate. Although the C language does not have encapsulation mechanisms that permit a programmer to specify modules, we can think of code being divided into con-ceptual modules. For example, consider the buffer pool mechanism described in Chapter 10 and the high-level message passing mechanism described in Chapter 11. In each case, a set of functions operates on a shared data structure. The buffer pool module offers four primary functions:poolinit mkpool getbuf freebufEach of the functions is written to assume that poolinit will be called before any ofthe other functions are invoked. As we have seen, sysinit makes the call to poolinitwhen the operating system functions are being initialized. Similarly, sysinit calls ptinitto initialize the port mechanism.Relying on sysinit to initialize each module has several disadvantages. First, a pro-grammer cannot add a new module to the operating system without modifying a funda-mental system function, sysinit. More important, a programmer must understand which other modules a given initialization function uses, and must insert the new initialization call after the other modules are initialized. Second, if the initialization call is acciden-tally omitted, the module may operate incorrectly and cause the system to fail. Third, placing a call of the initialization function in sysinit forces the loader to include the ini-tialization function and shared data items, even if other functions in the module are not used. On an embedded system with constrained memory, programmers cannot afford to include items that are not needed — if sysinit references all possible modules, the image may be too large to fit in memory.How can a programmer arrange for module initialization without placing an expli-cit call in sysinit? The answer lies in self-initializing modules. For a conventional C program, self-initializing is trivial: declare a global variable with an initial value that specifies whether initialization has been performed, and insert code at the beginning of each function to test the global variable. For example, Figure 23.1 shows the general structure of code for a module that has two functions, func_1 and func_2, plus an ini-tialization function, func_init. Each function includes an extra line of code that exam-ines global variable needinit, which is statically initialized to 1. If needinit is 1 when a function is called, func_init is invoked to perform initialization.Sec. 23.2        Self-initializing Modules 591//**EExxaammpplleeooffaasseellff--iinniittiiaalliizziinnggmmoodduulleetthhaattuusseessaagglloobbaallvvaarriiaabbllee**//iinntt3322nneeeeddiinniitt==11;;//**NNoonn--zzeerroouunnttiilliinniittiiaalliizzeedd**//... declarations for other global data structuresvvooiiddffuunncc__11((... args)){{iiff((nneeeeddiinniitt))ffuunncc__iinniitt(());;//**IInniittiiaalliizzeebbeeffoorreepprroocceeeeddiinngg**//... code for func_1rreettuurrnn;;}} vvooiiddffuunncc__22((... args)){{iiff((nneeeeddiinniitt))ffuunncc__iinniitt(());;//**IInniittiiaalliizzeebbeeffoorreepprroocceeeeddiinngg**//... code for func_2rreettuurrnn;;}} vvooiiddffuunncc__iinniitt((vvooiidd)){{iiff((nneeeeddiinniitt!!==00)){{//**IInniittiiaalliizzaattiioonniissnneeeeddeedd**//... code to perform initializationnneeeeddiinniitt==00;;}} rreettuurrnn;;}}Figure 23.1An example showing the structure of a conventional C programthat uses a global variable to control self-initialization.Although it works in a conventional program, the approach outlined above doesnot suffice for modules in our operating system. There are two reasons: concurrencyand reboot. First we will discuss how to handle concurrency, and then we will look at reboot.23.3 Self-initializing Modules In A Concurrent SystemTo see what can happen to the module in Figure 23.1 if concurrent processes make calls to the functions, consider a worst-case scenario. Suppose two processes, P1  and P2 attempt to use the module, and consider context switching between them. If one proc-ess calls function func_1 and the other calls func_2, both processes could be executing func_init to initialize global data structures the module uses. One of the processes592 Subsystem Initialization And Memory Marking Chap. 23might finish initialization, return to its function, and start using the global data struc-tures while the other process continues initialization which overwrites the values.The options for handling concurrent execution consist of disabling interrupts or us-ing a mutual exclusion semaphore. A mutex semaphore minimizes interference withother system activities — a process will only block if it attempts to use the modulewhile another process is already using it. Otherwise, no processes block, and interruptsare not disabled. However, semaphore creation requires initialization, which means we cannot use semaphores to control access to the initialization function. Figure 23.2 illus-trates a hybrid solution that disables interrupts during initialization, and uses a sema-phore to provide mutual exclusion for normal execution.//**AAsseellff--iinniittiiaalliizziinnggmmoodduulleetthhaattppeerrmmiittssccoonnccuurrrreennttaacccceessss**//iinntt3322nneeeeddiinniitt==11;;//**NNoonn--zzeerroouunnttiilliinniittiiaalliizzeedd**//ssiidd3322mmuutteexx;;//**MMuuttuuaalleexxcclluussiioonnsseemmaapphhoorreeIIDD**//vvooiiddffuunncc__11((... args)){{iinnttmmaasskkmmaasskk;;mmaasskk==ddiissaabbllee(());;//**DDiissaabblleedduurriinnggiinniittiiaalliizzaattiioonn**//iiff((nneeeeddiinniitt))ffuunncc__iinniitt(());;//**IInniittiiaalliizzeebbeeffoorreepprroocceeeeddiinngg**//rreessttoorree((mmaasskk));;//**RReessttoorreeiinntteerrrruuppttss**//wwaaiitt((mmuutteexx));;//**UUsseemmuutteexxffoorreexxcclluussiivveeaacccceessss**//... code for func_1ssiiggnnaall((mmuutteexx));;//**RReelleeaasseetthheemmuutteexx**//rreettuurrnn;;}}. . . other functions in the module structured as abovevvooiiddffuunncc__iinniitt((vvooiidd)){{iinnttmmaasskkmmaasskk;;mmaasskk==ddiissaabbllee(());;iiff((nneeeeddiinniitt!!==00)){{//**IInniittiiaalliizzaattiioonniissssttiillllnneeeeddeedd**//mmuutteexx==sseemmccrreeaattee((11));;//**CCrreeaatteetthheemmuutteexxsseemmaapphhoorree**//... code to perform other initializationnneeeeddiinniitt==00;;}} rreessttoorree((mmaasskk));;rreettuurrnn;;}}Figure 23.2 An illustration of a self-initializing module that permits con-current access.Sec. 23.3        Self-initializing Modules In A Concurrent System 593As the code shows, disable and restore are only used when the initialization is test-ed or performed, which means functions in the module can take arbitrarily long without causing problems for devices. Note that func_init disables interrupts even though indi-vidual functions (e.g., func_1) disable interrupts before calling func_init. The use of disable and restore allows func_init to be called directly by a user process or from a function in the module. In either case, the initialization function will return to the caller with interrupts in the same state as when the call was made. Exercises consider alterna-tive structures.Also note that when the initialization finishes, two things will have been accom-plished. First, the module’s data structures will have been initialized. Second, the mu-tual exclusion semaphore will have been created, and its ID will have been placed in global variablemutex ready for functions in the module to use.23.4 Self-initialization In The Presence Of RebootAs an added complication, consider rebooting a system where all code and data remain resident in memory. For example, an early version of Xinu allowed reboot to avoid slow speed downloading. Rebooting a resident system adds a complication to ini-tialization because global variables (i.e., variables in the data segment) will not be reset to their initial values. For example, consider variable needinit in Figure 23.2. When the operating system is loaded, the variable has the value 1. As soon as any of the functions in the module are called, initialization will be performed, and needinit will have the value 0. If the operating system is restarted, the module will not be reinitial-ized.To understand the potential consequences, consider a module that allocates heap memory. The initialization function will call getmem, and will save a pointer to the al-located memory. Functions in the module use the pointer to access the allocated memory. When the operating system reboots, all heap memory will be placed on the free list, and will be available for allocation. Suppose that after the reboot, the order in which processes execute differs from the order in the initial run. It could happen that the memory block allocated to a module in the first run of the system is allocated for another purpose in the second run. If a module continues to assume it owns the memory block that was allocated in the first run, the module can write into a memory block owned by another process. Such errors are especially difficult to find.23.5 Initialization Using Accession NumbersFor systems where the integer size is large and reboots do not occur often, the ini-tialization problem can be handled with an accession number scheme. The scheme usesa single global counter for the operating system plus a global counter for each module. The operating system counter is used to count how many times the operating system has rebooted, and the global variable for each module is used to count the number of times594 Subsystem Initialization And Memory Marking Chap. 23the module has been initialized. The value of all counters is initialized to 0 at compile time. The operating system boot counter is incremented when sysinit executes, so it will be 1 on the first run of the system.Assuming a module must be initialized once each time the system boots, the use of accession numbers should be clear. The module initialization test can be replaced by a comparison: the module should be initialized if the system’s boot counter exceeds the module’s initialization counter. Figure 23.3 illustrates the use of accession numbers.//**AAsseellff--iinniittiiaalliizziinnggmmoodduulleeuussiinnggaacccceessssiioonnnnuummbbeerrss**//eexxtteerrnniinntt3322bboooott;;//**CCoouunnttooffttiimmeessOOSSbboooottss**//iinntt3322mmiinniitt==00;;//**CCoouunnttooffmmoodduulleeiinniittiiaalliizzaattiioonnss**//ssiidd3322mmuutteexx;;//**MMuuttuuaalleexxcclluussiioonnsseemmaapphhoorreeIIDD**//vvooiiddffuunncc__11((... args)){{iiff((mmiinniitt<<bboooott))ffuunncc__iinniitt(());;//**IInniittiiaalliizzeebbeeffoorreepprroocceeeeddiinngg**//wwaaiitt((mmuutteexx));;//**UUsseemmuutteexxffoorreexxcclluussiivveeaacccceessss**//... code for func_1ssiiggnnaall((mmuutteexx));;//**RReelleeaasseetthheemmuutteexx**//rreettuurrnn;;}}. . . other functions in the module structured as abovevvooiiddffuunncc__iinniitt((vvooiidd)){{iinnttmmaasskkmmaasskk;;mmaasskk==ddiissaabbllee(());;iiff((mmiinniitt<<bboooott)){{//**IInniittiiaalliizzaattiioonniissssttiillllnneeeeddeedd**//mmuutteexx==sseemmccrreeaattee((11));;//**CCrreeaatteetthheemmuutteexxsseemmaapphhoorree**//... code to perform other initializationmmiinniitt++++;;}} rreessttoorree((mmaasskk));;rreettuurrnn;;}}Figure 23.3Illustration of a self-initializing module using accession numbersto handle system reboot.Sec. 23.6        A Generalized Memory Marking Scheme 59523.6 A Generalized Memory Marking SchemeThe accession number scheme illustrated in Figure 23.3 makes an important as-sumption: the reboot counter will never wrap around. On a system with 32-bit integers, rebooting once per second and using unsigned arithmetic means the system can run for over one-hundred years before the counter wraps around. On 8-bit and 16-bit embedded processors, an accession number mechanism will not suffice.The question arises: how can self-initializing modules work in a concurrent en-vironment on a processor with a small range of integer values? Of course, one could write code to compute 32-bit values using smaller integers. However, the author creat-ed an elegant and efficient technique to handle the problem. Known as memory mark-ing, the technique requires almost no overhead and accommodates dynamic module loading as well as the static modules described in this chapter.Memory marking defines a new data type (memmark) and two functions to mani-pulate the data type:memmark L; – Declare L to be a location that can be marked mark(L); – Mark location Lnotmarked(L) – Non-zero if location L is not markedAfter an operating system reboot, none of the locations in memory has been marked. Thererfore, notmarked returns non-zero. After mark has been called to mark a location, notmarked returns 0 for that location. It may seem odd that the second func-tion tests whether a location is unmarked instead of whether the location is marked. However, we will see that the most common situation involves taking action when a lo-cation has not yet been marked. For example, the code for a typical check might ap-pear:iiff((nnoottmmaarrkkeedd((xxxxxx)))){{...code to perform initializationmmaarrkk((xxxxxx));;}}where xxx is a variable declared to be of type memmark. Of course, when used in a concurrent processing system, additional code is needed to disable interrupts to guaran-tee that no other process can interfere with initialization.Figure 23.4 shows how memory marking facilities can be inserted into a self-initializing module.596 Subsystem Initialization And Memory Marking Chap. 23//**AAsseellff--iinniittiiaalliizziinnggmmoodduulleeuussiinnggmmeemmoorryymmaarrkkiinngg**//mmeemmmmaarrkklloocc;;//**CCoouunnttooffmmoodduulleeiinniittiiaalliizzaattiioonnss**//ssiidd3322mmuutteexx;;//**MMuuttuuaalleexxcclluussiioonnsseemmaapphhoorreeIIDD**//vvooiiddffuunncc__11((... args)){{iiff((nnoottmmaarrkkeedd((lloocc))))ffuunncc__iinniitt(());;//**IInniittiiaalliizzeetthheemmoodduullee**//wwaaiitt((mmuutteexx));;//**UUsseemmuutteexxffoorreexxcclluussiivveeaacccceessss**//... code for func_1ssiiggnnaall((mmuutteexx));;//**RReelleeaasseetthheemmuutteexx**//rreettuurrnn;;}}. . . other functions in the module structured as abovevvooiiddffuunncc__iinniitt((vvooiidd)){{iinnttmmaasskkmmaasskk;;mmaasskk==ddiissaabbllee(());;iiff((nnoottmmaarrkkeedd((lloocc)))){{mmuutteexx==sseemmccrreeaattee((11));;//**CCrreeaatteetthheemmuutteexxsseemmaapphhoorree**//... code to perform other initializationmmaarrkk((lloocc));;}} rreessttoorree((mmaasskk));;rreettuurrnn;;}}Figure 23.4  An illustration of a module using memory marking.23.7 Data Declarations For The Memory Marking SystemThe implementation of memory marking is surprisingly efficient in both the time required and space occupied. In essence, the system stores a list of memory locations that have been marked in array marks. The system uses integer nmarks to store an in-teger count of the number of items currently in the marks array. Each marked location is an integer. When the location is marked, the system stores a value in the locationthat gives the index in the marks array corresponding to the location.Testing whether a location L has been marked is straightforward: extract the in-teger value from location L, call it I. IfI is out of range of the marks array or the IthSec. 23.7        Data Declarations For The Memory Marking System 597entry in the marks array does not contain L, the location is not marked. File mark.hcontains the data declarations as well as inline function notmarked.//**mmaarrkk..hh--nnoottmmaarrkkeedd**//##ddeeffiinneeMMAAXXMMAARRKK2200//**MMaaxxiimmuummnnuummbbeerrooffmmaarrkkeeddllooccaattiioonnss**//eexxtteerrnniinntt3322**((mmaarrkkss[[]]));;eexxtteerrnniinntt3322nnmmaarrkkss;;eexxtteerrnnssiidd3322mmkkmmuutteexx;;ttyyppeeddeeffiinntt3322mmeemmmmaarrkk[[11]];;//**DDeeccllaarreeaammeemmoorryymmaarrkkttoobbeeaannaarrrraayy**////**ssoouusseerrccaannrreeffeerreenncceetthheennaammee**////**wwiitthhoouuttaalleeaaddiinngg&&**////**------------------------------------------------------------------------------------------------------------------------------------------------**nnoottmmaarrkkeedd--RReettuurrnnnnoonnzzeerrooiiffaallooccaattiioonnhhaassnnoottbbeeeennmmaarrkkeedd**------------------------------------------------------------------------------------------------------------------------------------------------**//##ddeeffiinneennoottmmaarrkkeedd((LL))((LL[[00]]<<00||||LL[[00]]>>==nnmmaarrkkss||||mmaarrkkss[[LL[[00]]]]!!==LL))The memory marking code exploits a C language subtlety to make using memory marks easier and safer. In C, the name of an array gives a pointer to the array. When a programmer declares a variable to be of type memmark, the result is an integer array with one element. For example, when a programmer declares:mmeemmmmaarrkklloocc;;the compiler allocates storage for a single integer. However, because the type of vari-able loc is an array rather than an integer, references to loc in a program result in a pointer. Therefore, when a programmer writes:mmaarrkk((lloocc));;the compiler passes the address of loc without requiring a programmer to remember to include an ampersand. The code for notmarked should now be clear: when a program-mer writes:nnoottmmaarrkkeedd((lloocc))to invoke the notmarked macro, argument loc will be an array with one location, not an integer. Therefore, to find the integer value stored in loc, the code dereferences the ar-ray (i.e., refers to loc[0] rather than to loc).598 Subsystem Initialization And Memory Marking Chap. 2323.8 Implementation Of MarkingFile mark.c contains code for the two remaining functions of the memory marking system: markinit and mark. Function markinit is called when the operating system re-boots (e.g., in Xinu, it is called from sysinit). Markinit sets the count of marked loca-tions to zero, and allocates a mutual exclusion semaphore. Oncemarkinit has initialized the system, modules can call mark to mark a specific location.//**mmaarrkk..cc--mmaarrkkiinniitt,,mmaarrkk**//##iinncclluuddee<<xxiinnuu..hh>>iinntt3322**mmaarrkkss[[MMAAXXMMAARRKK]];;//**PPooiinntteerrssttoommaarrkkeeddllooccaattiioonnss**//iinntt3322nnmmaarrkkss;;//**NNuummbbeerrooffmmaarrkkeeddllooccaattiioonnss**//ssiidd3322mmkkmmuutteexx;;//**MMuuttuuaalleexxcclluussiioonnsseemmaapphhoorree**////**------------------------------------------------------------------------------------------------------------------------------------------------**mmaarrkkiinniitt--CCaalllleeddoonncceeaattssyysstteemmssttaarrttuupp**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddmmaarrkkiinniitt((vvooiidd)){{nnmmaarrkkss==00;;mmkkmmuutteexx==sseemmccrreeaattee((11));;}} //**------------------------------------------------------------------------------------------------------------------------------------------------**mmaarrkk--MMaarrkkaassppeecciiffiieeddmmeemmoorryyllooccaattiioonn**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussmmaarrkk((iinntt3322**lloocc//**LLooccaattiioonnttoommaarrkk**//)){{//**IIffllooccaattiioonniissaallrreeaaddyymmaarrkkeedd,,ddoonnootthhiinngg**//iiff((((**lloocc>>==00))&&&&((**lloocc<<nnmmaarrkkss))&&&&((mmaarrkkss[[**lloocc]]====lloocc)))){{rreettuurrnnOOKK;;}} //**IIffnnoommoorreemmeemmoorryymmaarrkkssaarreeaavvaaiillaabbllee,,iinnddiiccaatteeaanneerrrroorr**//Sec. 23.8        Implementation Of Marking 599iiff((nnmmaarrkkss>>==MMAAXXMMAARRKK)){{rreettuurrnnSSYYSSEERRRR;;}} //**OObbttaaiinneexxcclluussiivveeaacccceessssaannddmmaarrkktthheessppeecciiffiieeddllooccaattiioonn**//wwaaiitt((mmkkmmuutteexx));;mmaarrkkss[[((**lloocc))==nnmmaarrkkss++++]]==lloocc;;ssiiggnnaall((mmkkmmuutteexx));;rreettuurrnnOOKK;;}}One line of code in function mark does the work of marking a location:mmaarrkkss[[((**lloocc))==nnmmaarrkkss++++]]==lloocc;;The single line increments the number of marks, assigns the original value to the loca-tion, and uses the number as an index into the marks array to set the entry to the ad-dress of the location being marked.23.9 PerspectiveSince the publication of the first edition of the Xinu book, engineers have written to say they used the memory marking approach when building embedded software sys-tems. In other words, the mechanism is quite practical. The author originally created the memory marking mechanism while he was a graduate student, and the purpose was to solve a homework problem in a theory class. Ironically, the professor in the class did not appreciate the practicality of the scheme.Even if you skim over everything else in this chapter, take a moment to look at the line of code discussed above. In most languages, marking a memory location would re-quire multiple lines of code, and would not compile into minimal instructions. In C, the source code is incredibly compact, and the compiler can produce an efficient implemen-tation.23.10 SummarySeveral techniques are available to allow a module to initialize itself. The standard programming technique of using an initialized global variable can be extended to a con-current programming environment by disabling interrupts during initialization. A hy-brid scheme can restrict disabling interrupts to the initialization code, and can use a mu-tual exclusion semaphore to allow the functions in the module to execute with interrupts enabled.600 Subsystem Initialization And Memory Marking Chap. 23The memory marking technique generalizes self-initialization to handle reboot ofan operating system without reloading the image. Memory marking is both efficientand elegant. The implementation uses the trick of declaring an array of one location to allow a programmer to declare a memory mark, x, pass the name x as an argument to notmarked and mark, even though the functions require an address.EXERCISES23.1 The module shown in Figure 23.2 arranges for function func_1 to disable interrupts be-fore the if statement that checks global variable needinit, and restore interrupts afterward. Argue that removing the calls to disable and restore in func_1 will not change correct-ness.23.2 Extend the previous exercise by removing the calls to disable, restore, and the condition-al check of needinit (i.e., simply have func_1 call func_init and then wait on the mutex).Show that the resulting code is still correct. What is the advantage of keeping the if statement?23.3 Can multiple processes call notmarked and mark concurrently or will problems result?Explain.23.4  The code in mark can be rewritten to use the notmarked macro. What is the disadvan-tage of using the macro?23.5 Modify the buffer pool functions from Chapter 10 to use memory marking and to beself-initializing.23.6 Consider an operating system that provides dynamic loading (i.e., the system can load amodule into memory at runtime). Is memory marking useful in such a system? Explain.Chapter Contents24.1 Introduction, 60324.2 Terminology: Faults, Checks, Traps, And Exceptions, 60324.3 Vectored Exceptions And Maskable Interrupts, 60424.4 Types Of Exceptions, 60424.5 Handling Exceptions, 60524.6 Exception Vector Initialization, 60624.7 Panic In The Face Of Catastrophic Problems, 60624.8 Implementation Of Panic, 60724.9 Perspective, 60724.10 Summary, 60824Exception Handling
I never make exceptions. An exception disproves the rule.— Sir Arthur Conan Doyle24.1 IntroductionThis chapter discusses the topic of exception handling. Because the underlying hardware dictates exactly how an exception is reported, the techniques an operating sys-tem uses to handle exceptions depend entirely on the hardware. Therefore, we will describe how exceptions are handled on the example platforms, and leave readers to ex-plore other systems and architectures.In general, exception handling is concerned with details rather than concepts. Therefore, the chapter contains fewer broad concepts than earlier chapters. The reader should think of it as an example, and be aware that both the details and techniques may change if another hardware system is used.24.2 Terminology: Faults, Checks, Traps, And ExceptionsA variety of terms have been used to describe problems that can occur during exe-cution, and various hardware vendors have preferred terminology. Early computers used the term check (or machine check) to refer to an internal hardware malfunction.For example, an early version of Xinu ran on hardware that could detect a power supply failure. That is, as the voltage began to fall, the processor informed the operating sys-tem.††Although it seems unlikely that an operating system would have time to respond during a power failure, on the occasion when a power supply did fail, Xinu was able to print a “power failure” message before losing power.603604 Exception Handling Chap. 24Originally, the term fault was used to refer to problems associated with hardware, as opposed to errors that are caused by software. When demand paging was invented, however, the term page fault was used to describe a condition where a referenced page is not resident in memory. As paging became popular, faults became associated with page faults, and the distinction between hardware faults and software faults was lost.When an error situation arises, the hardware must have a way to inform the operat-ing system. Some vendors use the term trap, and say that the hardware traps to the operating system. As we have seen, the hardware must also inform the operating sys-tem when an I/O device needs service, and hardware is often designed to use a single mechanism for both errors and interrupts.24.3 Vectored Exceptions And Maskable InterruptsCurrently, most vendors use the generic term exception to refer to any conditionthat is unexpected. We say that the hardware “raises an exception” to indicate a prob-lem. Exceptions include a broad range of conditions, including page faults, arithmetic errors (e.g., divide by zero), illegal instructions, bus errors, page faults, and I/O inter-rupts. As we have seen, systems can use a single vectored mechanism to handle all ex-ceptions.Despite using a single mechanism, all exceptions are not treated exactly the same.The main difference arises because a processor can mask some exceptions, but not oth-ers. We have seen that an operating system can disable interrupts. The term maskable interrupt occurs because disabling interrupts requires the operating system to set inter-rupt mask bits in an internal hardware register. Some hardware only provides one mask bit (i.e., interrupts are disabled or enabled). Other hardware uses multiple bits to pro-vide multiple levels of interrupts. On such systems, a processor can disable interrupts on lower-priority devices while still permitting interrupts on higher-priority devices. In-terrupt controller hardware may also provide a mask for specific IRQs, which allows a processor to disable or enable interrupts on individual devices (e.g., to stop a Wi-Fi de-vice without affecting other devices).24.4 Types Of ExceptionsExceptions can be grouped into seven key types:Device interruptsArithmetic exceptionsIllegal memory referencesI/O errors (bus errors)Protection faultsInvalid instructionsHardware failuresSec. 24.4        Types Of Exceptions 605Earlier chapters examine device interrupts in detail, and point out that a misconfig-ured device can generate an interrupt with an invalid IRQ. Arithmetic exceptions in-clude attempts to divide by zero, and floating point overflow/underflow. On hardwarein which the memory system is separate from other I/O, the hardware will raise amemory exception if software references an address that does not correspond to physi-cal memory. On RISC computers where memory references must be aligned, a memory error can result if software attempts to fetch or store an integer from an address that is not a multiple of the word size. Some hardware does not distinguish between illegal memory references and I/O errors — a single exception type (bus error) is used for both. I/O errors do not always mean that device hardware has malfunctioned. It is pos-sible for an I/O error to occur if a device driver passes an invalid address to a device. For example, if DMA hardware is using a descriptor ring in memory and the ring con-tains an invalid pointer, the DMA hardware will cause an error by attempting to use the pointer.Protection faults occur when software attempts to perform an operation that is not permitted at the current level of protection. For example, the hardware raises a protec-tion fault if an application attempts to execute an instruction that requires operating sys-tem privilege.Invalid instructions are rare because most code is generated by a compiler. How-ever, if an error causes a program to branch to an arbitrary location in memory, the lo-cation may not contain an instruction. Therefore, programmers must be especially care-ful when writing code, such as the device-independent I/O functions, that uses indirect function calls.With current technology, hardware failures are also rare. Solid-state electronics has made hardware extremely reliable. However, battery-powered devices introduce a specific failure mode because a battery can lose voltage gradually as the charge is drained, and hardware can misbehave if the voltage slips below a minimum threshold.24.5 Handling ExceptionsWhen an unexpected interrupt occurs, the solution is straightforward: ignore the in-terrupt (or if a new device has been added, reconfigure the system to include the de-vice). Exception processing is more complex, and depends on the size and purpose of the system as well as the source of the exception. In particular, operating systems mustbe correct and reliable. Therefore, if operating system code causes an exception, the problem is serious, and may warrant stopping the system.When application code causes an exception, the problem is less serious and is as-sumed to be local to the application. Two general approaches have been used to handle application exceptions: termination and notification. Termination means the process that caused the exception is killed. Notification means the operating system calls an ex-ception handler associated with the application process. That is, when it begins execu-tion, an application informs the operating system of a function to call for exceptions that it wishes to catch. When an exception occurs, the operating checks the stored in-606 Exception Handling Chap. 24formation to see whether the process registered an exception handler for the exception.If so, the operating system calls the exception handler, and then allows the process to continue. Some programming languages have a way to declare exception handlers.For an embedded system, recovery from an exception is usually difficult or impos-sible. Even if the system allows interaction with a user, the user can do little to correctthe problem. Thus, many embedded systems either reboot or power down when an ex-ception occurs.24.6 Exception Vector InitializationWe said that although some exceptions are maskable, many are not. The hardware uses the exception to choose an entry in the vector, and assumes the entry contains the address of a handler. Therefore, an operating system designer must be careful to ensure that no exceptions can occur until the system fills in the exception vector.Arranging an operating system to associate exceptions with the appropriate handler, filling in vectors, and building dispatch code that invokes a handler are tedious tasks that plague implementers. The mismatch between low-level hardware and high-level operating system abstractions makes it difficult to map exceptions onto the code that caused the exception. For example, suppose a device using DMA is following pointers on a descriptor ring in memory, and encounters an invalid pointer. The hardware raises an exception, but the exception has nothing to do with the application that is currently executing. Thus, it may be difficult for an operating system designer to identify the correct source of a problem.24.7 Panic In The Face Of Catastrophic ProblemsOur example code follows the Unix tradition, and uses the name panic for the function that handles catastrophic problems.  Panic is only invoked in situations where processing cannot continue. The idea is straightforward: panic takes a string as an argu-ment, displays the string on the console, and then halts the processor. The code is minimal: panic does not attempt to recover, nor does it attempt to identify the offending process.Because many hardware-specific details are involved, a version of panic that displays registers or processor state may need to be written in assembly language. For example, an exception can occur because a stack pointer is invalid, and a panic function may need to avoid using the stack. Consequently, to work under all circumstances, panic code cannot merely attempt to push a value on the stack or execute a function call. Similarly, because entries in the device switch table may be incorrect, a panic function that extracts information about the CONSOLE device from the device switch table may not work. Fortunately, most of these cases are extreme. Therefore, many operating system designers start with a basic version of the panic function that works as long as the bulk of the operating system and runtime environment remain intact.Sec. 24.8        Implementation Of Panic 60724.8 Implementation Of PanicOur version of a panic function is simplistic. Because interrupt processing may have caused the exception, panic begins by disabling further interrupts, and then uses polled I/O to display the message on the console (i.e., it uses kprintf). To stop the pro-cessor, the code merely enters a tight loop; the exercises suggest alternatives.File panic.c contains the code://**ppaanniicc..cc--ppaanniicc**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**ppaanniicc--DDiissppllaayyaammeessssaaggeeaannddssttooppaallllpprroocceessssiinngg**------------------------------------------------------------------------------------------------------------------------------------------------**//vvooiiddppaanniicc((cchhaarr**mmssgg//**MMeessssaaggeettooddiissppllaayy**//)){{ddiissaabbllee(());;//**DDiissaabblleeiinntteerrrruuppttss**//kkpprriinnttff((""\\nn\\nn\\rrppaanniicc::%%ss\\nn\\nn"",,mmssgg));;wwhhiillee((TTRRUUEE)){{;;}}//**BBuussyyllooooppffoorreevveerr**//}}24.9 PerspectiveThe question of how to handle exceptions is more complex than it may seem. To see why, consider what happens after an application makes a system call: although it remains running, the application process executes operating system code. If an excep-tion occurs, the exception should be considered an operating system problem and should not invoke the exception handler for the process. Similarly, if an exception occurs while an application is executing code from a shared library, the exception should not be treated differently than an exception caused by the application. Such distinctions re-quire the operating system to keep track of exactly what an application is currently do-ing.Another type of complexity arises because exceptions can be caused by the interac-tion of processes. For example, if a Xinu process inadvertently writes into another process’s address space, the second process may experience an exception that the first process caused. Thus, even if the system provides a mechanism to catch exceptions, the exception handler for the second process may not anticipate the problem, and may have no way to recover.608 Exception Handling Chap. 2424.10 SummaryTrapping and identifying exceptions and unexpected interrupts are important be-cause they help isolate bugs that arise as an operating system is being implemented. Hence, building error detection functions early is essential, even if the implementation is crude and unsophisticated.In embedded systems, an exception usually causes the system to reboot or power down. Our example implementation of panic does not assume interrupts are working,and does not attempt to use operating system functions. Instead, the code disables inter-rupts, prints a message on the console, and enters a hard loop to stop further processing.EXERCISES24.1 Rewrite Xinu to make the code serially reusable, and modify panic to wait 15 secondsand then jump back to the starting location (i.e., reboot Xinu).24.2 How many locations does panic require on the runtime stack to process an exception?24.3 Design a mechanism that allows an executing process to catch exceptions.24.4  Some processors include a halt instruction that shuts down the processor. Find examplesystems that have such an instruction, and rewrite the code.24.5  Find a situation where an error can occur, but panic cannot be called. Hint: what hap-pens during a function call?Chapter Contents25.1 Introduction, 61125.2 The Need For Multiple Configurations, 61125.3 Configuration In Xinu, 61325.4 Contents Of The Xinu Configuration File, 61325.5 Computation Of Minor Device Numbers, 61625.6 Steps In Configuring A Xinu System, 61625.7 Perspective, 61725.8 Summary, 61725System Configuration
No pleasure endures unseasoned by variety.— Publilius Syrus25.1 IntroductionThis chapter concludes the discussion of basic operating system design by answer-ing a practical question: how can the code from earlier chapters be transformed to makeit suitable for a given computer that has a specific set of peripheral devices?The chapter discusses the motivation for configuration, tradeoffs between static and dynamic configuration, and presents a basic configuration program that takes a descrip-tion of the system and generates source files tailored to the description.25.2 The Need For Multiple ConfigurationsThe earliest computers were designed as monolithic systems, meaning that the hardware and software were designed together. A designer chose the details of the pro-cessor, memory, and I/O devices, and an operating system was built to control the specific hardware that had been selected. Later generations of computers added options, allowing a customer to choose between a large or small memory and a large or small disk. As the industry matured, third-party vendors began selling peripheral devices that could be attached to a computer. Current computer users have many possibilities — an owner can purchase hardware devices from a variety of vendors. Thus, a given comput-er can have a combination of hardware devices unlike other computers.611612 System Configuration Chap. 25Two broad approaches have been used to configure operating system software:Static configurationDynamic configurationStatic configuration.Static configuration is appropriate for small, “self-contained”systems, where the hardware does not change. A designer chooses the hardware, in-cluding processor, memory, and a set of peripheral devices. Once the hardware has been specified, an operating system is created that supports exactly the hardware that has been chosen, without any extra software modules. In practice, one does not create a new operating system for each hardware design. Instead, a general-purpose operating system is used, and a subset of the system modules are selected. Usually, the hardware specification becomes input to a configuration program that manages operating system source code. The configuration program uses the hardware specification to select the modules that are needed for the target hardware, and excludes other modules. When the resulting code has been compiled and linked, we say it has been configured for the hardware.Dynamic configuration. The alternative to static configuration is dynamic config-uration in which parts of the operating system can be changed while the system exe-cutes. Dynamic configuration is only appropriate for systems that have large memories and secondary storage. A basic operating system starts running without an exact knowledge of the hardware. The system probes the hardware, determines which devices are present, and loads pieces of the system for the hardware. Of course, the pieces of operating system software must be available on a local disk or downloaded (e.g., over the Internet).Static configuration is a form of early binding. The chief advantage is that the memory image only contains modules for the hardware that exists. Static configurationis ideal for the smallest embedded systems where memory is limited and no secondary storage is available. Another advantage arises because the system does not spend time identifying hardware during the bootstrap process; the information is bound into the code when the operating system image is created. Thus, a system can boot instantly. The chief disadvantage of early configuration is that a system configured for one machine cannot run on another unless the two are identical, including details such as the size of memory and all the devices.Deferring configuration until system startup allows the designer to build more robust code because a single system can operate on several hardware configurations. During startup, the system can adapt itself to the exact hardware on which it executes. In particular, dynamic configuration handles an arbitrary set of peripheral devices built by an arbitrary set of vendors. For example, a single operating system image can be used independent of the disk, printer, network interface, and video screen used on the computer. Dynamic reconfiguration also allows a system to adapt to changes in the hardware without stopping (e.g., when a user attaches or detaches a USB device).Sec. 25.3        Configuration In Xinu 61325.3 Configuration In XinuBecause it runs as an embedded system, Xinu follows a static configuration ap-proach, with the majority of configuration occurring when the system is compiled and linked. Of course, even in some embedded systems, part of the configuration must be postponed until system startup. For example, some versions of Xinu calculate the size of memory during system initialization. Others use dynamic configuration to detect the presence of a real-time clock. As we have seen, some bus hardware chooses IRQs and device addresses when the bus is powered on. On such hardware, Xinu must wait until it runs to find the interrupt vector addresses and device CSR addresses.To help manage configuration and to automate the selection of device driver modules, Xinu uses a separate configuration program. Named config, the program isnot part of the operating system, and we do not need to examine the source code. In-stead, we will look at how config operates: it takes an input file that contains specifica-tions, and produces output files that become part of the operating system code. The next sections explain the configuration program and show examples.25.4 Contents Of The Xinu Configuration FileThe config program takes as input a text file named Configuration. It parses the input file, and generates two output files: conf.h and conf.c. We have already seen the output files, which contain defined constants for devices and a definition of the device switch table.†The Xinu configuration file is a text file, divided into three sections. The sections are separated by lines that contain two ampersand characters (%%). The three sections are:Section 1: Type declarations for device typesSection 2: Device specifications for specific devicesSection 3:  Symbolic constants25.4.1  Section 1: Type DeclarationsThe motivation for a type declaration arises because a system may contain more than one copy of a particular hardware device. For example, a system may contain two UART devices that both use the tty abstraction. In such cases, a set of functions that comprise a tty driver must be specified for each UART. Entering the specification many times manually is error-prone, and can lead to inconsistencies. Thus, the type section allows the specification to be entered once and assigned a name that is used with both devices in the device specification section.†File conf.h can be found on page 267, and conf.c can be found on page 279.614 System Configuration Chap. 25Each type declaration defines a name for the type, and lists a set of default device driver functions for the type. The declaration also allows one to specify the type of hardware with which the device is associated. For example, the type declaration:ttttyy::oonnuuaarrtt--iittttyyiinniitt--ooiioonnuullll--cciioonnuullll--rrttttyyrreeaadd--ggttttyyggeettcc--ppttttyyppuuttcc--wwttttyywwrriittee--ssiiooeerrrr--nnttttyyccoonnttrrooll--iinnttrrttttyyhhaannddlleerr--iirrqq88defines a type named tty that is used on a UART device. Neither tty nor uart is a key-word or has any meaning. Instead they are simply names that the designer chose. The remaining items specify the default driver functions for type tty. Each driver function is preceded by a keyword that begins with a minus sign. Figure 25.1 lists the possible keywords and gives their meaning. Note: a given specification does not need to use all keywords. In particular, because a CSR address is unique to a device, a type declara-tion does not usually include a csr keyword.Keyword Meaning-i function that performs init-o function that performs open-c function that performs close-r function that performs read-w function that performs write-s function that performs seek-g function that performs getc-p function that performs putc-n function that performs control-intr function that handles interrupts-csr control and status register address-irq interrupt vector numberFigure 25.1  Keywords used in the Xinu configuration file and their meaning.25.4.2  Section 2: Device SpecificationsSection 2 of file Configuration contains a declaration for each device in the sys-tem. A declaration gives a name for the device (e.g., CONSOLE), and specifies the setof functions that constitutes a driver. Note that in Xinu, a device is an abstract concept, not necessarily tied to a physical hardware device. For example, in addition to devices like CONSOLE and ETHERNET that each correspond to underlying hardware, the de-vice section can list pseudo-devices, such as a FILE device used for I/O.Sec. 25.4        Contents Of The Xinu Configuration File 615Declaring a device serves two purposes. First, it allocates a slot in the deviceswitch table, allowing the high-level I/O primitives to be used with the device ratherthan requiring a programmer to call specific driver functions. Second, it allows configto assign each device a minor device number. All devices with the same type are as-signed minor numbers in sequence starting at zero.When a device is declared, specific values can be supplied as needed or driverfunctions can be overridden. For example, the declaration:CCOONNSSOOLLEEiissttttyyoonnuuaarrtt--ccssrr00xxBB88002200000000declares CONSOLE to be a device of type tty that runs on UART hardware. In addi-tion, the declaration specifies a CSR address of 0xB8020000.If a programmer needed to test a new version of ttygetc, the programmer mightchange the specification to:CCOONNSSOOLLEEiissttttyyoonnuuaarrtt--ccssrr00xxBB88002200000000--ggmmyyttttyyggeettccwhich uses the default driver functions from the tty declaration given above, but over-rides the getc function to use myttygetc. Note that having a configuration makes it easy to change one function without modifying or replacing the original file.The example type declaration includes the phrase on uart. To understand the pur-pose of specifying the underlying hardware, observe that designers sometimes wish touse the same abstraction for multiple pieces of hardware. For example, suppose a sys-tem contains two types of UART hardware. The on keyword allows a designer to usethe tty abstraction for hardware types, and to allocate a single array of control blockseven though some of the low-level hardware details differ and the set of driver func-tions used for one type of hardware differs from the set used for another.25.4.3  Symbolic ConstantsIn addition to defining the structure of the device switch table, conf.h contains con-stants that specify the total number of devices and the number of each type. The config program generates such constants to reflect the specification found in file Configuration. For example, constant NDEVS is defined to be an integer that tells the total number of devices that have been configured. The device switch table contains NDEVS devices, and device-independent I/O routines use NDEVS to test whether a device id corresponds to a valid device.Config also generates a set of defined constants that specify the number of devices of each type. Driver functions can use the appropriate constant to declare the array of control blocks. Each constant has the form Nxxx, where xxx is the type name. For ex-ample, if file Configuration defines two devices of type tty, conf.h will contain the fol-lowing line:##ddeeffiinneeNNttttyy22616 System Configuration Chap. 2525.5 Computation Of Minor Device NumbersConsider the files that config produces. File conf.h contains the declaration of the device switch table, and conf.c contains the code that initializes the table. For a given device, its devtab entry contains a set of pointers to the device driver routines that correspond to high-level I/O operations like open, close, read, and write. The entry also contains the interrupt vector address and the device’s CSR address (if the hardware allows the addresses to be known when the system is compiled). All information in the device switch table is derived from file Configuration in a straightforward manner.As mentioned above, each entry in the device switch table also contains a minor device number. Minor device numbers are nothing more than integers that distinguish among multiple devices that each use the same type of control block. Recall that device driver functions use the minor device number as an index into the array of control blocks to associate a specific entry with each device. In essence, the config program counts devices of each type. That is, each time it encounters a device, config uses the device type to assign the next minor device number (numbers start at zero). For exam-ple, Figure 25.2 shows how device IDs and minor numbers are assigned on a system that has three tty devices and two eth devices.device device device minorname identifier type numberCONSOLE 0 tty 0ETHERNET 1 eth 0SERIAL2 2 tty 1PRINTER 3 tty 2ETHERNET2 4 eth 1Figure 25.2  An example of device configuration.Notice that the three tty lines have minor numbers zero, one, and two, even thoughtheir device IDs happen to be zero, two, and three.25.6 Steps In Configuring A Xinu SystemTo configure a Xinu system, the programmer edits file Configuration, adding or changing device information and symbolic constants as desired. When run, program config first reads and parses the file, collecting the information about each device type. It then reads device specifications, assigns minor device numbers, and produces the out-put files conf.c and conf.h. Finally, in addition to symbolic constants that are generatedSec. 25.6        Steps In Configuring A Xinu System 617automatically, config appends definitions of symbolic constants from the third section of the specifications onto conf.h, making them available for operating system functions to include.After config produces a new version of conf.c and conf.h, conf.c must be recom-piled, as must all system functions that include conf.h.25.7 PerspectiveThe history of operating systems is one of moving from static configuration to dynamic configuration. The interesting question is whether the benefits of dynamic configuration outweigh the costs. For example, compare the time required to boot Xinu to the time required to boot a large production system, such as Windows or Linux. Although the underlying computer hardware does not usually change, a production sys-tem may need to go through the steps of polling the bus to find the devices that are present, loading drivers, and interacting with each deviceSome systems, especially those used on laptops, offer a sleep mode (sometimes called hibernation mode) that allows rapid restart. Instead of completely poweringdown the system, sleep mode saves processor state (e.g., by saving the running memory image and hardware registers on disk). Then, when a user restarts the machine, the machine state is restored from disk. Only a few checks must be made before the system can resume running. For example, if a laptop was connected to a wireless network be-fore being put into sleep mode, the user could have moved to a new location where the network is no longer available. Therefore, the operating system must check network connections after the system resumes.25.8 SummaryInstead of building a monolithic operating system tailored to specific hardware, designers look for ways to make systems configurable. Static configuration, a form of early binding, selects modules when the system is compiled and linked. The alternative, dynamic configuration, loads modules, such as device drivers, at runtime.Because it is designed for an embedded environment, Xinu uses static config-uration. Program config reads file Configuration, and produces files conf.h and conf.cthat define and initialize the device switch table. The separation of device types from device declarations allows config to compute minor device numbers.618 System Configuration Chap. 25EXERCISES25.1  Create a function myttyread that calls ttygetc repeatedly to satisfy a request. To test yourcode, modify file Configuration to substitute your code in place of ttyread.25.2  Find out how other systems are configured. What happens, for example, when Windowsboots?25.3  If every operating system function includes conf.h, any change to file Configurationmeans a new version of conf.h will be generated, and the entire system must be recom-piled. Redesign the config program to separate constants into several different include files to eliminate unnecessary recompilation.25.4  Discuss whether a configuration program is worthwhile. Include some estimate of theextra effort required to make a system easily configurable. Remember that a program-mer is likely to have little experience or knowledge about a system when it is first con-figured.25.5 In theory, many aspects of a system may need to change when porting the system fromone computer to another. In addition to devices, for example, one might consider the processor (not only the basic instruction set, but the extra instructions found on some models), the availability of co-processors (including floating point), the real-time clock or time resolution, and the endianness of integers. Argue that if a configuration system has parameters for all the above, the resulting system is untestable.25.6 Measure the time a production system takes to boot and the time the same system takesto resume after hibernation. What is the percentage difference?25.7 In the previous exercise, does the time to resume change if the system is moved and itsnetwork is no longer available?25.8 Repeat the measurement of booting vs. resuming after hibernation for a system that hasthree USB devices plugged in before hibernation and none when the system resumes.Also repeat the experiment for the case where the system has no USB devices before hibernation, but three devices are plugged in during hibernation.Chapter Contents26.1 Introduction, 62126.2 What Is A User Interface?, 62226.3 Commands And Design Principles, 62226.4 Design Decisions For A Simplified Shell, 62326.5 Shell Organization And Operation, 62326.6 The Definition Of Lexical Tokens, 62426.7 The Definition Of Command-Line Syntax, 62526.8 Implementation Of The Xinu Shell, 62526.9 Storage Of Tokens, 62826.10 Code For The Lexical Analyzer, 62926.11 The Heart Of The Command Interpreter, 63326.12 Command Name Lookup And Builtin Processing, 641 26.13 Arguments Passed To Commands, 64126.14 Passing Arguments To A Non-builtin Command, 643 26.15 I/O Redirection, 64626.16 An Example Command Function (sleep), 647 26.17 Perspective, 64926.18 Summary, 65026An Example User Interface: The Xinu Shell
A man has to learn that he cannot command things...— James Allen26.1 IntroductionPrevious chapters explain an operating system as a set of functions that applica-tions can invoke to obtain services. However, a typical user never encounters system functions. Instead, users invoke applications, and allow the applications to access func-tions in the underlying system.This chapter examines a basic interface known as a shell† that allows a user tolaunch applications and control their input and output. Following the pattern estab-lished by other parts of the system, our design emphasizes simplicity and elegance rath-er than features. We concentrate on a few fundamental ideas that make the shell power-ful without requiring large amounts of code. The chapter shows examples of both software that interprets user commands and applications that a user can invoke. Although it only offers basic functionality, our example interpreter illustrates several important concepts.
†The term shell and many of the ideas used in the Xinu shell come from Unix.621622 An Example User Interface: The Xinu Shell Chap. 2626.2 What Is A User Interface?A user interface consists of the hardware and software with which users interact to perform computational tasks and observe the results. Thus, user interface software lies between a human who specifies what must be done and a computer system that per-forms the specified tasks.The goal of user interface design is to create an environment in which users can perform computational tasks conveniently and productively. For example, most modern user interfaces employ a graphical representation that presents a set of icons from which the user selects to launch an application. The use of graphics makes application selec-tion quick, and relieves the user from memorizing a set of application names.Small embedded systems typically offer two levels of interface: one for a system builder and another for the end user. For example, a desktop system provides a graphi-cal interface through which an end user launches applications and interacts with the de-vice. To write new software, directly access the file system, or enter text commands, however, a programmer invokes a lower-level interface that is sometimes called a Ter-minal.26.3 Commands And Design PrinciplesIndustry uses the term Command Line Interface (CLI) to describe an interface that allows a user to enter a series of textual commands; many embedded system products offer a CLI. Usually, each line of input corresponds to a command, and the system processes a line before reading the next line. The term command arises because most CLIs follow the same syntactic form in which a line starts with a name that specifies an action to be taken and is followed by parameters that control the details of the action and the item(s) to which the action applies. For example, we can imagine a system that uses a command named config to control settings associated with a network interface. To minimize keystrokes, a CLI may use short, cryptic abbreviations. The command to set the MTU parameter of interface number 0 to 1500 might be:config 0 MTU=1500The set of all available commands determines the functionality available to a user (i.e., defines the power of the computing system). However, a good design does not merely collect random commands. Instead, the design adheres to the following princi-ples:Functionality: sufficient for all needsOrthogonality: only one way to perform a given taskConsistency: commands follow a consistent patternLeast astonishment: a user should be able to predict resultsSec. 26.4        Design Decisions For A Simplified Shell 62326.4 Design Decisions For A Simplified ShellWhen they design a CLI and the shell program that processes commands, program-mers must choose among many alternatives. The following paragraphs list decisions a programmer faces, and describe the choices made for a simplified Xinu shell.Handling input. Should our interface allow the terminal device driver to handle the details of backspacing, character echoing, and line erasing, or should it handle those details itself? The choice is important because it determines the extent to which the shell can control input. For example, a modern Unix shell allows Control-B and Control-F characters to move the cursor backward and forward while editing a line of input, while our tty driver does not.† Our choice is to use the tty driver, which simpli-fies the design and reduces the amount of code. An exercise suggests changing the design to have the shell, rather than the tty driver, interpret all input characters.Foreground or background execution. Does the shell wait while a command com-pletes execution before starting another? Our shell follows the Unix tradition of allow-ing a user to decide whether the shell waits or the command executes in foreground or background.Redirection of input and output. Also like Unix, our example shell allows a userto specify a source of input and destination for output when the command is invoked.The technique, known as I/O redirection, allows each command to function as ageneral-purpose tool that can be applied to a variety of files and I/O devices. Providing redirection in the shell also means that I/O specifications are uniform — a single mech-anism for redirection applies to all commands.Typed or untyped arguments. Should a shell check the number and type of argu-ments for a given command, or should each command handle arguments? Following the Unix tradition, our example shell does not check the number of arguments, nor doesit interpret argument values. Instead, the shell treats each argument as a text string, and the set of arguments is passed to the command. Consequently, each command must check whether its arguments are valid.26.5 Shell Organization And OperationA shell is organized as a loop that repeatedly reads a line of input and executes the command on the line. Once a line has been read, the shell must extract a commandname, arguments, and other items, such as the specifications of I/O redirection or back-ground processing. Following standard practice for syntactic analysis, we have divided the code into two separate functions: one function handles lexical analysis by grouping characters into tokens, and the other function examines whether the set of tokens forms a valid command.Using a separate lexical function may seem unnecessary for the trivial syntax ofour sample shell. It is tempting to take short cuts for a small task. However, we chosethe organization because it permits future expansion.†The use of Control-B and Control-F is derived from the Emacs editor.624 An Example User Interface: The Xinu Shell Chap. 2626.6 The Definition Of Lexical TokensAt the lexical level, our shell scans a line of input and groups characters into syn-tactic tokens. Figure 26.1 lists the lexical tokens that the scanner recognizes and thefour lexical types the scanner uses when classifying tokens.Symbolic Name Numeric Input Description(Token Type) Value CharactersSH_TOK_AMPER 0 & ampersandSH_TOK_LESS 1 < less-than symbolSH_TOK_GREATER 2 > greater-than symbolSH_TOK_OTHER 3 ’...’ quoted string (single quotes)SH_TOK_OTHER 3 "..." quoted string (double-quotes) SH_TOK_OTHER  3 other sequence of non-whitespaceFigure 26.1  Lexical tokens used by the example Xinu shell.As with most command line processors, our shell strives to be flexible. Characters such as a “less than” (i.e., <) are assigned special meaning. The shell includes quoted strings as lexical tokens to permit a user to include special characters in arguments. The rule is that a quoted string can contain arbitrary characters, including the special characters recognized by the shell. Rather than incorporate complex rules for escaping characters in a string, the Xinu shell uses two forms. A quoted string starts with either a single or double quote, and contains all characters, including blanks, tabs, and special characters up to the first occurrence of the opening quote. Thus, the string:’’aassttrriinngg’’contains eight total characters including a blank. More important, because two quotesare recognized, a string can be created that includes one of the quote characters. For example, the string:""ddoonn’’ttbblliinnkk""contains eleven characters, including a single quote. The lexical scanner removes the surrounding quotes, and classifies the resulting sequence of characters to be a single to-ken of type SH_TOK_OTHER.The lexical scanner defines whitespace to consist of blanks or tab characters. At least one whitespace character must separate two tokens of type SH_TOK_OTHER. Otherwise, whitespace is ignored.Sec. 26.7        The Definition Of Command-Line Syntax 62526.7 The Definition Of Command-Line SyntaxOnce a line has been scanned and divided into a series of lexical tokens, the shellparses the tokens to verify that they form a valid sequence. The syntax is:command_name args* [ redirection ] [ background ]Brackets [ ] denote an optional occurrence and asterisk indicates zero or more repetitions of an item. The string command_name denotes the name of a command, args* denotes zero or more optional arguments, the optional redirection refers to input redirection, output redirection, or both, and the optional background indicates background execu-tion. Figure 26.2 contains a grammar that defines the set of valid inputs in terms of to-kens.command qname [args] [redirection] [background]name qSH_TOK_OTHERargs qSH_TOK_OTHER [args]redirection    qinput_redirect [output_redirect] redirection qoutput_redirect [input_redirect]input_redirect qSH_TOK_LESS SH_TOK_OTHERoutput_redirect  qSH_TOK_GREATER SH_TOK_OTHER background qSH_TOK_AMPERFigure 26.2A grammar that specifies valid sequences of tokens for the ex-ample shell.In essence, a command consists of a sequence of one or more “other” tokens op-tionally followed by requests to redirect the input and/or output (in either order), option-ally followed by a specification that the command should run in background. The first token on the line must be the name of a command.26.8 Implementation Of The Xinu ShellOur examination of the implementation begins with the definition of constants andvariables used by the shell. File shell.h contains the declarations.626 An Example User Interface: The Xinu Shell Chap. 26//**sshheellll..hh--DDeeccllaarraattiioonnssaannddccoonnssttaannttssuusseeddbbyytthheeXXiinnuusshheellll**////**SSiizzeeccoonnssttaannttss**//##ddeeffiinneeSSHHEELLLL__BBUUFFLLEENNTTYY__IIBBUUFFLLEENN++11//**LLeennggtthhooffiinnppuuttbbuuffffeerr**//##ddeeffiinneeSSHHEELLLL__MMAAXXTTOOKK3322//**MMaaxxiimmuummttookkeennssppeerrlliinnee**//##ddeeffiinneeSSHHEELLLL__CCMMDDSSTTKK88119922//**SSiizzeeooffssttaacckkffoorrpprroocceessss**////**tthhaatteexxeeccuutteessccoommmmaanndd**//##ddeeffiinneeSSHHEELLLL__AARRGGLLEENN((SSHHEELLLL__BBUUFFLLEENN++SSHHEELLLL__MMAAXXTTOOKK))//**AArrgguummeennttaarreeaa**//##ddeeffiinneeSSHHEELLLL__CCMMDDPPRRIIOO2200//**PPrroocceesssspprriioorriittyyffoorrccoommmmaanndd**////**MMeessssaaggeeccoonnssttaannttss**////**SShheellllbbaannnneerr((aassssuummeessVVTT110000))**//##ddeeffiinneeSSHHEELLLL__BBAANN00""\\003333[[11;;3311mm""##ddeeffiinneeSSHHEELLLL__BBAANN11""------------------------------------------------------------------------------------""##ddeeffiinneeSSHHEELLLL__BBAANN22""__________________________""##ddeeffiinneeSSHHEELLLL__BBAANN33""\\\\\\\\////||________||||\\\\||||||||||||""##ddeeffiinneeSSHHEELLLL__BBAANN44""\\\\\\\\////||||||\\\\||||||||||||""##ddeeffiinneeSSHHEELLLL__BBAANN55""////\\\\\\\\__||||__||\\\\||||||||||""##ddeeffiinneeSSHHEELLLL__BBAANN66""////\\\\\\\\||||||||\\\\||\\\\----//""##ddeeffiinneeSSHHEELLLL__BBAANN77""------------------------------""##ddeeffiinneeSSHHEELLLL__BBAANN88""------------------------------------------------------------------------------------""##ddeeffiinneeSSHHEELLLL__BBAANN99""\\003333[[00;;3399mm\\nn""//**MMeessssaaggeesssshheellllddiissppllaayyssffoorruusseerr**//##ddeeffiinneeSSHHEELLLL__PPRROOMMPPTT""xxsshh$$""//**CCoommmmaannddpprroommpptt**//##ddeeffiinneeSSHHEELLLL__SSTTRRTTMMSSGG""WWeellccoommeettooXXiinnuu!!\\nn""//**WWeellccoommeemmeessssaaggee**//##ddeeffiinneeSSHHEELLLL__EEXXIITTMMSSGG""SShheellllcclloosseedd\\nn""//**SShheelllleexxiittmmeessssaaggee**//##ddeeffiinneeSSHHEELLLL__SSYYNNEERRRRMMSSGG""SSyynnttaaxxeerrrroorr\\nn""//**SSyynnttaaxxeerrrroorrmmeessssaaggee**//##ddeeffiinneeSSHHEELLLL__CCRREEAATTMMSSGG""CCaannnnoottccrreeaatteepprroocceessss\\nn""//**ccoommmmaannddeerrrroorr**//##ddeeffiinneeSSHHEELLLL__IINNEERRRRMMSSGG""CCaannnnoottooppeennffiillee%%ssffoorriinnppuutt\\nn""//**IInnppuutteerrrr**//##ddeeffiinneeSSHHEELLLL__OOUUTTEERRRRMMSSGG""CCaannnnoottooppeennffiillee%%ssffoorroouuttppuutt\\nn""//**OOuuttppuutteerrrr**////**BBuuiillttiinnccmmddeerrrroorrmmeessssaaggee**//##ddeeffiinneeSSHHEELLLL__BBGGEERRRRMMSSGG""CCaannnnoottrreeddiirreeccttII//OOoorrbbaacckkggrroouunnddaabbuuiillttiinn\\nn""//**CCoonnssttaannttssuusseeddffoorrlleexxiiccaallaannaallyyssiiss**//##ddeeffiinneeSSHH__NNEEWWLLIINNEE’’\\nn’’//**NNeewwlliinneecchhaarraacctteerr**//##ddeeffiinneeSSHH__EEOOFF’’\\0044’’//**CCoonnttrrooll--DDiissEEOOFF**//##ddeeffiinneeSSHH__AAMMPPEERR’’&&’’//**AAmmppeerrssaannddcchhaarraacctteerr**//##ddeeffiinneeSSHH__BBLLAANNKK’’’’//**BBllaannkkcchhaarraacctteerr**//##ddeeffiinneeSSHH__TTAABB’’\\tt’’//**TTaabbcchhaarraacctteerr**//Sec. 26.8        Implementation Of The Xinu Shell 627##ddeeffiinneeSSHH__SSQQUUOOTTEE’’\\’’’’//**SSiinngglleeqquuootteecchhaarraacctteerr**//##ddeeffiinneeSSHH__DDQQUUOOTTEE’’""’’//**DDoouubblleeqquuootteecchhaarraacctteerr**//##ddeeffiinneeSSHH__LLEESSSS’’<<’’//**LLeessss--tthhaanncchhaarraacctteerr**//##ddeeffiinneeSSHH__GGRREEAATTEERR’’>>’’//**GGrreeaatteerr--tthhaanncchhaarraacctteerr**////**TTookkeennttyyppeess**//##ddeeffiinneeSSHH__TTOOKK__AAMMPPEERR00//**AAmmppeerrssaannddttookkeenn**//##ddeeffiinneeSSHH__TTOOKK__LLEESSSS11//**LLeessss--tthhaannttookkeenn**//##ddeeffiinneeSSHH__TTOOKK__GGRREEAATTEERR22//**GGrreeaatteerr--tthhaannttookkeenn**//##ddeeffiinneeSSHH__TTOOKK__OOTTHHEERR33//**TTookkeennootthheerrtthhaanntthhoossee**////**lliisstteeddaabboovvee((ee..gg..,,aann**////**aallpphhaannuummeerriiccssttrriinngg))**////**SShheellllrreettuurrnnccoonnssttaannttss**//##ddeeffiinneeSSHHEELLLL__OOKK00##ddeeffiinneeSSHHEELLLL__EERRRROORR11##ddeeffiinneeSSHHEELLLL__EEXXIITT--33//**SSttrruuccttuurreeooffaanneennttrryyiinntthheettaabblleeooffsshheellllccoommmmaannddss**//ssttrruuccttccmmddeenntt{{//**EEnnttrryyiinnccoommmmaannddttaabbllee**//cchhaarr**ccnnaammee;;//**NNaammeeooffccoommmmaanndd**//bbooooll88ccbbuuiillttiinn;;//**IIsstthhiissaabbuuiillttiinnccoommmmaanndd??**//iinntt3322((**ccffuunncc))((iinntt3322,,cchhaarr**[[]]));;//**FFuunnccttiioonnffoorrccoommmmaanndd**//}};;eexxtteerrnnuuiinntt3322nnccmmdd;;eexxtteerrnnccoonnssttssttrruuccttccmmddeennttccmmddttaabb[[]];;Unlike a Unix system, where commands reside in files, all Xinu shell commandsare linked into the image. The shell defines an array that lists the set of commands thatare available, the name of each command, and the function to execute for the command.The final section of file shell.h defines the table of commands, cmdtab. Each entry in the table is struct cmdent which contains three items: a name for the command, a Boolean indicating whether the command is restricted to run as a builtin, and a pointer to a function that implements the command. Later sections discuss how the command table is initialized and how it is used.628 An Example User Interface: The Xinu Shell Chap. 2626.9 Storage Of TokensThe data structures that our shell uses are somewhat unexpected. An integer array, toktyp, is used to record the numeric value of the type for each token. The tokens them-selves are stored as null-terminated strings. To conserve space, tokens are packed into contiguous locations of a character array, tokbuf. An integer array, tok, is used to store the index of the start of each token. The shell depends on two counters: ntok counts the number of tokens found so far, and variable tlen counts the characters that have been stored in array tokbuf. To understand the data structures, consider the example input line:date > file &The line contains four tokens. Figure 26.3 shows how the lexical analyzer fills in thedata structures to hold the tokens that have been extracted from the input line.toktyptok
d0ate+>5+f7ile+&12+05712tokbuf3230
tlen = 14ntok = 4
Figure 26.3Contents of variables tokbuf, toktyp, tok, ntok, and tlen for theinput line: date > file &As the figure shows, the tokens themselves are placed in array tokbuf with all whitespace removed. A null character terminates each token. Array tok contains in-tegers that are each an index into tokbuf — the ithlocation of array tok gives the indexin tokbuf of the string for the ithtoken. Finally, the ithlocation of array toktyp specifiesthe type of the ithtoken. For example, the second token on the line, >, has numerictype 2 (SH_TOK_LESS†), and starts at location 5 in array tokbuf. The third token onthe line, file, has numeric type 3 (SH_TOK_OTHER), and starts at location 7 in array tokbuf.†Figure 26.1 on page 624 lists the numeric values for each token type.Sec. 26.10        Code For The Lexical Analyzer 62926.10 Code For The Lexical AnalyzerBecause our shell syntax is straightforward, we have chosen to use an ad hoc, top-down implementation for the lexical analyzer. File lexan.c contains the code.//**lleexxaann..cc--lleexxaann**//##iinncclluuddee<<xxiinnuu..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**lleexxaann--AAddhhoocclleexxiiccaallaannaallyyzzeerrttooddiivviiddeeccoommmmaannddlliinneeiinnttoottookkeennss**------------------------------------------------------------------------------------------------------------------------------------------------**//iinntt3322lleexxaann((cchhaarr**lliinnee,,//**IInnppuuttlliinneetteerrmmiinnaatteeddwwiitthh**////**NNEEWWLLIINNEEoorrNNUULLLLCCHH**//iinntt3322lleenn,,//**LLeennggtthhoofftthheeiinnppuuttlliinnee,,**////**iinncclluuddiinnggNNEEWWLLIINNEE**//cchhaarr**ttookkbbuuff,,//**BBuuffffeerriinnttoowwhhiicchhttookkeennssaarree**////**ssttoorreeddwwiitthhaannuullll**////**ffoolllloowwiinnggeeaacchhttookkeenn**//iinntt3322**ttlleenn,,//**PPllaacceettoossttoorreennuummbbeerrooff**////**cchhaarrssiinnttookkbbuuff**//iinntt3322ttookk[[]],,//**AArrrraayyooffppooiinntteerrssttootthhee**////**ssttaarrttooffeeaacchhttookkeenn**//iinntt3322ttookkttyypp[[]]//**AArrrraayytthhaattggiivveesstthheettyyppee**////**ooffeeaacchhttookkeenn**//)){{cchhaarrqquuoottee;;//**CChhaarraacctteerrffoorrqquuootteeddssttrriinngg**//uuiinntt3322nnttookk;;//**NNuummbbeerrooffttookkeennssffoouunndd**//cchhaarr**pp;;//**PPooiinntteerrtthhaattwwaallkkssaalloonnggtthhee**////**iinnppuuttlliinnee**//iinntt3322ttbbiinnddeexx;;//**IInnddeexxiinnttoottookkbbuuff**//cchhaarrcchh;;//**NNeexxttcchhaarrffrroommiinnppuuttlliinnee**////**SSttaarrttaatttthheebbeeggiinnnniinnggoofftthheelliinneewwiitthhnnoottookkeennss**//nnttookk==00;;pp==lliinnee;;ttbbiinnddeexx==00;;//**WWhhiilleennoottyyeettaatteennddoofflliinnee,,ggeettnneexxttttookkeenn**//630 An Example User Interface: The Xinu Shell Chap. 26wwhhiillee((((**pp!!==NNUULLLLCCHH))&&&&((**pp!!==SSHH__NNEEWWLLIINNEE)))){{//**IIffttoooommaannyyttookkeennss,,rreettuurrnneerrrroorr**//iiff((nnttookk>>==SSHHEELLLL__MMAAXXTTOOKK)){{rreettuurrnnSSYYSSEERRRR;;}} //**SSkkiippwwhhiitteessppaacceebbeeffoorreettookkeenn**//wwhhiillee((((**pp====SSHH__BBLLAANNKK))||||((**pp====SSHH__TTAABB)))){{pp++++;;}} //**SSttooppppaarrssiinnggaatteennddoofflliinnee((oorreennddooffssttrriinngg))**//cchh==**pp;;iiff((((cchh====SSHH__NNEEWWLLIINNEE))||||((cchh====NNUULLLLCCHH)))){{**ttlleenn==ttbbiinnddeexx;;rreettuurrnnnnttookk;;}} //**SSeettnneexxtteennttrryyiinnttookkaarrrraayyttoobbeeaanniinnddeexxttootthhee**////**ccuurrrreennttllooccaattiioonniinntthheettookkeennbbuuffffeerr**//ttookk[[nnttookk]]==ttbbiinnddeexx;;//**tthheessttaarrttoofftthheettookkeenn**////**SSeetttthheettookkeennttyyppee**//sswwiittcchh((cchh)){{ccaasseeSSHH__AAMMPPEERR::ttookkttyypp[[nnttookk]]==SSHH__TTOOKK__AAMMPPEERR;;ttookkbbuuff[[ttbbiinnddeexx++++]]==cchh;;ttookkbbuuff[[ttbbiinnddeexx++++]]==NNUULLLLCCHH;;nnttookk++++;;pp++++;;ccoonnttiinnuuee;;ccaasseeSSHH__LLEESSSS::ttookkttyypp[[nnttookk]]==SSHH__TTOOKK__LLEESSSS;;ttookkbbuuff[[ttbbiinnddeexx++++]]==cchh;;ttookkbbuuff[[ttbbiinnddeexx++++]]==NNUULLLLCCHH;;nnttookk++++;;pp++++;;ccoonnttiinnuuee;;Sec. 26.10        Code For The Lexical Analyzer 631ccaasseeSSHH__GGRREEAATTEERR::ttookkttyypp[[nnttookk]]==SSHH__TTOOKK__GGRREEAATTEERR;;ttookkbbuuff[[ttbbiinnddeexx++++]]==cchh;;ttookkbbuuff[[ttbbiinnddeexx++++]]==NNUULLLLCCHH;;nnttookk++++;;pp++++;;ccoonnttiinnuuee;;ddeeffaauulltt::ttookkttyypp[[nnttookk]]==SSHH__TTOOKK__OOTTHHEERR;;}};;//**HHaannddlleeqquuootteeddssttrriinngg((ssiinngglleeoorrddoouubblleeqquuoottee))**//iiff((((cchh====SSHH__SSQQUUOOTTEE))||||((cchh====SSHH__DDQQUUOOTTEE)))){{qquuoottee==cchh;;//**rreemmeemmbbeerrooppeenniinnggqquuoottee**////**CCooppyyqquuootteeddssttrriinnggttooaarrggaarreeaa**//pp++++;;//**MMoovveeppaassttssttaarrttiinnggqquuoottee**//wwhhiillee((((((cchh==**pp++++))!!==qquuoottee))&&&&((cchh!!==SSHH__NNEEWWLLIINNEE))&&&&((cchh!!==NNUULLLLCCHH)))){{ttookkbbuuff[[ttbbiinnddeexx++++]]==cchh;;}} iiff((cchh!!==qquuoottee)){{//**ssttrriinnggmmiissssiinnggeennddqquuoottee**//rreettuurrnnSSYYSSEERRRR;;}} //**FFiinniisshheeddssttrriinngg--ccoouunnttttookkeennaannddggoooonn**//ttookkbbuuff[[ttbbiinnddeexx++++]]==NNUULLLLCCHH;;//**tteerrmmiinnaatteettookkeenn**//nnttookk++++;;//**ccoouunnttssttrriinnggaassoonneettookkeenn**//ccoonnttiinnuuee;;//**ggoottoonneexxttttookkeenn**//}} //**HHaannddlleeaattookkeennootthheerrtthhaannaaqquuootteeddssttrriinngg**//ttookkbbuuff[[ttbbiinnddeexx++++]]==cchh;;//**ppuuttffiirrssttcchhaarraacctteerriinnbbuuffffeerr**//pp++++;;wwhhiillee((((((cchh==**pp))!!==SSHH__NNEEWWLLIINNEE))&&&&((cchh!!==NNUULLLLCCHH))&&&&((cchh!!==SSHH__LLEESSSS))&&&&((cchh!!==SSHH__GGRREEAATTEERR))&&&&((cchh!!==SSHH__BBLLAANNKK))&&&&((cchh!!==SSHH__TTAABB))&&&&((cchh!!==SSHH__AAMMPPEERR))&&&&((cchh!!==SSHH__SSQQUUOOTTEE))&&&&((cchh!!==SSHH__DDQQUUOOTTEE)))){{632 An Example User Interface: The Xinu Shell Chap. 26ttookkbbuuff[[ttbbiinnddeexx++++]]==cchh;;pp++++;;}} //**RReeppoorrtteerrrroorriiffootthheerrttookkeenniissaappppeennddeedd**//iiff((((cchh====SSHH__SSQQUUOOTTEE))||||((cchh====SSHH__DDQQUUOOTTEE))||||((cchh====SSHH__LLEESSSS))||||((cchh====SSHH__GGRREEAATTEERR)))){{rreettuurrnnSSYYSSEERRRR;;}} ttookkbbuuff[[ttbbiinnddeexx++++]]==NNUULLLLCCHH;;//**tteerrmmiinnaatteetthheettookkeenn**//nnttookk++++;;//**ccoouunnttvvaalliiddttookkeenn**//}} **ttlleenn==ttbbiinnddeexx;;rreettuurrnnnnttookk;;}}The first two arguments of lexan give the address of an input line and the number of characters on the line. Succeeding arguments give pointers to the data structures that Figure 26.3 illustrates.  Lexan initializes the number of tokens found, a pointer to the in-put line, and an index into array tokbuf. It then enters a while loop that runs until pointer p reaches the end of the line.To process a token, lexan skips leading whitespace (i.e., blanks and tabs), stores the current index of tokbuf in array tok, and then uses a switch statement to choose the action appropriate for the next input character. For any of the single-character tokens (i.e., an ampersand, less-than symbol, or greater-than symbol), lexan records the token type in array toktyp, places the token followed by a null character in the tokbuf array, increments ntok, moves to the next character in the string, and continues the while loop, which will start to process the next input character.For a character that is not one of the three single-character tokens, lexan recordsthe token type as SH_TOK_OTHER and exits the switch statement. There are twocases: the token is a quoted string or the token consists of contiguous characters up tothe next special character or whitespace.  Lexan recognizes either a single-quote or a double-quote character; the string ends at the first occurrence of a matching quote or the end-of-line, whichever occurs first. If it encounters an end-of-line condition in a string, lexan returns SYSERR. Otherwise, it copies characters from the string to tokbuf un-changed and uninterpreted, which means that a string can contain arbitrary characters, including whitespace and the other quote mark character. Once the copy has been com-pleted, lexan appends a null character to define the end of the token. It then continues the outer while loop to look for the next token.Sec. 26.10        Code For The Lexical Analyzer 633The final section of code handles a token that is composed of contiguous characters other than the single token characters and quotes. The code loops until it encounters a special character or whitespace, placing characters in successive locations of tokbuf. Before moving on to the next token, the code checks for an error where two tokens oc-cur with no whitespace between them.Once lexan reaches the end of the input line, it returns a count of the number of to-kens found. If an error is detected during processing, lexan returns SYSERR to its call-er, making no attempt to recover or repair the problem. That is, the action to be taken when an error occurs is coded into lexan. The exercises discuss the choice of error han-dling and suggest alternatives.26.11 The Heart Of The Command InterpreterAlthough a command interpreter must handle many details, the basic algorithm is not difficult to understand. At the top level, the code consists of a loop that repeatedly reads a line of input, uses lexan to extract tokens, checks the syntax, arranges a way to pass arguments, redirects I/O if necessary, and runs a command in foreground or back-ground as specified. The loop terminates if a user enters the end-of-file character (control-d), or if a command returns a special exit code.As with the lexical analyzer, our interpreter implementation uses an ad hoc imple-mentation. That is, the code does not resemble a conventional compiler, nor does it contain independent code to verify that the sequence of tokens is valid. Instead, error checking is built into each step of processing. For example, after it has processed back-ground and I/O redirection, the shell verifies that remaining tokens are all of type SH_TOK_OTHER.Examining the code will make the approach clear. Function shell performs com-mand interpretation; file shell.c, shown below, contains the code. Note that the file also includes the declaration of array cmdtab which specifies the set of commands and the function used to implement each. In addition, the code sets external variable ncmd to the number of commands in the table.Conceptually, the set of commands is independent from the code that processes user input. Thus, it may make sense to divide shell.c into two files: one that specifies commands and another that contains code. In practice, however, the two have been combined because the example set of commands is so small that an additional file is un-necessary.634 An Example User Interface: The Xinu Shell Chap. 26//**sshheellll..cc--sshheellll**//##iinncclluuddee<<xxiinnuu..hh>>##iinncclluuddee<<ssttddiioo..hh>>##iinncclluuddee""sshhpprroottoottyyppeess..hh""//************************************************************************************************************************************************////**TTaabblleeooffXXiinnuusshheellllccoommmmaannddssaannddtthheeffuunnccttiioonnaassssoocciiaatteeddwwiitthheeaacchh**////************************************************************************************************************************************************//ccoonnssttssttrruuccttccmmddeennttccmmddttaabb[[]]=={{{{""aarrggeecchhoo"",,TTRRUUEE,,xxsshh__aarrggeecchhoo}},,{{""aarrpp"",,FFAALLSSEE,,xxsshh__aarrpp}},,{{""ccaatt"",,FFAALLSSEE,,xxsshh__ccaatt}},,{{""cclleeaarr"",,TTRRUUEE,,xxsshh__cclleeaarr}},,{{""ddaattee"",,FFAALLSSEE,,xxsshh__ddaattee}},,{{""ddeevvdduummpp"",,FFAALLSSEE,,xxsshh__ddeevvdduummpp}},,{{""eecchhoo"",,FFAALLSSEE,,xxsshh__eecchhoo}},,{{""eexxiitt"",,TTRRUUEE,,xxsshh__eexxiitt}},,{{""hheellpp"",,FFAALLSSEE,,xxsshh__hheellpp}},,{{""iippaaddddrr"",,FFAALLSSEE,,xxsshh__iippaaddddrr}},,{{""kkiillll"",,TTRRUUEE,,xxsshh__kkiillll}},,{{""mmeemmdduummpp"",,FFAALLSSEE,,xxsshh__mmeemmdduummpp}},,{{""mmeemmssttaatt"",,FFAALLSSEE,,xxsshh__mmeemmssttaatt}},,{{""ppiinngg"",,FFAALLSSEE,,xxsshh__ppiinngg}},,{{""ppss"",,FFAALLSSEE,,xxsshh__ppss}},,{{""sslleeeepp"",,FFAALLSSEE,,xxsshh__sslleeeepp}},,{{""uuddpp"",,FFAALLSSEE,,xxsshh__uuddppdduummpp}},,{{""uuddppeecchhoo"",,FFAALLSSEE,,xxsshh__uuddppeecchhoo}},,{{""uuddppeesseerrvveerr"",,FFAALLSSEE,,xxsshh__uuddppeesseerrvveerr}},,{{""uuppttiimmee"",,FFAALLSSEE,,xxsshh__uuppttiimmee}},,{{""??"",,FFAALLSSEE,,xxsshh__hheellpp}}}};;uuiinntt3322nnccmmdd==ssiizzeeooff((ccmmddttaabb))//ssiizzeeooff((ssttrruuccttccmmddeenntt));;//************************************************************************************************************************************************////**sshheellll--PPrroovviiddeeaanniinntteerraaccttiivveeuusseerriinntteerrffaacceetthhaatteexxeeccuutteess**////**ccoommmmaannddss..EEaacchhccoommmmaannddbbeeggiinnsswwiitthhaaccoommmmaannddnnaammee,,hhaass**////**aasseettooffooppttiioonnaallaarrgguummeennttss,,hhaassooppttiioonnaalliinnppuuttoorr**////**oouuttppuuttrreeddiirreeccttiioonn,,aannddaannooppttiioonnaallssppeecciiffiiccaattiioonnffoorr**////**bbaacckkggrroouunnddeexxeeccuuttiioonn((aammppeerrssaanndd))..TThheessyynnttaaxxiiss::**////** **////**ccoommmmaanndd__nnaammee[[aarrggss**]][[rreeddiirreeccttiioonn]][[&&]]**////** **//Sec. 26.11        The Heart Of The Command Interpreter 635//**RReeddiirreeccttiioonniisseeiitthheerroorrbbootthhooff::**////** **////**<<iinnppuutt__ffiillee**////**oorr**////**>>oouuttppuutt__ffiillee**////** **////************************************************************************************************************************************************//pprroocceesssssshheellll((ddiidd3322ddeevv//**IIDDooffttttyyddeevviicceeffrroommwwhhiicchh**//))//**ttooaacccceeppttccoommmmaannddss**//{{cchhaarrbbuuff[[SSHHEELLLL__BBUUFFLLEENN]];;//**IInnppuuttlliinnee((llaarrggeeeennoouugghhffoorr**////**oonneelliinneeffrroommaattttyyddeevviiccee**//iinntt3322lleenn;;//**LLeennggtthhoofflliinneerreeaadd**//cchhaarrttookkbbuuff[[SSHHEELLLL__BBUUFFLLEENN++//**BBuuffffeerrttoohhoollddaasseettooff**//SSHHEELLLL__MMAAXXTTOOKK]];;//**CCoonnttiigguuoouussnnuullll--tteerrmmiinnaatteedd**////**SSttrriinnggssooffttookkeennss**//iinntt3322ttlleenn;;//**CCuurrrreennttlleennggtthhooffaallllddaattaa**////**iinnaarrrraayyttookkbbuuff**//iinntt3322ttookk[[SSHHEELLLL__MMAAXXTTOOKK]];;//**IInnddeexxooffeeaacchhttookkeenniinn**////**aarrrraayyttookkbbuuff**//iinntt3322ttookkttyypp[[SSHHEELLLL__MMAAXXTTOOKK]];;//**TTyyppeeooffeeaacchhttookkeenniinnttookkbbuuff**//iinntt3322nnttookk;;//**NNuummbbeerrooffttookkeennssoonnlliinnee**//ppiidd3322cchhiilldd;;//**PPrroocceessssIIDDooffssppaawwnneeddcchhiilldd**//bbooooll88bbaacckkggnndd;;//**RRuunnccoommmmaannddiinnbbaacckkggrroouunndd??**//cchhaarr**oouuttnnaammee,,**iinnnnaammee;;//**PPooiinntteerrssttoossttrriinnggssffoorrffiillee**////**nnaammeesstthhaattffoollllooww>>aanndd<<**//ddiidd3322ssttddiinnppuutt,,ssttddoouuttppuutt;;//**DDeessccrriippttoorrssffoorrrreeddiirreecctteedd**////**iinnppuuttaannddoouuttppuutt**//iinntt3322ii;;//**IInnddeexxiinnttooaarrrraayyooffttookkeennss**//iinntt3322jj;;//**IInnddeexxiinnttooaarrrraayyooffccoommmmaannddss**//iinntt3322mmssgg;;//**MMeessssaaggeeffrroommrreecceeiivvee(())ffoorr**////**cchhiillddtteerrmmiinnaattiioonn**//iinntt3322ttmmppaarrgg;;//**AAddddrreessssoofftthhiissvvaarriissuusseedd**////**wwhheennffiirrssttccrreeaattiinnggcchhiilldd**////**pprroocceessss,,bbuuttiissrreeppllaacceedd**//cchhaarr**ssrrcc,,**ccmmpp;;//**PPooiinntteerrssuusseedddduurriinnggnnaammee**////**ccoommppaarriissoonn**//bbooooll88ddiiffff;;//**WWaassddiiffffeerreenncceeffoouunndddduurriinngg**////**ccoommppaarriissoonn**//cchhaarr**aarrggss[[SSHHEELLLL__MMAAXXTTOOKK]];;//**AArrgguummeennttvveeccttoorrppaasssseeddttoo**////**bbuuiillttiinnccoommmmaannddss**////**PPrriinnttsshheellllbbaannnneerraannddssttaarrttuuppmmeessssaaggee**//636 An Example User Interface: The Xinu Shell Chap. 26ffpprriinnttff((ddeevv,,""\\nn\\nn%%ss%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn%%ss\\nn"",,SSHHEELLLL__BBAANN00,,SSHHEELLLL__BBAANN11,,SSHHEELLLL__BBAANN22,,SSHHEELLLL__BBAANN33,,SSHHEELLLL__BBAANN44,,SSHHEELLLL__BBAANN55,,SSHHEELLLL__BBAANN66,,SSHHEELLLL__BBAANN77,,SSHHEELLLL__BBAANN88,,SSHHEELLLL__BBAANN99));;ffpprriinnttff((ddeevv,,""%%ss\\nn\\nn"",,SSHHEELLLL__SSTTRRTTMMSSGG));;//**CCoonnttiinnuuaallllyypprroommpptttthheeuusseerr,,rreeaaddiinnppuutt,,aannddeexxeeccuutteeccoommmmaanndd**//wwhhiillee((TTRRUUEE)){{//**DDiissppllaayypprroommpptt**//ffpprriinnttff((ddeevv,,SSHHEELLLL__PPRROOMMPPTT));;//**RReeaaddaaccoommmmaanndd**//lleenn==rreeaadd((ddeevv,,bbuuff,,ssiizzeeooff((bbuuff))));;//**EExxiittggrraacceeffuullllyyoonneenndd--ooff--ffiillee**//iiff((lleenn====EEOOFF)){{bbrreeaakk;;}} //**IIfflliinneeccoonnttaaiinnssoonnllyyNNEEWWLLIINNEE,,ggoottoonneexxttlliinnee**//iiff((lleenn<<==11)){{ccoonnttiinnuuee;;}} bbuuff[[lleenn]]==SSHH__NNEEWWLLIINNEE;;//**tteerrmmiinnaatteelliinnee**////**PPaarrsseeiinnppuuttlliinneeaannddddiivviiddeeiinnttoottookkeennss**//nnttookk==lleexxaann((bbuuff,,lleenn,,ttookkbbuuff,,&&ttlleenn,,ttookk,,ttookkttyypp));;//**HHaannddlleeppaarrssiinnggeerrrroorr**//iiff((nnttookk====SSYYSSEERRRR)){{ffpprriinnttff((ddeevv,,""%%ss\\nn"",,SSHHEELLLL__SSYYNNEERRRRMMSSGG));;ccoonnttiinnuuee;;}} //**IIfflliinneeiisseemmppttyy,,ggoottoonneexxttiinnppuuttlliinnee**//iiff((nnttookk====00)){{Sec. 26.11        The Heart Of The Command Interpreter 637ffpprriinnttff((ddeevv,,""\\nn""));;ccoonnttiinnuuee;;}} //**IIffllaassttttookkeenniiss’’&&’’,,sseettbbaacckkggrroouunndd**//iiff((ttookkttyypp[[nnttookk--11]]====SSHH__TTOOKK__AAMMPPEERR)){{nnttookk----;;ttlleenn--==22;;bbaacckkggnndd==TTRRUUEE;;}}eellssee{{bbaacckkggnndd==FFAALLSSEE;;}} //**CChheecckkffoorriinnppuutt//oouuttppuuttrreeddiirreeccttiioonn((ddeeffaauullttiissnnoonnee))**//oouuttnnaammee==iinnnnaammee==NNUULLLL;;iiff((((nnttookk>>==33))&&&&((((ttookkttyypp[[nnttookk--22]]====SSHH__TTOOKK__LLEESSSS))||||((ttookkttyypp[[nnttookk--22]]====SSHH__TTOOKK__GGRREEAATTEERR)))))){{iiff((ttookkttyypp[[nnttookk--11]]!!==SSHH__TTOOKK__OOTTHHEERR)){{ffpprriinnttff((ddeevv,,""%%ss\\nn"",,SSHHEELLLL__SSYYNNEERRRRMMSSGG));;ccoonnttiinnuuee;;}} iiff((ttookkttyypp[[nnttookk--22]]====SSHH__TTOOKK__LLEESSSS)){{iinnnnaammee==&&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;}}eellssee{{oouuttnnaammee==&&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;}} nnttookk--==22;;ttlleenn==ttookk[[nnttookk]];;}} iiff((((nnttookk>>==33))&&&&((((ttookkttyypp[[nnttookk--22]]====SSHH__TTOOKK__LLEESSSS))||||((ttookkttyypp[[nnttookk--22]]====SSHH__TTOOKK__GGRREEAATTEERR)))))){{iiff((ttookkttyypp[[nnttookk--11]]!!==SSHH__TTOOKK__OOTTHHEERR)){{ffpprriinnttff((ddeevv,,""%%ss\\nn"",,SSHHEELLLL__SSYYNNEERRRRMMSSGG));;ccoonnttiinnuuee;;}} iiff((ttookkttyypp[[nnttookk--22]]====SSHH__TTOOKK__LLEESSSS)){{iiff((iinnnnaammee!!==NNUULLLL)){{ffpprriinnttff((ddeevv,,""%%ss\\nn"",,SSHHEELLLL__SSYYNNEERRRRMMSSGG));;ccoonnttiinnuuee;;}}638 An Example User Interface: The Xinu Shell Chap. 26iinnnnaammee==&&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;}}eellssee{{iiff((oouuttnnaammee!!==NNUULLLL)){{ffpprriinnttff((ddeevv,,""%%ss\\nn"",,SSHHEELLLL__SSYYNNEERRRRMMSSGG));;ccoonnttiinnuuee;;}} oouuttnnaammee==&&ttookkbbuuff[[ttookk[[nnttookk--11]]]];;}} nnttookk--==22;;ttlleenn==ttookk[[nnttookk]];;}} //**VVeerriiffyyrreemmaaiinniinnggttookkeennssaarreettyyppee""ootthheerr""**//ffoorr((ii==00;;ii<<nnttookk;;ii++++)){{iiff((ttookkttyypp[[ii]]!!==SSHH__TTOOKK__OOTTHHEERR)){{bbrreeaakk;;}}}} iiff((((nnttookk====00))||||((ii<<nnttookk)))){{ffpprriinnttff((ddeevv,,SSHHEELLLL__SSYYNNEERRRRMMSSGG));;ccoonnttiinnuuee;;}} ssttddiinnppuutt==ssttddoouuttppuutt==ddeevv;;//**LLooookkuuppffiirrssttttookkeenniinntthheeccoommmmaannddttaabbllee**//ffoorr((jj==00;;jj<<nnccmmdd;;jj++++)){{ssrrcc==ccmmddttaabb[[jj]]..ccnnaammee;;ccmmpp==ttookkbbuuff;;ddiiffff==FFAALLSSEE;;wwhhiillee((**ssrrcc!!==NNUULLLLCCHH)){{iiff((**ccmmpp!!==**ssrrcc)){{ddiiffff==TTRRUUEE;;bbrreeaakk;;}} ssrrcc++++;;ccmmpp++++;;}} iiff((ddiiffff||||((**ccmmpp!!==NNUULLLLCCHH)))){{ccoonnttiinnuuee;;}}eellssee{{bbrreeaakk;;}}Sec. 26.11        The Heart Of The Command Interpreter 639}} //**HHaannddlleeccoommmmaannddnnoottffoouunndd**//iiff((jj>>==nnccmmdd)){{ffpprriinnttff((ddeevv,,""ccoommmmaanndd%%ssnnoottffoouunndd\\nn"",,ttookkbbuuff));;ccoonnttiinnuuee;;}} //**HHaannddlleebbuuiilltt--iinnccoommmmaanndd**//iiff((ccmmddttaabb[[jj]]..ccbbuuiillttiinn)){{//**NNoobbaacckkggrroouunnddoorrrreeddiirreecctt..**//iiff((iinnnnaammee!!==NNUULLLL||||oouuttnnaammee!!==NNUULLLL||||bbaacckkggnndd)){{ffpprriinnttff((ddeevv,,SSHHEELLLL__BBGGEERRRRMMSSGG));;ccoonnttiinnuuee;;}}eellssee{{//**SSeettuuppaarrggvveeccttoorrffoorrccaallll**//ffoorr((ii==00;;ii<<nnttookk;;ii++++)){{aarrggss[[ii]]==&&ttookkbbuuff[[ttookk[[ii]]]];;}} //**CCaallllbbuuiillttiinnsshheellllffuunnccttiioonn**//iiff((((**ccmmddttaabb[[jj]]..ccffuunncc))((nnttookk,,aarrggss))====SSHHEELLLL__EEXXIITT)){{bbrreeaakk;;}}}} ccoonnttiinnuuee;;}} //**OOppeennffiilleessaannddrreeddiirreeccttII//OOiiffssppeecciiffiieedd**//iiff((iinnnnaammee!!==NNUULLLL)){{ssttddiinnppuutt==ooppeenn((NNAAMMEESSPPAACCEE,,iinnnnaammee,,""rroo""));;iiff((ssttddiinnppuutt====SSYYSSEERRRR)){{ffpprriinnttff((ddeevv,,SSHHEELLLL__IINNEERRRRMMSSGG,,iinnnnaammee));;ccoonnttiinnuuee;;}}}} iiff((oouuttnnaammee!!==NNUULLLL)){{ssttddoouuttppuutt==ooppeenn((NNAAMMEESSPPAACCEE,,oouuttnnaammee,,""ww""));;iiff((ssttddoouuttppuutt====SSYYSSEERRRR)){{ffpprriinnttff((ddeevv,,SSHHEELLLL__OOUUTTEERRRRMMSSGG,,oouuttnnaammee));;640 An Example User Interface: The Xinu Shell Chap. 26ccoonnttiinnuuee;;}}eellssee{{ccoonnttrrooll((ssttddoouuttppuutt,,FF__CCTTLL__TTRRUUNNCC,,00,,00));;}}}} //**SSppaawwnncchhiillddtthhrreeaaddffoorrnnoonn--bbuuiilltt--iinnccoommmmaannddss**//cchhiilldd==ccrreeaattee((ccmmddttaabb[[jj]]..ccffuunncc,,SSHHEELLLL__CCMMDDSSTTKK,,SSHHEELLLL__CCMMDDPPRRIIOO,,ccmmddttaabb[[jj]]..ccnnaammee,,22,,nnttookk,,&&ttmmppaarrgg));;//**IIffccrreeaattiioonnoorraarrgguummeennttccooppyyffaaiillss,,rreeppoorrtteerrrroorr**//iiff((((cchhiilldd====SSYYSSEERRRR))||||((aaddddaarrggss((cchhiilldd,,nnttookk,,ttookk,,ttlleenn,,ttookkbbuuff,,&&ttmmppaarrgg))====SSYYSSEERRRR)))){{ffpprriinnttff((ddeevv,,SSHHEELLLL__CCRREEAATTMMSSGG));;ccoonnttiinnuuee;;}} //**SSeettssttddiinnppuuttaannddssttddoouuttppuuttiinncchhiillddttoorreeddiirreeccttII//OO**//pprrooccttaabb[[cchhiilldd]]..pprrddeesscc[[00]]==ssttddiinnppuutt;;pprrooccttaabb[[cchhiilldd]]..pprrddeesscc[[11]]==ssttddoouuttppuutt;;mmssgg==rreeccvvccllrr(());;rreessuummee((cchhiilldd));;iiff((!!bbaacckkggnndd)){{mmssgg==rreecceeiivvee(());;wwhhiillee((mmssgg!!==cchhiilldd)){{mmssgg==rreecceeiivvee(());;}}}}}} //**TTeerrmmiinnaatteetthheesshheellllpprroocceessssbbyyrreettuurrnniinnggffrroommtthheettoopplleevveell**//ffpprriinnttff((ddeevv,,SSHHEELLLL__EEXXIITTMMSSGG));;rreettuurrnnOOKK;;}}The main loop calls lexan to divide the input line into tokens, and begins process-ing the command. First, the code checks the last token to see if the user appended anSec. 26.11        The Heart Of The Command Interpreter 641ampersand. If so, the shell sets Boolean backgnd to TRUE; otherwise, backgnd is set to FALSE. The variable is used later to determine whether to run the command in back-ground.After the background token has been removed, the shell checks for I/O redirection. Input and output redirection can both be specified, and the specifications can occur in either order, but must be the last of the remaining tokens. Therefore, the shell checks for redirection twice. If two specifications occur, the shell verifies that they do not both specify input or both specify output. At this point in processing the line, the shell mere-ly saves a pointer to the file name without attempting to open the file (the files are opened later).Once the shell has removed tokens that specify I/O redirection, the only tokens that remain correspond to a command name and arguments to the command. Thus, be-fore it continues to process the command, the shell iterates through remaining tokens to verify that they are of type “other” (SH_TOK_OTHER). If any are not, the code prints an error message and moves to the next input line. Once all checks have been per-formed, the shell looks up the command and executes the corresponding function.26.12 Command Name Lookup And Builtin ProcessingThe first token on the line is taken to be a command name. Recall that the exam-ple code stores information about commands in array cmdtab. Thus, lookup is straight-forward — the shell searches the array sequentially looking for an exact match between the first token and one of the command names. If no match is found, the code prints an error message and moves to the next command.Our shell supports two types of commands: builtin and non-builtin. The difference arises from the way the commands are executed: the shell uses the conventional func-tion call mechanism to execute a builtin command, and creates a separate process to ex-ecute a non-builtin command. The distinction means that a user cannot specify back-ground processing and cannot redirect I/O for a builtin command.†To test whether a command should execute as a builtin, the shell examines field cbuiltin of the entry in cmdtab. For a builtin command, no redirection or background processing is allowed. So, the shell verifies that neither was specified, creates an argu-ment array in variable args, and calls the command function. The next section explains how command arguments are constructed.26.13 Arguments Passed To CommandsOur example shell uses the same argument passing mechanism as a Unix shell. When a command is invoked, the shell passes tokens from the command line as uninter-preted, null-terminated strings. The shell does not know how many arguments a given command expects, nor does the shell understand whether the arguments make sense. †An exercise suggests a way to blur the distinction between builtin and non-builtin commands.642 An Example User Interface: The Xinu Shell Chap. 26Instead, the shell merely passes all arguments from the command line, and allows the command to check and interpret them.Conceptually, the shell passes an arbitrary number of string arguments, where the number is only limited by the length of an input line. To make programming simpleand uniform, the shell creates an array of pointers and only passes two values when it invokes a command: a count of command-line arguments and an array of pointers to character strings that constitute the arguments. Unix uses the names argc and argv for the two arguments a command receives from the shell; Xinu uses the names nargs and args. The names are only a convention — a programmer can choose arbitrary names for arguments when writing a function that implements a command.The example shell adopts another convention from Unix: the first item in the args array is a pointer to the command name. An example will clarify the details. Considerthe command line:date -f illegalAlthough the argument illegal is not permitted by the Xinu date command, the shellsimply passes the string and allows the function that implements the date command to check its arguments. Figure 26.4 illustrates the two items the shell passes to the date function.argsnargs 3da t e+-f+ille g a l++nargs entriesFigure 26.4 Illustration of the two arguments (nargs and args) the shellpasses to the date command for an input line: date -f illegalAlthough passing an integer, such as nargs, to a command is trivial, the args array is more complex. In essence, the shell must construct the args array, and then pass its address to the command. There are two cases: builtin commands and non-builtin com-mands. We will consider builtins first.After the shell has parsed the command line and removed tokens for I/O redirec-tion and background processing, variable ntok will contain the count of remaining to-kens, which is exactly the count needed for nargs. Furthermore, array tok contains theindex in tokbuf where each token begins. Therefore, the shell can create an args arrayby computing the starting address of each token.To form the args array, the code iterates through ntok tokens and for the ith tokencomputes the expression:&tokbuf[tok[i]]Sec. 26.13        Arguments Passed To Commands 643That is, it sets args[i] equal to the address of the ith token in tokbuf. Once array argshas been initialized, the shell calls the function that implements the builtin command.26.14 Passing Arguments To A Non-builtin CommandThe second case, non-builtin commands, is more complex. Our shell creates a separate process to execute commands that are not builtin, and the command can exe-cute in background (i.e., the shell can continue to read and handle new input lines while the command process runs in background). The question arises: what mechanism should the shell use to pass arguments to a process? The shell cannot use the same ap-proach as with builtin commands because a command running in background needs a separate copy of its arguments that will not change as the shell goes on to process another command.There are two ways to solve the problem of argument passing for a non-builtin command: the shell can allocate separate storage to arguments or the shell can hide the arguments in storage already allocated for the process. Because Xinu does not automat-ically release heap storage when a process terminates, the first approach requires the shell to keep a record of the argument storage allocated for each command so it can free the memory once the process completes. Thus, we have chosen the second approach:After creating a process to execute a command, the shell places acopy of arguments in the stack area of the process and then allows the process to execute.Where on the process’s stack should arguments be placed? Although it might be possible to rewrite create so it leaves space at the top of the stack, doing so is messy. Thus, we have chosen to use the area at the bottom of the stack. The shell stores a copy of the args array followed by a copy of the strings in tokbuf in the stack. Of course, pointers in the copy of the args vector must be assigned the addresses of strings in the copy of tokbuf. Figure 26.5 illustrates how the data from Figure 26.4 is arrangedin contiguous memory locations.da t e+-f+ille g a l++args array starts at lowest byte of user’s stack or next multiple of 4 bytes beyond itFigure 26.5A copy of the args array and argument strings in a process’sstack.644 An Example User Interface: The Xinu Shell Chap. 26Rather than incorporate code into the shell that copies items into the process’sstack, our implementation uses a separate function, addargs. File addargs.c containsthe code.//**aaddddaarrggss..cc--aaddddaarrggss**//##iinncclluuddee<<xxiinnuu..hh>>##iinncclluuddee""sshhpprroottoottyyppeess..hh""//**------------------------------------------------------------------------------------------------------------------------------------------------**aaddddaarrggss--AAddddllooccaallccooppyyooffaarrggvv--ssttyylleeaarrgguummeennttssttootthheessttaacckkooff**aaccoommmmaannddpprroocceesssstthhaatthhaassbbeeeennccrreeaatteeddbbyytthheesshheellll**------------------------------------------------------------------------------------------------------------------------------------------------**//ssttaattuussaaddddaarrggss((ppiidd3322ppiidd,,//**IIDDooffpprroocceessssttoouussee**//iinntt3322nnttookk,,//**CCoouunnttooffaarrgguummeennttss**//iinntt3322ttookk[[]],,//**IInnddeexxooffttookkeennssiinnttookkbbuuff**//iinntt3322ttlleenn,,//**LLeennggtthhooffddaattaaiinnttookkbbuuff**//cchhaarr**ttookkbbuuff,,//**AArrrraayyooffnnuullll--tteerrmm..ttookkeennss**//vvooiidd**dduummmmyy//**DDuummmmyyaarrgguummeenntttthhaattwwaass**////**uusseeddaattccrreeaattiioonnaannddmmuusstt**////**bbeerreeppllaacceeddbbyyaappooiinntteerr**////**ttooaannaarrgguummeennttvveeccttoorr**//)){{iinnttmmaasskkmmaasskk;;//**SSaavveeddiinntteerrrruuppttmmaasskk**//ssttrruuccttpprroocceenntt**pprrppttrr;;//**PPttrrttoopprroocceessss’’ttaabblleeeennttrryy**//uuiinntt3322aalloocc;;//**AArrgguummeennttllooccaattiioonniinnpprroocceessss**////**ssttaacckkaassaanniinntteeggeerr**//uuiinntt3322**aarrgglloocc;;//**LLooccaattiioonniinnpprroocceessss’’ssssttaacckk**////**ttooppllaacceeaarrggssvveeccttoorr**//cchhaarr**aarrggssttrr;;//**LLooccaattiioonniinnpprroocceessss’’ssssttaacckk**////**ttooppllaacceeaarrggssttrriinnggss**//uuiinntt3322**sseeaarrcchh;;//**ppooiinntteerrtthhaattsseeaarrcchheessffoorr**////**dduummmmyyaarrgguummeennttoonnssttaacckk**//uuiinntt3322**aappttrr;;//**WWaallkksstthhrroouugghhaarrggssaarrrraayy**//iinntt3322ii;;//**IInnddeexxiinnttoottookkaarrrraayy**//mmaasskk==ddiissaabbllee(());;//**CChheecckkaarrgguummeennttccoouunnttaannddddaattaalleennggtthh**//iiff((((nnttookk<<==00))||||((ttlleenn<<00)))){{Sec. 26.14        Passing Arguments To A Non-builtin Command 645rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}} pprrppttrr==&&pprrooccttaabb[[ppiidd]];;//**CCoommppuutteelloowweessttllooccaattiioonniinntthheepprroocceessssssttaacckkwwhheerreetthhee**////**aarrggssaarrrraayywwiillllbbeessttoorreeddffoolllloowweeddbbyytthheeaarrgguummeenntt**////**ssttrriinnggss**//aalloocc==((uuiinntt3322))((pprrppttrr-->>pprrssttkkbbaassee--pprrppttrr-->>pprrssttkklleenn++ssiizzeeooff((uuiinntt3322))));;aarrgglloocc==((uuiinntt3322**))((((aalloocc++33))&&~~00xx33));;//**rroouunnddmmuullttiipplleeooff44**////**CCoommppuutteetthheeffiirrssttllooccaattiioonnbbeeyyoonnddaarrggssaarrrraayyffoorrtthheessttrriinnggss**//aarrggssttrr==((cchhaarr**))((aarrgglloocc++((nnttookk++11))));;//**++11ffoorraannuullllppttrr**////**SSeetteeaacchhllooccaattiioonniinntthheeaarrggssvveeccttoorrttoobbeetthheeaaddddrreessssooff**////**ssttrriinnggaarreeaapplluusstthheeooffffsseettoofftthhiissaarrgguummeenntt**//ffoorr((aappttrr==aarrgglloocc,,ii==00;;ii<<nnttookk;;ii++++)){{**aappttrr++++==((uuiinntt3322))((aarrggssttrr++ttookk[[ii]]));;}} //**AAddddaannuullllppooiinntteerrttootthheeaarrggssaarrrraayy**//**aappttrr++++==((uuiinntt3322))NNUULLLL;;//**CCooppyytthheeaarrgguummeennttssttrriinnggssffrroommttookkbbuuffiinnttoopprroocceessss’’ssssttaacckk**////**jjuussttbbeeyyoonnddtthheeaarrggssvveeccttoorr**//mmeemmccppyy((aappttrr,,ttookkbbuuff,,ttlleenn));;//**FFiinnddtthheesseeccoonnddaarrgguummeennttiinnpprroocceessss’’ssssttaacckk**//ffoorr((sseeaarrcchh==((uuiinntt3322**))pprrppttrr-->>pprrssttkkppttrr;;sseeaarrcchh<<((uuiinntt3322**))pprrppttrr-->>pprrssttkkbbaassee;;sseeaarrcchh++++)){{//**IIffffoouunndd,,rreeppllaacceewwiitthhtthheeaaddddrreessssoofftthheeaarrggssvveeccttoorr**//iiff((**sseeaarrcchh====((uuiinntt3322))dduummmmyy)){{**sseeaarrcchh==((uuiinntt3322))aarrgglloocc;;rreessttoorree((mmaasskk));;rreettuurrnnOOKK;;}}}}646 An Example User Interface: The Xinu Shell Chap. 26//**AArrgguummeennttvvaalluueennoottffoouunnddoonntthheessttaacckk--rreeppoorrttaanneerrrroorr**//rreessttoorree((mmaasskk));;rreettuurrnnSSYYSSEERRRR;;}}Once a process has been created, the process table entry contains both the address of the top of the stack and the stack size. Because a stack grows downward in memory, addargs can compute the lowest memory address assigned to the stack by subtracting the stack size from the address of the stack top. However, a few details complicate the code. For example, on some processors pointers must be aligned. Therefore, addargs computes a starting location in the stack that is a multiple of four bytes. As a result, the final byte of the last argument string may end up to three bytes before the lowest byte of the stack. Furthermore, the code adds an extra null pointer to the end of the args ar-ray as shown in Figure 26.5.Most of code in addargs operates as expected by computing the address in thestack at which the args array starts and then copying both the args array and the argu-ment strings into the stack. However, the final for loop, which iterates through theprocess’s stack may seem unusual: it finds the second argument that has been passed to the process and replaces it with a pointer to the args array. When the process is creat-ed, the shell uses a dummy value for the argument and then passes the value to addargs in parameter dummy. Thus, addargs searches the stack until it finds the value and re-places it.Why does our implementation use a dummy argument and a search? The alterna-tive consists of having addargs calculate the location of the second argument. Although calculating a location may seem cleaner, such a calculation requires addargs to under-stand the format of the initial process stack. Using a search means that only create needs to understand the details of process creation and the format of the stack. Of course, using a search has a disadvantage: the shell must choose a dummy argument that will not occur early in the stack. Rather than choosing an arbitrary integer, our shell implementation uses the address of variable tmparg.26.15 I/O RedirectionOnce a process has been created to execute a command and the shell has called ad-dargs to copy arguments into the process stack, all that remains is to handle I/O redirection and start the process executing. To redirect I/O, the shell assigns device descriptors to the array prdesc in the process table entry. The two key values are prdesc[0] and prdesc[1], which the shell sets to stdin and stdout.How do variables stdin and stdout receive values? Recall that the shell initializes them to dev, the device descriptor that was passed as an argument when the shell was invoked. Usually, the shell is invoked with device CONSOLE. Thus, if the user does not redirect I/O, the process executing a command will “inherit” the console device forSec. 26.15        I  /O Redirection 647input and output. If a user does redirect I/O, the shell sets variables inname and/or out-name to the name that was specified on the command line. Otherwise inname and out-name are set to NULL. Before assigning stdin and stdout to the command process, the shell checks inname and outname. Ifinname is non-null, the shell calls open to open inname for reading and sets stdin to the descriptor. Similarly, if outname is non-null, the shell calls open to open outname for writing, and sets stdout to the descriptor.When should descriptors be closed? Our example code assumes that the commandwill close standard input and standard output descriptors before it exits; the shell doesnot clean up descriptors after the command completes. Forcing all commands to close their standard I/O devices before exiting has the disadvantage of making commands dif-ficult to understand and difficult to program correctly because command code must remember to close devices even though the code does not open them. Having the shell monitor command processes and close standard I/O devices is also difficult because command processes are independent and multiple command processes can exit at the same time. The exercises suggest another alternative.The final section of code in the shell runs the command process. There are twocases. To run the process in foreground, the shell calls resume to start the process, andthen calls receive to wait for a message that the process has completed (when the proc-ess exits, kill sends a message to the shell). For the background case, the shell starts the command process but does not wait. Instead, the main shell loop continues and the shell reads the next command. The exercises suggest a modification of the code to im-prove correctness.26.16 An Example Command Function (sleep)To understand how a command processes arguments, consider function xsh_sleep, which implements the sleep command.†  Sleep is trivial — it delays for the number of seconds specified by its argument. Thus, the delay is achieved by a single line of code that calls the sleep system function; the code is presented here merely to illustrate how arguments are parsed and how a command function prints a help message. File xsh.sleep.c contains the code.
†By convention, the function that implements command X is named xsh_X.648 An Example User Interface: The Xinu Shell Chap. 26//**xxsshh__sslleeeepp..cc--xxsshh__sslleeeepp**//##iinncclluuddee<<xxiinnuu..hh>>##iinncclluuddee<<ssttddiioo..hh>>##iinncclluuddee<<ssttrriinngg..hh>>//**------------------------------------------------------------------------------------------------------------------------------------------------**xxsshh__sslleeeepp--SShheellllccoommmmaannddttooddeellaayyffoorraassppeecciiffiieeddnnuummbbeerrooffsseeccoonnddss**------------------------------------------------------------------------------------------------------------------------------------------------**//sshheellllccmmddxxsshh__sslleeeepp((iinnttnnaarrggss,,cchhaarr**aarrggss[[]])){{iinntt3322ddeellaayy;;//**DDeellaayyiinnsseeccoonnddss**//cchhaarr**cchhppttrr;;//**WWaallkksstthhrroouugghhaarrgguummeenntt**//cchhaarrcchh;;//**NNeexxttcchhaarraacctteerrooffaarrgguummeenntt**////**FFoorraarrgguummeenntt’’----hheellpp’’,,eemmiitthheellppaabboouutttthhee’’sslleeeepp’’ccoommmmaanndd**//iiff((nnaarrggss====22&&&&ssttrrnnccmmpp((aarrggss[[11]],,""----hheellpp"",,77))====00)){{pprriinnttff((""UUssee::%%ss\\nn\\nn"",,aarrggss[[00]]));;pprriinnttff((""DDeessccrriippttiioonn::\\nn""));;pprriinnttff((""\\ttDDeellaayyffoorraassppeecciiffiieeddnnuummbbeerrooffsseeccoonnddss\\nn""));;pprriinnttff((""OOppttiioonnss::\\nn""));;pprriinnttff((""\\tt----hheellpp\\ttddiissppllaayytthhiisshheellppaannddeexxiitt\\nn""));;rreettuurrnn00;;}} //**CChheecckkffoorrvvaalliiddnnuummbbeerrooffaarrgguummeennttss**//iiff((nnaarrggss>>22)){{ffpprriinnttff((ssttddeerrrr,,""%%ss::ttoooommaannyyaarrgguummeennttss\\nn"",,aarrggss[[00]]));;ffpprriinnttff((ssttddeerrrr,,""TTrryy’’%%ss----hheellpp’’ffoorrmmoorreeiinnffoorrmmaattiioonn\\nn"",,aarrggss[[00]]));;rreettuurrnn11;;}} iiff((nnaarrggss!!==22)){{ffpprriinnttff((ssttddeerrrr,,""%%ss::aarrgguummeennttiinneerrrroorr\\nn"",,aarrggss[[00]]));;ffpprriinnttff((ssttddeerrrr,,""TTrryy’’%%ss----hheellpp’’ffoorrmmoorreeiinnffoorrmmaattiioonn\\nn"",,aarrggss[[00]]));;rreettuurrnn11;;}} cchhppttrr==aarrggss[[11]];;cchh==**cchhppttrr++++;;Sec. 26.16        An Example Command Function (sleep) 649ddeellaayy==00;;wwhhiillee((cchh!!==NNUULLLLCCHH)){{iiff((((cchh<<’’00’’))||||((cchh>>’’99’’)))){{ffpprriinnttff((ssttddeerrrr,,""%%ss::nnoonnddiiggiittiinnaarrgguummeenntt\\nn"",,aarrggss[[00]]));;rreettuurrnn11;;}} ddeellaayy==1100**ddeellaayy++((cchh--’’00’’));;cchh==**cchhppttrr++++;;}} sslleeeepp((ddeellaayy));;rreettuurrnn00;;}}26.17 PerspectiveThe design of a shell introduces many choices. A designer has almost complete freedom because a shell operates as an application that lies outside the rest of the sys-tem and only the command functions depend on the shell. Thus, as our example shows, the argument passing paradigm used by a shell can differ dramatically from the argu-ment passing paradigm used throughout the rest of the system. Similarly, a designer can choose a syntax for command-line input as well as a semantic interpretation without affecting other parts of the system.Perhaps the most interesting aspect of shell design arises from the choice of how much knowledge about commands is bound into the shell. On the one hand, if a shell knows all commands and their arguments, the shell can complete command names and check the command arguments, making the code that implements commands much simpler. On the other hand, allowing late binding means more flexibility because the shell does not need to change when new commands are created, but the tradeoff is that each command must check its arguments. Furthermore, a designer can choose whether to build each command function into the shell or to leave each command in a separate file, as Unix does.Our example shell demonstrates one of the most important principles in shelldesign: a relatively small amount of code can provide powerful abstractions for a user.For example, consider how little code is needed to interpret input or output redirection, and the small amount of code needed to recognize an ampersand at the end of the line as a request to run a command in background. Despite their compact implementation, facilities for I/O redirection and background processing make a shell much more powerful and user-friendly than a shell in which each command interacts with a user to prompt for input and output information or whether to run in background.650 An Example User Interface: The Xinu Shell Chap. 2626.18 SummaryWe have examined a basic command-line interpreter called a shell. Although the example code is small, it supports concurrent command execution, redirection of input and output, and arbitrary string argument passing. The implementation is divided into two conceptual pieces: a lexical analyzer that reads a line of text and groups characters into tokens, and a shell function that checks the sequence of tokens and invokes a com-mand.The example code demonstrates the relationship between a user interface and the facilities provided by the underlying system. For example, although the underlying sys-tem provides support for concurrent processes, the shell makes concurrent execution available to a user. Similarly, although the underlying system provides the ability to open devices or files, the shell makes I/O redirection available to the user.EXERCISES26.1  Rewrite the shell to use rawmode and handle all keyboard input. Arrange for Control-Pto move to the “previous” shell command, and interpret Control-B and Control-F asmoving backward and forward through a line as Unix ksh or bash do.26.2 Rewrite the grammar in Figure 26.2 to remove the optional notation [ ].26.3  Modify the shell to allow I/O redirection on builtin commands. What changes arenecessary?26.4 Devise a modified version of create that handles string arguments for the shell, automati-cally performing the same function as addargs when creating the process.26.5      Modify the shell so it can be used as a command.  That is, allow the user to invoke com-mand shell and start with a new shell process. Have control return to the original shellwhen the subshell exits. Be careful.26.6 Modify the shell so it can accept input from a text file (i.e., allow the user to build a fileof commands and then start a shell interpreting them).26.7 Modify the shell to allow a user to redirect standard error as well as standard output.26.8 Read about shell variables in a Unix shell, and implement a similar variable mechanismin the Xinu shell.26.9    Find out how the Unix shell passes environment variables to command processes, andimplement a similar mechanism in the Xinu shell.26.10 Implement inline input redirection, allowing the user to typeccoommmmaanndd<<<<ssttooppfollowed by lines of input terminated by a line that begins with the sequence of charac-ters stop. Have the shell save the input in a temporary file and execute the command with the temporary file as standard input.Exercises65126.11 It is possible to extend the command table to include information on the number andtypes of arguments each command requires, and to have the shell check arguments be-fore passing them to the command. List two advantages and two disadvantages of hav-ing the shell check arguments.26.12 Suppose the designer decided to add a for statement to the shell so a user could executea command repeatedly as in:ffoorr112233445566778899;;ccoommmmaanndd--lliinneewhere for is a keyword, and command-line is a command line exactly like commands the shell now accepts. Should the designer modify the shell syntax and parser or try to make for a builtin command? Explain.26.13 Add command completion to the shell by having the user type a unique prefix of a com-mand followed by ESC; have the shell type out the completed command and wait for the user to add arguments and press the Enter key.26.14 Unix allows command lines of the form:ccoommmmaanndd__11||ccoommmmaanndd__22||ccoommmmaanndd__33where the symbol |, called a pipe, specifies that the standard output of one command is connected to the standard input of the next command. Implement a pipe device for Xinu, and modify the shell to allow a pipeline of commands.26.15   Modify the tty device driver and shell so that pressing CONTROL-c kills the currentlyexecuting process.26.16    Modify the tty device driver and shell so that pressing CONTROL-z places the currentlyexecuting process in background.26.17    Modify the design to permit I/O redirection and background processing for builtin com-mands: if redirection or background processing is needed, treat the command as a normal command and create a separate process.26.18 The text describes the problem of closing device descriptors when a command exits.Modify the system so kill automatically closes a process’s descriptors when the process exits.26.19 The example shell calls receive to wait for a foreground process to exit, but does notcheck the message received. Show a sequence of events that can cause the shell toproceed before a foreground command has completed.26.20    Modify the code in the shell to repair the problem in the previous exercise.Appendix 1Porting An Operating System
Progress, far from consisting in change, depends upon retentiveness....— George SantayanaA1.1 IntroductionThroughout the text, we have focused on the interior of an operating system. Chapters present abstractions, discuss design tradeoffs, show how the code fits into a hierarchical organization, and examine implementation details. Chapter 25 examines how a system can be configured to allow the code to run on systems with a variety of peripheral devices.This appendix examines two larger questions. First, how can an existing operating system be ported to a new hardware platform that differs in some fundamental ways? Second, can an operating system be written in a way that makes porting easier? To answer the first question, the appendix discusses cross-development and downloading, outlines the steps involved in understanding hardware, and provides practical advice about how to proceed. To answer the second question, the appendix discusses tech-niques that have been used to make an operating system adaptable.
653654Operating System DesignA1.2 Motivation: Evolving HardwareAlthough work on operating systems demands the ability to grasp high-level abstractions, design efficient mechanisms, and understand small details, the most signi-ficant challenge facing operating system designers does not arise from the intellectual difficulty of the task. Instead, it arises from the constant changes in technology and the consequent economic pressure for vendors to create new products or to add features to existing products. While this revision of the text was being written, for example, one hardware vendor introduced two new hardware platforms. One of the platforms represented a minor improvement, but the other made dramatic changes in the processor chip, instruction set, memory organization, and I/O devices.Because an operating system interfaces directly with the underlying hardware, even small changes in the hardware can have an overwhelming effect on the system. For ex-ample, if a vendor changes the hardware to reserve a piece of the memory address space for Flash ROM, the memory management software in the operating system must be modified. Although such modification may seem straightforward, the details may in-volve changes to page tables and the code that interacts with the MMU hardware as well as the code that allocates memory on demand. If a significant amount of the ad-dress space becomes reserved, the operating system’s allocation policy may need to change. The point is:Because both technological and economic factors cause continual changes in hardware, an operating system designer must be prepared to port the operating system to new platforms.A1.3 Steps Taken When Porting An Operating SystemDespite the effects of hardware change, moving an existing operating system to a new platform is much easier than designing and building a new system from scratch. In particular, if an operating system has been written in a high-level language, porting the system to a new platform is easy because a compiler can do most of the work.Consider Xinu. Most of the code is written in C. If a C compiler is available forthe new platform, many of the functions can be compiled without making changes inthe source. If a given function deals with basic data structures, such as integers, charac-ters, arrays, and structures, a compiler may be able to compile the code without change, and the resulting binary program may run correctly. Even in cases where change is needed, the modifications may be minor (e.g., to accommodate slight differences in compilers). Thus, a principle is:An operating system written in a high-level language, such as C, is much easier to port to a new platform than a system written in assem-bly language.Sec. A1.3        Steps Taken When Porting An Operating System 655We will assume that, whenever possible, an operating system has been written in C, and we will consider the steps taken when porting to a new platform. Specifically, Figure A1.1 lists steps taken when porting Xinu.Step Description1. Learn about the new hardware2. Build cross-development tools3. Learn the compiler’s calling conventions4. Build a bootstrap mechanism5. Devise a basic polled output function6. Load and run a sequential program7. Port and test the basic memory manager8. Port the context switch and process creation functions9. Port and test the remaining process manager functions10. Build an interrupt dispatcher11. Port and test the real-time clock functions12. Port and test a tty driver13. Port or create drivers for an Ethernet and other devices14. Port the network stack, including Internet protocols15. Port the remote disk and RAM disk modules16. Port the local and remote file system modules17. Port the Xinu shell and other applicationsFigure A1.1  The steps taken when porting Xinu to a new platform.Note the relationship between the steps listed and the Xinu hierarchy. In essence, porting follows the same pattern as design: lower levels of the hierarchy are ported first, and successive levels are then added. The next sections highlight each step.656Operating System DesignA1.3.1  Learning About The HardwareStep 1 may seem straightforward. Unfortunately, some vendors are reluctant to re-veal details about their commercial hardware or software. For example, one vendor of a popular platform for experimenters refuses to provide any details about the USB hardware, making it impossible to write a USB driver. Even if generic information is available (e.g., the processor instruction set), a vendor may choose to keep some details secret (e.g., a map of the bus address space, the hardware initialization sequence, or the details about addresses on the bus). Nevertheless, throughout the remainder of this ap-pendix, we will assume that the needed information can be obtained.A1.3.2  Build Cross-Development ToolsIf the target hardware platform already runs a fully functional operating system, it may be possible to skip steps 1 through 6, and use the legacy operating system to com-pile and boot a new system. In most cases, however, the target platform will be new, may lack the power needed for a production system, or may not be available for development. Therefore, an operating system designer usually does not rely on the tar-get platform to support software development. Instead, a designer uses a cross-development approach in which a compiler and linker run on a conventional computer system, but are configured to produce code for the target machine.One of the most widely used cross-development environments consists of the GnuC Compiler, gcc, running on a Unix system, such as Linux or BSD. A copy of gcc canbe downloaded and used at no cost from:http://gcc.gnu.orgAfter downloading the source code for gcc, a programmer must select configuration op-tions to specify details, such as the target processor type and the endianness of the tar-get machine. The programmer runs the Unix utility make to build a version of the com-piler, assembler, and linker that will produce code for the target machine.A1.3.3  Learn The Compiler’s Calling ConventionsBecause it is a key to basic parts of an operating system, function invocation must be understood in detail. To build a context switch, for example, a programmer must precisely understand all details of the calling conventions. Although hardware designers include subroutine invocation mechanisms, understanding the hardware is not enough because a compiler can impose additional requirements.It may seem that using an open source compiler means the calling conventions will be obvious. However, an operating system designer needs to know about special cases, and the answers to questions may be difficult to find. Fortunately, information is usual-ly available on the web.Sec. A1.3        Steps Taken When Porting An Operating System 657A1.3.4  Build A Bootstrap MechanismOnce it has been compiled and linked, a program image must be downloaded into the target platform. Early embedded hardware required that the image be burned into a separate ROM chip and installed in a socket. Fortunately, modern systems use alterna-tive mechanisms that require much less effort. Typically, the hardware includes bootstrap functionality that can read an image from an SD memory card or a USB de-vice, accept an image over a console serial line, or download an image over a network. The bootstrap procedure is usually intended for system developers, and may not gen-erally be known.For example, consider the platforms used in the text. One can get started by build-ing an image, storing the image on an SD memory card, and booting from the card. Manually moving a card from a development machine to the target platform after every change can be tedious. Downloading over a network means a developer can create a new image and boot it without touching the hardware. However, arranging a way to download an image over a network can sometimes be difficult. For example, the Galileo does not have facilities that can boot an image over a network, which is why we had to write a bootstrap program, place the program on an SD card, and arrange for the program to perform a network download. Whatever method is chosen, it is essential to find a way to boot a copy of an image on the target machine.A1.3.5  Devise A Basic Polled Output FunctionThe next step in porting requires a programmer to devise a way for a running pro-gram to output characters. Until some basic I/O is available, a programmer must work in the dark — hoping that the image has been downloaded and started correctly. SomeI/O is invaluable: once even basic I/O is available, a programmer can determine how much of the system is working, and can isolate problems quickly.Because early test programs do not include interrupt processing, the basic I/O mechanism must use polling. A typical approach starts by finding a way to light an LED (e.g., by using GPIO pins). The key to development, however, lies in a kputcfunction that waits for a serial I/O device to become ready and then transmits a charac-ter. Both ends must agree on details such as the baud rate and bits per character, which can make debugging tedious. To simplify the code, the first version of kputc can be written in assembly language and can have information about the device (e.g., the CSR address and the baud rate) hardwired into the program. Once character output is avail-able, debugging proceeds rapidly.A1.3.6  Load And Run A Sequential ProgramOnce an image can be downloaded and run, the next step consists of building an environment that permits a sequential program to execute. In particular, successful exe-cution of a C program requires that memory permissions are set correctly (the program text is readable and data locations can be read and written) and a runtime stack exists (which is needed for function calls).658Operating System DesignInitializing the environment may seem trivial, but it requires knowledge of both hardware and compiler details. For example, one must choose a mode for the proces-sor. One must also choose an initial value for a stack pointer that does not conflict with device CSRs or holes in memory. Depending on the platform and compiler, it may be advisable to initialize a frame pointer or exception vectors (e.g., to prevent an invalid memory reference from generating another invalid memory reference, which generates another invalid memory reference, and so on).A1.3.7  Port And Test The Basic Memory ManagerOnce the layout of memory is known and a sequential program can be downloaded and run on the target hardware, a programmer can port and test the four basic memory management functions: getmem, freemem, getstk, and freestk. In addition to basic allo-cation and deallocation tests, a programmer should concentrate on alignment. Some hardware platforms require all memory accesses to be word aligned and some allow unaligned access. On machines that require alignment, a programmer should ensure that the memory free list has been initialized in such a way that alignment works correctly (i.e., all allocated blocks begin on the appropriate boundary).A1.3.8  Port The Context Switch And Process Creation FunctionsOnce basic memory management is working, a programmer can begin to port the process manager functions. In particular, a programmer starts with context switch, scheduling, and process creation. A giant step forward occurs once the three fundamen-tal process management functions are in place: instead of a sequential program, the code will be a fledgling operating system that supports concurrent execution.There are two difficult parts in the design. Creating the saved information for a process requires an intricate knowledge of the machine state and the operation of the context switch. Building a context switch is tricky because it involves finding a way to save all the state associated with a process and reload all the state from another process. It can be easy to overlook details or inadvertently to destroy state while saving a copy (e.g., clobber a register). Unfortunately, debugging can be extremely difficult because problems may not be discovered until the system attempts to reload saved state.A1.3.9  Port And Test The Remaining Process Manager FunctionsOnce process creation, scheduling, and context switching are working, other proc-ess management functions can be added easily. Semaphores functions can be portedand tested, as can message passing. Beyond the context switch level, most process management functions do not depend on the hardware. Of course, various data types may change, depending on the underlying hardware. For example, when moving from a 32-bit computer to a 64-bit computer, the msg32 type may be changed to msg64. Nevertheless, porting the semaphore and message passing functions is a relatively straightforward task.Sec. A1.3        Steps Taken When Porting An Operating System 659A1.3.10  Build An Interrupt DispatcherThe last big hardware hurdle concerns interrupts. Building an interrupt dispatcher requires a detailed knowledge of the hardware. How do the processor, interrupt con-troller, and bus interact? Exactly what state does the hardware save when an interrupt occurs, and what state is the operating system required to save? How does the dispatch-er determine which device interrupted? How does a dispatcher return to the running program when the interrupt ends? What addresses are used for the bus and devices?The details of interrupts are surprisingly subtle. On most systems, for example, I/O is memory mapped. Thus, I/O devices (and perhaps the bus hardware) are mapped into specific addresses. To access I/O facilities, however, an operating system may need to disable or avoid the memory cache because each I/O access must go to the underlying hardware rather than the cache.A1.3.11  Port And Test The Real-Time Clock FunctionsOnce interrupt dispatching is in place, an example device is needed to test the mechanism. It is logical to start by testing the real-time clock, usually one of the easi-est devices to use. On some systems building a real-time clock handler first is absolute-ly necessary because the clock cannot be stopped — if the system has interrupts en-abled, clock interrupts will occur. Clock interrupts mean that processes can call sleep()to delay for a specified time, and that time slicing goes into effect.A1.3.12  Port And Test A Tty DriverClock interrupts are distinct from other devices because a clock does not perform input or output. A serial line is perhaps the simplest type of device that has both inputand output (some hardware separates input and output interrupt handling). Thus, the tty driver will exercise both input and output, and ensure that all basic interrupt processing works.Fortunately, most systems include a serial line, and many use the same UART hardware as described in the text. Thus, much of the tty driver code, including the lower half, can simply be recompiled and used. Basic device parameters, which will have been worked out in Step A1.3.5, can be added to the device switch table or thelower half as appropriate.A1.3.13  Port Or Create Drivers For An Ethernet And Other DevicesOnce input and output have been tested, more complex device drivers can be port-ed. Devices that use DMA (e.g., disks and network interfaces) require buffer pools tobe in place, and may require a deeper understanding of how DMA interacts with a memory cache. However, having a basic system in place makes debugging much easier because a programmer can focus on one device at a time.660Operating System DesignA1.3.14  Port The Network Stack, Including Internet ProtocolsBecause networking has become fundamental, network protocols are an essentialpart of an operating system. Some embedded systems that use network communicationdo not have a local disk. Once an Ethernet driver is available, adding higher layer pro-tocols is straightforward. Porting can start with a network input process; UDP, IP, and ARP can then be added. Once UDP is available, Internet communication can be tested.A1.3.15  Port The Remote Disk And RAM Disk ModulesPorting a RAM disk driver is trivial, and allows a programmer to test the local file system. The remote disk driver provides access to stable storage, even if the platform does not have a disk. Thus, porting the RAM disk and remote disk is an easy step be-fore porting a file system.A1.3.16  Port The Local And Remote File System ModulesGiven an operational disk driver, porting a basic file system is straightforward. The first step consists of porting and testing functions that read and write index blocks; the second step consists of porting and testing code that builds the free lists of index and data blocks. Once the basic allocation functions are in place, a directory can be ad-ded and the file system tested.A1.3.17  Port The Xinu Shell And Other ApplicationsAlthough applications are convenient, a shell adds significant complexity to the system. Thus, one usually writes functions that test each operating system module and exercise special cases. Once the system is running, the final step consists of porting a shell and more general-purpose applications.A1.4 Programming To Accommodate ChangeHow should operating system designers contend with constant change? Can we anticipate future hardware? Can a system be designed and implemented to makechanges easier? Designers have been considering the questions for decades. Most early operating systems were created to match the hardware and written in assembly language. Each system was designed and built from scratch, with new abstractions and new mechanisms. As I/O devices (such as disks) and operating system abstractions (such as files) became standardized, designing a new system from scratch became much more expensive than adapting an existing system. Modern systems employ two tech-niques to accommodate change:Sec. A1.4        Programming To Accommodate Change 661Compile time: write source code that can generate multiple versions.Runtime: design facilities that allow an operating system to changedynamically.Compile time.One way to make a system adaptable consists of writing source code that uses conditional compilation to allow a given source program to be used on multiple systems. As a simplistic example, consider writing an operating system that must run on hardware with a real-time clock or hardware that has no real-time clock. A programmer can use the C preprocessor to conditionally compile source code according to the hardware. For example, if preprocessor variable RT_CLOCK has been defined, functions that use the clock should be compiled as usual. Otherwise, functions that depend on a clock should be replaced by versions that report an error. The sleep func-tion from Chapter 13 can be used to illustrate the idea. To accommodate both situa-tions, the code from the function can be rewritten as follows:ssyyssccaallllsslleeeepp((uuiinntt3322ddeellaayy//**TTiimmeettooddeellaayyiinnsseeccoonnddss**//)){{ ##iiffddeeffRRTT__CCLLOOCCKKiiff((ddeellaayy>>MMAAXXSSEECCOONNDDSS)){{rreettuurrnn((SSYYSSEERRRR));;}} sslleeeeppmmss((11000000**ddeellaayy));;rreettuurrnnOOKK;;##eellsseerreettuurrnnSSYYSSEERRRR;;##eennddiiff}}If constant RT_CLOCK has been defined, the C preprocessor generates the source code shown in Chapter 13, which is then compiled. If RT_CLOCK has not been de-fined, the C preprocessor eliminates the body of the sleep function and generates a sin-gle line of source code:rreettuurrnnSSYYSSEERRRR;;The chief advantage of conditional compilation lies in its efficiency: instead of using a test at runtime, the source code can be tailored to the specific hardware. Furthermore, the system does not contain extra code that is never used (which can be important in embedded systems). The chief disadvantage of conditional compilation is loss of reada-bility. In the case above, the code snippet is so small that the entire block of code fits onto a display. In a production system, the conditional block may span hundreds of lines of code. Furthermore, if two conditions interact, conditional code may be nested.662Operating System DesignRuntime.  The simplest way to increase runtime portability consists of using condi-tional execution. When it starts, the operating system gathers information about the hardware and places the information in a global data structure. For example, a Boolean variable in the global data structure might specify whether the hardware includes a real-time clock. Each operating system function is written to interrogate the data struc-ture and act accordingly. The chief advantage of using a runtime approach lies in gen-erality — an image can be run without being recompiled.The idea of runtime adaptation has been generalized by separating an operating system into two parts: a microkernel that contains basic process management functional-ity and a series of dynamically loaded kernel modules that extend the functionality. In theory, porting a microkernel to a new environment is easier than porting a complete system because porting can be done piecemeal. That is, the microkernel is ported first, and modules are ported later, as needed.A1.5 SummaryPortability is important because hardware continues to change. The steps requiredto port an operating system to a new environment follow the same pattern as the origi-nal design: port the lower levels of the system first, and then port successively higher levels.Operating system code can be written to increase portability. A compile-time ap-proach that uses conditional compilation achieves highest efficiency. A runtime ap-proach that uses conditional execution allows a single image to run on multiple versions of a platform. The most advanced runtime approach uses a microkernel plus dynamic kernel modules, which allows modules to be ported only if they are needed.Appendix 2Xinu Design Notes
A2.1 IntroductionThis appendix contains a set of informal notes that characterize Xinu and the underlying design. The notes are not intended as a tutorial, nor are they a complete description of the system. Instead, they provide a concise summary of characteristics and features.A2.2 OverviewEmbedded paradigm. Because it is intended for use in embedded systems, Xinu follows a cross-development paradigm. To develop create, edit, cross-compile, and cross-link Xinu software, a programmer uses a conventional computer, typically onethat runs a version of the Unix operating system, such as Linux. Output from cross-development software is a memory image. Once such an image has been created, a pro-grammer downloads the image to the target system (typically over a computer network). Finally, the programmer starts the image running on the target embedded system.Source code organization. Xinu software is organized into a handful of directories that follow the organization used with various Unix systems. Instead of placing all files for each module in a separate directory, files are grouped into a few directories. For ex-ample, all include files are placed in one directory, and files that constitute the kernel sources are placed in another. Device drivers are the exception — source files for a given device driver are placed in a subdirectory named for the device type. The sub-directories within a Xinu source tree are organized as follows:663664Operating System Design./compile The Makefile used to compile and link a Xinu image/bin Executable scripts invoked during compilation/binaries Compiled binaries for Xinu functions (.o files)./config Source for the configuration program and Makefile/conf.h Configuration include file (copied to ../include)/conf.c Configuration declarations (copied to ../system)./device Source code for device drivers, organized into onesubdirectory for each device type/tty Source code for the tty driver/rfs Source code for the remote file access system (both themaster device and remote file pseudo-devices/eth Source code for the Ethernet driver/rds Source code for the remote disk driver/... Directories for other device drivers./include All include files./shell Source code for the Xinu shell and shell commands./system Source code for Xinu kernel functions./lib Source code for library functions./net Source code for network protocol softwareA2.3 Xinu CharacteristicsNote: these are the notes kept during implementation; they are not intended to be atutorial introduction to Xinu.– The system supports multiple concurrent processes.– Each process is known by its process ID.– The process ID is used as an index into the process table.– The system provides counting semaphores.–  Each semaphore is known by its ID, which is used as an index into thesemaphore table.Sec. A2.3        Xinu Characteristics 665– The system supports a real-time clock that is used for round-robinscheduling of equal-priority processes and timed delays.– Each process is assigned a priority, which is used in scheduling; aprocess priority can be changed dynamically.–  The system supports multiple I/O devices and multiple types of I/O de-vices.– The system includes a set of device-independent I/O primitives.– The console device uses a tty abstraction in which characters arequeued both during input and output.–  The tty driver supports modes: raw mode passes characters transparent-ly, and cooked mode supports character echo, line editing with erasing backspace, flow control, and crlfmapping.– The system includes an Ethernet driver that can send and receive Eth-ernet packets; the driver uses DMA.– The system includes a local file system that supports concurrentgrowth of files without preallocation; the local file system only has a single-level directory structure.– Xinu also includes a remote file system mechanism that allows accessto files on a remote server.– The system includes a message passing mechanism used for inter-process communication; each message is one word long.– Processes are dynamic — a process can be created, suspended, restart-ed, and killed.– Xinu includes a low-level memory manager used to allocate and freeheap areas or process stacks, and a high-level memory manager used to create buffer pools, where each pool contains a set of fixed-size buffers.– Xinu includes a configuration program that generates a Xinu systemaccording to the specifications given; the configuration program allows one to choose a set of devices and set system parameters.– The system provides Internet access via TCP and UDP.A2.4 Xinu ImplementationFunctions and modules. The system sources are organized as a set of functions. In general, each file corresponds to a system call (e.g., file resume.c contains system call resume). In addition to the system call function, a file may contain utility functions needed by that system call.666Operating System DesignKey files. In most cases, each major system function is found in a separate file.For example, function resume is found in file resume.c. The following lists other filesthat play an important role in Xinu.Configuration A text file containing device information and constants thatdescribe the system and the hardware. The config program takes file Configuration as input and produces conf.c and conf.h.conf.h Generated by config, it contains declarations and constantsincluding defined names of I/O devices, such as CONSOLE.conf.c Generated by config, it contains initialization for the deviceswitch table.kernel.h  General symbolic constants and type declarations usedthroughout the kernel.prototypes.h   Prototype declarations for all system functions.xinu.h A master include file that includes all header files in thecorrect order. Most Xinu functions only need to includexinu.h.process.h       Process table entry structure declaration; state constants. semaphore.h   Semaphore table entry structure declaration; semaphore con-stants.tty.h Tty device control block, buffers, and other tty constants.bufpool.h       Buffer pool constants and format.memory.h  Constants and structures used by the low-level memorymanager.ports.h       Definitions by the high-level inter-process communicationmechanism.sleep.h Definitions for real-time delay functions.queue.h Declarations and constants for the general-purpose processqueue manipulation functions.resched.c The Xinu scheduler that selects the next process to run fromthe eligible set; resched calls the context switch.ctxsw.S The context switch that changes from one executing processto another; it consists of a small piece of assembly code.initialize.c The system initialization function, sysinit, and other initiali-zation code as well as code for the null process (process 0).Sec. A2.4        Xinu Implementation 667userret.c The function to which a user process returns if the processexits. Userret must never return. It must kill the processthat executed it because the stack does not contain a legal frame or return address.platinit.c Platform-specific initialization.A2.5 Major Concepts And ImplementationProcess states.Each process has a state given by field prstate in its process table entry. Constants that define process states have names of the form PR_xxxx.  PR_FREE means the process entry is unused.  PR_READY means the process is linked into the ready list and is eligible for the processor.  PR_WAITmeans the process is waiting on a semaphore (given by prsem). PR_SUSP means the process is in hibernation; it is not on any list. PR_SLEEP means the process is in the queue of sleeping processes and will awaken after a timeout. PR_CURRmeans that the process is (the only one) currently running. The currently running process is not on the ready list. PR_RECV means the process is blocked waiting to receive a message; PR_RECTIM is like PR_RECV except the process is also sleeping for a specified time and will awaken if the timer expires or a message arrives, whichever happens first.Counting semaphores.Semaphores reside in the array semtab. Each entry in the array corresponds to a semaphore and has a count (scount) and state (sstate). The state is S_FREE if the semaphore slot is unassigned, and S_USED if the semaphore is in use. If the count is negative P then the head and tail fields of the entry in the semaphore table point to the head and tail of a FIFO queue of P processes waiting for the semaphore. If the count is nonnegative P then no processes are waiting and the queue is empty.Blocked processes.A process that is blocked for any reason is not eligible to use the pro-cessor. Any action that blocks the current processes forces it to relinquish the processor and allow another process to execute. A process that is blocked on a semaphore is on the queue for the semaphore, and a process blocked for a timed delay is on the queue of sleeping processes. Other blocked processes are not on a queue. Function ready moves a blocked process to the ready list and makes the process eligible to use the processor.Sleeping processes. A process calls sleep to delay for a specified time. The process is ad-ded to a delta list of sleeping processes. A process may only put itself to sleep.Process queues and ordered lists.There is a single data structure used for all process lists.The structure contains entries for the head and tail of each list as well as an entry for each process. The first NPROC entries in the table (0 to NPROC-1) correspond to the NPROC processes in the system; successive entries in the table are allocated in pairs, where each pair forms the head and tail of a list.The advantage of keeping all heads and tails in the same data structure is that enqueuing, dequeuing, testing for empty/nonempty, and removing from the middle (e.g., when a process668Operating System Designis killed) are all handled by a small set of functions (files queue.c and queue.h). An emptyqueue has the head and tail pointing to each other. Testing whether a list is empty is trivial. Lists can be ordered or may be FIFO; each entry has a key that is ignored if the list is FIFO.Null process. Process 0 is a null process that is always available to run or is running. Care must be taken so that process 0 never executes code that could cause it to block (e.g., it can-not wait for a semaphore). Because the null process may be running during interrupts, inter-rupt code may never wait for a semaphore. When the system starts, the initialization code creates a process to execute main and then becomes the null process (i.e., executes an infi-nite loop). Because its priority is lower than that of any other process, the null process loop executes only when no other process is ready.Netin process. The network input process, netin repeatedly reads and demultiplexes incom-ing packets. Netin must not block or all network input stops. Therefore, if an Internet pro-tocol requires replies (e.g., a response to an ICMP ping request), the outgoing packet isplaced on a queue for the IP output process, ipout.Operating System Design
Douglas Comer
ComerThe Xinu Approach
Second EditionOperating System Design
The Xinu Approach
Second EditionOperating System Design
Second Edition
With Intel and ARM Examples
• Access online or download to your smartphone, tablet or PC/Mac
• Search the full text of this and other titles you own
• Make and share notes and highlights
• Copy and paste text and ﬁgures for use in your own documents
• Customize your view by changing font size and layoutWITH VITALSOURCE®
EBOOK
Widely lauded for avoiding the typical black box approach found in other operating system textbooks, the first edition of this bestselling book taught readers how an operating system works and explained how to build it from the ground up. Continuing to follow a logical pattern for system design, Operating System Design: The Xinu Approach, Sec-ond Edition removes the mystery from operating system design and consolidates the body of material into a sys-tematic discipline. It presents a hierarchical design paradigm that organizes major operating system components in an orderly, understandable manner. The book guides readers through the construction of a conventional process-based operating system using prac-tical, straightforward primitives. It gives the implementation details of one set of primitives, usually the most popu-lar set. Once readers understand how primitives can be implemented on conventional hardware, they can then easily implement alternative versions.The text begins with a bare machine and proceeds step-by-step through the design and implementation of the Xinu operating system. The Xinu code runs on many hardware platforms. This second edition has been completely rewritten to contrast operating systems for RISC and CISC processors. Encouraging hands-on experimentation, the book provides updated code throughout and examples for two low-cost experimenter boards: BeagleBone Black from ARM and Galileo from Intel.Features• Covers topics in the order a designer follows when building a system• Uses inexpensive embedded platforms from ARM and Intel• Describes the main components in the design hierarchy • Presents example software that illustrates the functions provided by each hierarchy level• Gives readers the foundation to implement alternative versions of primitives• Includes many practical examples and exercises that facilitate hands-on learning with the code• Offers updated code and other information on the author’s websiteComputer Science & Engineering
K25117www.crcpress.com
K25117_cover.indd   1 1/6/15   10:33 AM
